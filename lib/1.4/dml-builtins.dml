/*
  Â© 2013 Intel Corporation
  SPDX-License-Identifier: 0BSD
*/

dml 1.4;

provisional simics_util_vect;
bitorder le;

loggroup Register_Read;
loggroup Register_Write;
header %{
    #include <simics/dmllib.h>
%}

import "simics/device-api.dml";
import "simics/devs/io-memory.dml";
import "simics/model-iface/bank-instrumentation.dml";
import "simics/model-iface/int-register.dml";
import "simics/model-iface/register-view.dml";
import "simics/model-iface/register-view-read-only.dml";
import "simics/model-iface/transaction.dml";
import "simics/util/hashtab.dml";
import "simics/util/bitcount.dml";

import "simics/simulator/python.dml";
import "simics/simulator/sim-get-class.dml";

constant false = (1 == 0);
constant true = (0 == 0);

param dml_1_2 = false;
param dml_1_4 = true;

constant unmapped_offset = 0xffff_ffff_ffff_ffff;

param NULL auto;

// Handy macros and types
extern int strcmp(const char *__s1, const char *__s2);
extern void *memset(void *__s, int __c, size_t __n);
extern typedef uint64_t uintptr_t;

extern typedef struct { } conf_object_t;

extern char *MM_STRDUP(const char *s);
extern void MM_FREE(void *m);

extern size_t strlen(const char *s);
extern char *strcpy(char *s, const char *s);
extern void *memcpy(void *dest, const void *src, size_t n);

extern const atom_t ATOM_LIST_END;


extern char *_DML_describe_uint64_event(const char *base, uint64 data);

extern typedef struct {
} _callback_entry_t;

extern typedef struct {
} _connection_entry_t;

extern typedef _callback_entry_t * vect _callback_vect_t;
extern typedef _connection_entry_t * vect _connection_vect_t;

extern typedef struct {
    const char *logname;
    const uint32 *dimsizes;
    uint32 dimensions;
    uint32 id;
} _id_info_t;

extern const _id_info_t *_id_infos;

extern typedef struct {
    uint32 id;
    uint32 encoded_index;
} _identity_t;
extern typedef struct {
    void *trait;
    _identity_t id;
} _traitref_t;

extern bank_callback_handle_t _register_before_read(
    conf_object_t *bank,
    conf_object_t *connection,
    uint64 offset,
    uint64 size,
    before_read_callback_t before_read,
    void *user_data,
    _connection_vect_t *connections,
    _callback_vect_t *anonymous_callbacks);
extern bank_callback_handle_t _register_after_read(
    conf_object_t *bank,
    conf_object_t *connection,
    uint64 offset,
    uint64 size,
    after_read_callback_t after_read,
    void *user_data,
    _connection_vect_t *connections,
    _callback_vect_t *anonymous_callbacks);
extern bank_callback_handle_t _register_before_write(
    conf_object_t *bank,
    conf_object_t *connection,
    uint64 offset,
    uint64 size,
    before_write_callback_t before_write,
    void *user_data,
    _connection_vect_t *connections,
    _callback_vect_t *anonymous_callbacks);
extern bank_callback_handle_t _register_after_write(
    conf_object_t *bank,
    conf_object_t *connection,
    uint64 offset,
    uint64 size,
    after_write_callback_t after_write,
    void *user_data,
    _connection_vect_t *connections,
    _callback_vect_t *anonymous_callbacks);

extern attr_value_t _get_connections(_connection_vect_t *connections);
extern bool _move_before(conf_object_t *connection, conf_object_t *before,
                         _connection_vect_t *connections);

extern void _remove_callback(bank_callback_handle_t callback,
                             _connection_vect_t *connections,
                             _callback_vect_t *anonymous_before_read,
                             _callback_vect_t *anonymous_after_read,
                             _callback_vect_t *anonymous_before_write,
                             _callback_vect_t *anonymous_after_write);

extern void _remove_connection_callbacks(conf_object_t *bank,
                                         conf_object_t *connection,
                                         _connection_vect_t *connections);
extern void _enable_connection_callbacks(conf_object_t *connection,
                                         _connection_vect_t *connections);
extern void _disable_connection_callbacks(conf_object_t *connection,
                                          _connection_vect_t *connections);

extern void _callback_before_read(conf_object_t *bank,
                                  conf_object_t *initiator,
                                  bool *inquiry,
                                  physical_address_t *offset,
                                  physical_address_t size,
                                  _connection_vect_t *connections,
                                  _callback_vect_t *anonymous_callbacks);
extern void _callback_after_read(conf_object_t *bank,
                                 conf_object_t *initiator,
                                 physical_address_t *offset,
                                 physical_address_t size,
                                 uint64 *value, bool *success,
                                 _connection_vect_t *connections,
                                 _callback_vect_t *anonymous_callbacks);
extern void _callback_before_write(conf_object_t *bank,
                                   conf_object_t *initiator,
                                   physical_address_t *offset,
                                   physical_address_t size,
                                   uint64 *value,
                                   bool *suppress,
                                   _connection_vect_t *connections,
                                   _callback_vect_t *anonymous_callbacks);
extern void _callback_after_write(conf_object_t *bank,
                                  conf_object_t *initiator,
                                  physical_address_t *offset,
                                  physical_address_t size,
                                  bool *success,
                                  _connection_vect_t *connections,
                                  _callback_vect_t *anonymous_callbacks);

extern void _cancel_simple_events(conf_object_t *obj, _identity_t id);
extern void _register_attributes(conf_object_t *obj, _identity_t id);

/**
# Libraries and Built-ins

Most standard functionality in Device Modeling Language (DML) is implemented in
templates. Built-in
templates can be categorized as follows:

* Each object type has a corresponding template which is instantiated for all
  objects of that type. For instance, the template `register` is automatically
  instantiated in all registers. All such templates inherit the `object`
  template, and define the `objtype` parameter to the name of the object type,
  e.g. `"register"` for registers.


* Some templates primarily provide a standard implementation of some
  behaviour. For instance, the `uint64_attr` template can be
  applied on `attribute` objects to make it a simple integer
  attribute.

* Some templates primarily specify a programming interface, typically by
  providing an abstract or overrideable method or parameter. Such templates
  are often named like the provided member. For instance, objects
  that implement the `init` template provide the abstract method
  `init`. Interface templates have a number of uses:
  * In some cases, an interface template extends an existing
    template, altering its default behaviour to make sure its
    interface method is called. Often, this means that when you
    provide an implementation of an interface method,
    you *must* instantiate the corresponding template;
    otherwise, the method will not be called. For instance, if you
    implement the `write` method in a register, it is not called
      by default upon a write access; however, if you instantiate
      the `write` template in the register, then the register's
      behaviour is altered to call the
      `write` method. Thus, in order to provide custom
      side-effects on a write, you must write something like:
    ```
    register r @ 0 is write { method write(uint64 value) { default();
    log info: "wrote r"; } }
    ```


  * When writing a method or parameter override
    *inside a template*, you must
    explicitly instantiate the template you are overriding in order to specify
    that your declaration takes precedence over the default implementation. If
    your template is intended for a specific object type, then it is sufficient
    to override that template, but it is often better to override a more
    specific template if possible. For instance, the `init_val`
    parameter belongs to the `init_val` template, which is
    inherited by all registers. So a template that overrides this parameter
    may be implemented as follows:

    ```
    template init_to_ten is register {
        param init_val = 10;
    }
    ```

    However, it is even better to only inherit the `init_val`
    template:

    ```
    template init_to_ten is init_val {
        param init_val = 10;
    }
    ```

    The latter improves efficiency and
    permits `init_to_ten` to also be used on fields.


  * Similarly, if you write a template that needs to *access* some
    member of the object, then it must inherit a template that provides that
    member. For instance:
    ```
    template log_on_change is (write, get, name) {
        method write(uint64 value) {
            if (this.get() != value) {
                log info: "%s changed!", this.name;
            }
            default();
        }
    }
    ```


    Again, it would also work to inherit `register` instead of
    `get` and `name`, but at the cost of reduced
    flexibility and efficiency.
*/

is device;

/**

## Universal templates
The following templates are applicable to all object kinds:

### name

Provides a string parameter `name`, containing the name of the
object, as exposed to the end-user. This parameter is typically used in log
messages and names of configuration attributes. The name can be overridden
in order to hide confidential information from the end-user.

*/
template name {
    // name exposed to end-user, in attribute names etc
    param name : const char *;
    param name default _ident;
}

/**

### desc

Provides a string parameter `desc`, with a short description in plain text. By
convention, this should preferably be a few descriptive words, but may also be
a long name. The description can appear during simulation, when inspecting the
device, and also serves as a docstring that enriches the DML source code. The
parameter's default value is `undefined`. The `desc` parameter has a short-hand
syntax described in section [Object
Declarations](language.html#object-declarations).

Also provides a string parameter `shown_desc`, which is the string
actually exposed to the end-user during simulation. This parameter defaults to
`desc`, and can be overridden in order to hide confidential information
from the end-user.

See also [template
`documentation`](#documentation).
*/
template desc {
    param desc default undefined;
    param shown_desc default defined(desc) #? desc #: NULL;
}

/**
### shown\_desc

A subtemplate of [`desc`](#desc) that makes the `shown_desc` parameter a typed
parameter. This is inherited by objects that need to access `shown_desc` from
the context of a shared method.
*/
template shown_desc is desc {
    param shown_desc : const char *;
}

/**

### documentation

Provides a string parameter `documentation`, with a longer
description. The documentation may appear when extracting documentation from
the device.

If you have the *Documentation and Packaging* package and intend to
generate Simics reference documentation for the device then the
`documentation` string must follow the Simics documentation XML format,
otherwise you will get a syntax error during the documentation build. See the
*Writing Documentation* application note.

Also provides a string parameter `shown_documentation`, defaulting to
`documentation`. This parameter is similar to `shown_desc` in the [desc](#desc)
template, and is mainly a convenient way to suppress documentation.

*/
template documentation {
    param documentation default undefined;
    param shown_documentation default documentation;
}

/**
### limitations

Provides a string parameter `limitations`, describing limitations in
the implementation of this object. The documentation may appear when extracting
documentation from the device.

If you have the *Documentation and Packaging* package and intend to
generate Simics reference documentation for the device then the
`limitations` string must follow the Simics documentation XML format,
otherwise you will get a syntax error during the documentation build. See the
*Writing Documentation* application note.

Also provides a string parameter `shown_limitations`, defaulting to
`limitations`. This parameter is similar to `shown_desc`, and
is mainly a convenient way to suppress documentation.
*/
template limitations {
    param limitations default undefined;
    param shown_limitations default limitations;
}

/**
### init

Provides an abstract method `init`, which is called when the
device is created, *before* any attributes have been
initialized. Typically used to initialize a default value, or to set up data
structures.

The method `init` is automatically called on all objects that implement the
`init` template. The order in which `init` of objects are called is not
defined, except that `init` of a particular object is guaranteed to be called
before `init` of any of its parent objects. In particular, `init` of the device
object will be called only after all other implementations of `init`.

*/
template init {
    param _each_init : sequence(init);
    shared method _rec_init() {
        foreach obj in (this._each_init)
            obj._rec_init();
        this.init();
    }
    // Perform local initialization (allocation etc.)
    shared method init();
    param _each_init = each init in (this);
}

/**
### post\_init

Provides an abstract method `post_init`, which is called when the
device is created, *after* any attributes have been
initialized. Typically used to establish connections to other devices, or to
set up data structures that depend on configured attribute values.

The method `post_init` is automatically called on all objects that
implement the `post_init` template.
*/
template post_init {
    param _each_post_init : sequence(post_init);
    shared method _rec_post_init() {
        foreach obj in (this._each_post_init)
            obj._rec_post_init();
        this.post_init();
    }
    // Perform local finalization
    shared method post_init();
    param _each_post_init = each post_init in (this);
}

/**
### destroy
Provides an abstract method `destroy`, which is called when the
device is being deleted. This provides a means to clean up resources associated
with the device instance that are not managed by DMLC (and `destroy` should not
be used for any other purpose). This typically amounts to invoking
[`delete`](language.html#delete-statements) on any device state that has been
dynamically allocated using [`new`](language.html#new-expressions).

The method `destroy` is automatically called on all objects that implement the
`destroy` template. The order in which `destroy` of objects are called is not
defined, except that `destroy` of a particular object is guaranteed to be
called before `destroy` of any of its parent objects.
In particular, `destroy` of the device object will be called only after all
other implementations of `destroy`.

Usage notes:
* While the device is being deleted, it is not allowed to communicate
with any other Simics object (whether that is by accessing `connect`ed devices
or by leveraging the Simics API.) This includes even the device's own clock;
don't attempt to post or cancel time/cycle-based events in `destroy()`
(including posting events using `after` with a time/cycle delay). The
cancellation of such events is handled automatically, before the `destroy()`
calls are invoked. The use of `.cancel_after()` inside `destroy()` is tolerated
(even if almost always redundant.)
* Exiting Simics, even gracefully, will not perform device deletion and cause
`destroy()` to be called on its own. Simics instead simply relies on all
resources being released by virtue of the process terminating. This means that
side-effects within `destroy()` such as logging will not be visible upon
program exit unless deletion is explicitly performed beforehand &mdash; hence
why `destroy` should *only* be used to ensure resources get cleaned up.

> [!NOTE]
> the `destroy` template can't be instantiated for
> `event` objects. This is because `event` objects, through the
> `custom_time_event` or `custom_cycle_event` template, may already require
> defining a method named `destroy` whose purpose is different from the one
> required by the `destroy` template. To work around this limitation, you may
> declare a `group` within the `event` object that instantiates the `destroy`
> template instead.
*/
template destroy {
    param _each_destroy : sequence(destroy);
    param _each_destroy = each destroy in (this);
    shared method _rec_destroy() {
        foreach obj in (this._each_destroy)
            obj._rec_destroy();
        this.destroy();
    }
    // Perform local destruction (deallocation etc.)
    shared method destroy();

    #if (this.objtype == "event") {
        error "event objects may not instantiate the 'destroy' template";
    }
}

/**
### object

Base template, implemented by all objects. Inherits the templates
[`name`](#name), [`desc`](#desc), [`documentation`](#documentation) and
[`limitations`](#limitations). Provides the following additional parameters,
which cannot be overridden:

* `this` (reference): Always refers to the current object, i.e., the
  nearest enclosing object definition.

* `objtype`: string constant describing the object type, e.g. `"register"`

* `parent` (reference or `undefined`): Always refers to the parent
  (containing) object. Has the value `undefined` in the `device` object.

* qname: The fully qualified name, including indices, such as
  `some_bank.r0`. Constructed from the `name` parameter.  In the
  device object, this is equal to the `name` parameter.

* dev: The top-level `device` object

* templates: see [Template-Qualified Method Implementation
  Calls](language.html#template-qualified-method-implementation-calls).

* indices: List of local indices for this object. For a non-array
  object, this is the empty list. In a register array of size N, it is
  a list with one element, a non-negative integer smaller than N. The
  parameter is *not* cumulative across the object hierarchy, so for a
  single field inside a register array, the value is the empty list.

* Each array has an *individual index parameter*, to make it possible
  to refer to both inner and outer indexes when arrays are nested
  (cf. the `indices` parameter, above). The parameter name is
  specified in the array declaration; for instance, the declaration
  `register regs[i < 4][j < 11];` defines two index parameters, `i` and `j`.
  In this case, the `indices` parameter is `[i, j]`.

The `object` template provides the non-overridable method `cancel_after()`,
which cancels all pending events posted using `after` which are associated with
the object (any events associated with subobjects are unaffected).

There are no other methods common for all objects, but the methods `init`,
`post_init`, and `destroy` are automatically called on all objects that
implement the [`init`](#init), [`post_init`](#post_init), and
[`destroy`](#destroy) template, respectively.

*/
template object is (name, _qname, desc, documentation, limitations) {
    // identifier used in DML code
    param _ident auto;

    param objtype;
    // Does this DML object correspond to a Simics object?
    param _is_simics_object;
    param parent                    auto;

    // the closest ancestor that is not a group.
    // Can be softcoded, but that would have too much of a performance impact
    //
    // param _nongroup_parent = defined(parent)
    //     #? parent.objtype == "group" #? parent._nongroup_parent #: parent
    //     #: undefined;
    param _nongroup_parent auto;

    // The total number of dimensions this object has relative to the closest
    // ancestor that has a corresponding a Simics object. 0 if the object
    // itself corresponds to a Simics object.
    param _object_relative_dims     = _is_simics_object #? 0
                                    #: parent._object_relative_dims
                                       + indices.len;

    param indices                   auto;

    param qname                     auto;
    param _static_qname             auto;

    param dev                       = defined parent #? parent.dev #: this;

    // For template-qualified method implementation calls
    param templates                 auto;

    shared method cancel_after() {
        local object ref = this;
        _cancel_simple_events(dev.obj, cast(&ref, _traitref_t *)->id);
    }
}

/**
## Device objects

The top-level scope of a DML file defines the *device object*, defined by the
template `device`. This template inherits the [`init`](#init),
[`post_init`](#post_init), and [`destroy`](#destroy) templates.

The `device` template contains the following methods:

* `init()`: Called when the device object is loaded, but before its
  configuration-object attributes have been initialized.

* `post_init()`: Called when the device object is loaded, *after* its
  configuration-object attributes have been initialized.

* `destroy()`: Called when the device object is being deleted.

The `device` template contains the following parameters:

* `classname` *[string]*: The name of the Simics configuration object class defined
  by the device model. Defaults to the name of the device object.

* `register_size` *[integer | undefined]*: The default size (width) in bytes
  used for `register` objects; inherited by `bank` objects. The default value
  is `undefined`.

* `byte_order` *[string]*: The default byte order used when accessing registers
  wider than a single byte; inherited by `bank` objects. Allowed values are
  `"little-endian"` and `"big-endian"`. The default value is `"little-endian"`.

* `be_bitorder` *[bool]*: The default value of the `be_bitorder` in banks.  The
  default value is `true` if the DML file containing the `device` statement
  declares `bitorder be;`, and `false` otherwise.

* `use_io_memory` *[bool]*: The default value of the `use_io_memory` parameter
  in banks. The current default value is `true`, but in future Simics versions
  it will be `false`.

* `obj` *[conf_object_t *]*: A pointer to the `conf_object_t` C struct
  that Simics associates with this device instance

* `simics_api_version` *[string]*: The Simics API version used when building
  this device, as specified by the `--simics-api` command-line argument;
  e.g. `"6"` for the Simics 6 API.

*/
template device {
    is object;
    // _init and _post_init are called automatically on object instantiation
    is init;
    is post_init;
    // _destroy is called automatically on object deletion
    is destroy;

    // structural info
    param objtype = "device";
    param _is_simics_object = true;

    param simics_api_version auto;

    param _compat_broken_unused_types auto;
    param _compat_broken_conditional_is auto;
    param _compat_port_proxy_ifaces auto;
    param _compat_port_proxy_attrs auto;
    param _compat_function_in_extern_struct auto;
    param _compat_optional_version_statement auto;
    param _compat_port_obj_param auto;
    param _compat_io_memory auto;
    param _compat_shared_logs_on_device auto;
    param _compat_suppress_WLOGMIXUP auto;
    param _compat_legacy_attributes auto;
    param _compat_lenient_typechecking auto;
    param _compat_no_method_index_asserts auto;
    param _compat_meaningless_log_levels auto;
    param _compat_dml12_inline auto;
    param _compat_dml12_not auto;
    param _compat_dml12_goto auto;
    param _compat_dml12_misc auto;
    param _compat_dml12_int auto;
    param _compat_experimental_vect auto;
    param _compat_warning_statement auto;

    // automatic parameters
    param obj                       auto;
    param classname                 default name;

    // register defaults
    param register_size             default undefined;
    param byte_order                default "little-endian";
    param _be_bitorder            auto;
    param be_bitorder             default _be_bitorder;
    param log_group                 = undefined;

    param use_io_memory             default _compat_io_memory;
    // this was available in DML 1.2; defensively reserved in 1.4
    param banks                     = undefined;
    // this carried semantics in DML 1.2; deprecated in 1.4
    param _confidentiality          = undefined;

    method _init() { _rec_init(); }
    method _post_init() { _rec_post_init(); }
    method _destroy() { _rec_destroy(); }
    method init() default {}
    method post_init() default {}
    method destroy() default {}
}

/**
## Group objects

Group objects are generic container objects, used to group other objects.
They can appear anywhere in the object hierarchy, but some object types
(currently `implement` and `interface`) may not have a group
as parent.

The `group` template contains no particular methods or parameters other
than what is inherited from the [`object`](#object) template.

You may not declare any `bank`, `port` or `subdevice` underneath any group
named "bank" or "port". This is to avoid namespace clashes in Simics.
*/
template group is object {
    param objtype = "group";
    param _is_simics_object = false;
    param log_group = undefined;
    param _simics_namespace_clash =
        this.name == "bank" || this.name == "port"
        || (parent.objtype == "group"
            #? parent._simics_namespace_clash #: false);
}

session bool _issuing_state_callbacks = false;
session bool _has_state_callbacks = false;
// Used by "X then Y" log level feature
session ht_int_table_t _subsequent_log_ht;

extern typedef struct { } dml_qname_cache_t;
// Used by qname
session dml_qname_cache_t _qname_cache;

extern typedef struct { } _dml_detached_hook_queue_t;
// Used by hooks
session _dml_detached_hook_queue_t *_detached_hook_queue_stack;

extern typedef struct {} _dml_attr_parent_obj_proxy_info_t;

// Shared parameters for attributes, registers and connects, which all produce
// attributes. Methods get_attribute and set_attribute are abstract.
template _conf_attribute is object {
    shared method set_attribute(attr_value_t value) -> (set_error_t);
    shared method get_attribute() -> (attr_value_t);

    param configuration     default "optional";
    #if (configuration != "required" && configuration != "optional"
         && configuration != "pseudo" && configuration != "none") {
        error "'configuration' parameter must be 'required', 'optional', "
            + "'pseudo', or 'none'";
    }

    param persistent default false;
    param internal   default (!defined documentation && !defined desc);

    param readable : bool;
    param readable default configuration != "none";
    param writable : bool;
    param writable default configuration != "none";


    // All of below internal parameters are for use during attribute
    // registration

    // The base type of the Simics attribute. Required parameter
    param _attr_type : const char *;

    // The name of the attribute in Simics
    param _attr_name : const char *;
    param _attr_name auto;

    // '*_parent_obj_class' is the class of the parent Simics object containing
    // the attribute
    param _parent_obj_class : conf_class_t **;
    param _parent_obj_class auto;

    // All information needed for the creation of proxy attribute for this
    // attribute, leveraged when the parent object is a bank or port.
    param _parent_obj_proxy_info : _dml_attr_parent_obj_proxy_info_t;
    param _parent_obj_proxy_info auto;

    // Defined by the object template. We need it typed to leverage it in
    // attribute registration.
    param _object_relative_dims : uint32;

    // If the attribute is an array, indicates whether it should be allowed
    // to set only part of the array.
    param _attr_allow_cutoff : bool;
    param _attr_allow_cutoff = (objtype == "connect"
                                && configuration == "optional");

    // The documentation for the Simics attribute.
    param _documentation : const char *;
    param _documentation = (   defined(documentation)
                            #? documentation
                            #: shown_desc != NULL
                            #? shown_desc
                            #: objtype == "register"
                            #? "register " + _static_qname
                            #: "Undocumented")
                         + (   objtype == "connect"
                            #? defined(_interfaces_doc)
                            #? _interfaces_doc
                            #: "" #: "");

    // The flags for the Simics attribute.
    param _flags : attr_attr_t;
    param _flags = (   configuration == "required"
                    #? Sim_Attr_Required
                    #: configuration == "optional"
                    #? Sim_Attr_Optional
                    #: configuration == "pseudo"
                    #? Sim_Attr_Pseudo
                    #: 0)
                 | (persistent #? Sim_Attr_Persistent #: 0)
                 | (internal #? Sim_Attr_Internal #: 0);

    // Whether the attribute should be registered
    param _should_be_registered : bool;
    param _should_be_registered = configuration != "none";
}

extern typedef size_t ptrdiff_t;

/**
## Attribute objects

The `attribute` template contains the following methods:

<dl><dt>

<small>get() -&gt; (attr\_value\_t)</small>
</dt><dd>

Abstract method. Returns the value of the attribute.
</dd><dt>

<small>set(attr\_value\_t value) throws</small>
</dt><dd>

Abstract method. Sets the value of the attribute. If the provided value is
not allowed, use a `throw` statement to signal the error.
</dd><dt>

<small>get\_attribute -&gt; (attr\_value\_t), set\_attribute(attr\_value\_t value) -&gt; (set\_error\_t)</small>
</dt><dd>

Not intended to be used directly. Called by Simics for reading and
writing the attribute value. Calls the `get`
and `set` methods.
</dd></dl>

The `attribute` template contains the following parameters:

<dl><dt>

type [string | undefined]
</dt><dd>

A Simics configuration-object attribute type description string,
such as `"i"` or `"[s*]"`, specifying the type of the
attribute. (See the documentation of
`SIM_register_typed_attribute` in the *Model Builder
Reference Manual* for details.) For simple types this can easily be set
by standard attribute templates.
</dd><dt>

configuration [`"required"` | `"optional"` | `"pseudo"` | `"none"`]
</dt><dd>

Specifies how Simics treats the attribute. The default value is
`"optional"`. A *required* attribute must be initialized to a
value when the object is created, while an *optional* attribute can be
left undefined. In both cases, the value is saved when a checkpoint
is created. For a *pseudo*-attribute, the value is *not* saved
when a checkpoint is created (and it is not required to be initialized upon
object creation). Setting the value to `"none"` suppresses creation of
the attribute. This is seldom useful in attribute objects, but can be used in
related object types like `register` to suppress
checkpointing.
</dd><dt>

persistent [bool]
</dt><dd>

If this parameter is `true`, the attribute will be treated
as persistent, which means that its value will be saved
when using the `save-persistent-state` command.  The default
value is `false`.
</dd><dt>

readable [bool]
</dt><dd>

If false, the attribute cannot be read. This can only be used if
the `configuration` parameter is set
to `"pseudo"`. Normally set by the `write_only_attr` template.

</dd><dt>

writable [bool]
</dt><dd>

If false, the attribute cannot be written. This should normally be
set by instantiating the `read_only_attr` template, and requires
  that the `configuration` parameter
  is `"pseudo"`. Normally set by
  the `read_only_attr` template.

</dd><dt>

internal [bool]
</dt><dd>

If this parameter is `true`, the attribute will be treated
as internal, meaning that it will be excluded from documentation.
The default value is `true` if the `documentation` and `desc` parameters
are undefined, and `false` otherwise.
</dd></dl>
 */
template attribute is _conf_attribute {
    shared method get() -> (attr_value_t);
    shared method set(attr_value_t val) throws;
    param objtype = "attribute";
    param _is_simics_object = false;

    param _attr_type     = type;
    param type;
    param allocate_type = undefined;
    // limitations for attributes are not recognized
    param limitations = undefined;

    shared method set_attribute(attr_value_t value) -> (set_error_t) default {
        try {
            set(value);
            return Sim_Set_Ok;
        } catch {
            return Sim_Set_Illegal_Value;
        }
    }

    shared method get_attribute() -> (attr_value_t) {
        return get();
    }
}

extern typedef struct {
    const char *name;
    const char *type;
    const char *doc;
    conf_class_t *parent_obj_class;
    _dml_attr_parent_obj_proxy_info_t proxy_info;
    attr_attr_t flags;
    uint32 object_relative_dims;
    bool readable;
    bool writable;
    bool should_be_registered;
    bool allow_cutoff;
} _dml_attr_conf_info_t;

independent method _get_attribute_info(_conf_attribute attr)
    -> (_dml_attr_conf_info_t) {
    return {
        attr._attr_name, attr._attr_type, attr._documentation,
        attr._parent_obj_class ? *attr._parent_obj_class : NULL,
        attr._parent_obj_proxy_info, attr._flags, attr._object_relative_dims,
        attr.readable, attr.writable, attr._should_be_registered,
        attr._attr_allow_cutoff
    };
}

extern typedef struct {
    const _id_info_t *id_info;
    void *vtable;
    uint32 num;
    bool allow_cutoff;
} _dml_attr_getset_info_t;

extern typedef struct {
        conf_object_t obj;
        conf_object_t *dev;
        int ndims;
        const uint32 *indices;
} _port_object_t;

method _get_attribute_attr_trampoline(void *info) -> (attr_value_t) {
    return _get_attribute_attr(info, 0, 0);
}

independent method _get_attribute_attr_portobj_trampoline(
    conf_object_t *_portobj, void *_info)
    -> (attr_value_t) {
    local _port_object_t *portobj = cast(_portobj, _port_object_t *);
    local _dml_attr_getset_info_t *info =
        cast(_info, _dml_attr_getset_info_t *);
    local uint32 flat_index_offset = 0;
    local uint32 offset_coefficient = info->num;
    for (local uint32 i = 0; i < portobj->ndims; ++i) {
        offset_coefficient /= info->id_info->dimsizes[i];
        flat_index_offset += portobj->indices[i] * offset_coefficient;
    }

    return (&_get_attribute_attr)(portobj->dev, _info, portobj->ndims,
                                  flat_index_offset);
}

method _get_attribute_attr(const _dml_attr_getset_info_t *_conf_info,
                           uint32 start_dim, uint32 flat_index_offset)
    -> (attr_value_t) {
    local _dml_attr_getset_info_t conf_info = *_conf_info;
    local _id_info_t id_info = *conf_info.id_info;
    assert start_dim <= id_info.dimensions;

    if (id_info.dimensions - start_dim == 0) {
        local _traitref_t traitref = {conf_info.vtable,
                                      {id_info.id, flat_index_offset}};
        return cast(&traitref, _conf_attribute *)->get_attribute();
    }

    local size_t no_items = conf_info.num;
    for (local uint32 i = 0; i < start_dim; ++i) {
        no_items /= id_info.dimsizes[i];
    }
    local attr_value_t *items = new attr_value_t[no_items];
    local attr_value_t *items_buf = new attr_value_t[no_items];
    for (local int i = 0; i < no_items; ++i) {
        local _traitref_t traitref = {conf_info.vtable,
                                      {id_info.id, i + flat_index_offset}};
        items[i] = cast(&traitref, _conf_attribute *)->get_attribute();
    }
    for (local int i = cast(id_info.dimensions, int) - 1; i >= start_dim;
         --i) {
        local uint32 new_frag_size = id_info.dimsizes[i];
        local size_t new_no_items = no_items / new_frag_size;
        for (local int j = 0; j < new_no_items; ++j) {
            items_buf[j] = SIM_alloc_attr_list(new_frag_size);
            local attr_value_t *new_frag = SIM_attr_list(items_buf[j]);
            for (local int k = 0; k < new_frag_size; ++k) {
                new_frag[k] = items[j * new_frag_size + k];
            }
        }
        (items, items_buf) = (items_buf, items);
        no_items = new_no_items;
    }
    local attr_value_t to_ret = *items;
    delete items;
    delete items_buf;
    return to_ret;
}

method _set_attribute_attr_trampoline(attr_value_t *val, void *info)
                                  -> (set_error_t) {
    return _set_attribute_attr(info, 0, 0, val);
}

independent method _set_attribute_attr_portobj_trampoline(
    conf_object_t *_portobj, attr_value_t *val, void *_info) -> (set_error_t) {
    local _port_object_t *portobj = cast(_portobj, _port_object_t *);
    local _dml_attr_getset_info_t *info = cast(_info,
                                               _dml_attr_getset_info_t *);
    local uint32 flat_index_offset = 0;
    local uint32 offset_coefficient = info->num;
    for (local uint32 i = 0; i < portobj->ndims; ++i) {
        offset_coefficient /= info->id_info->dimsizes[i];
        flat_index_offset += portobj->indices[i] * offset_coefficient;
    }

    return (&_set_attribute_attr)(portobj->dev, _info, portobj->ndims,
                                  flat_index_offset, val);
}

method _set_attribute_attr(const _dml_attr_getset_info_t *_conf_info,
                           uint32 start_dim, uint32 flat_index_offset,
                           attr_value_t *val) -> (set_error_t) {
    local _dml_attr_getset_info_t conf_info = *_conf_info;
    local _id_info_t id_info = *conf_info.id_info;
    assert start_dim <= id_info.dimensions;
    if (id_info.dimensions - start_dim == 0) {
        local _traitref_t traitref = {conf_info.vtable,
                                      {id_info.id, flat_index_offset}};
        return cast(&traitref, _conf_attribute *)->set_attribute(*val);
    }

    local attr_value_t *items = new attr_value_t[conf_info.num];
    local attr_value_t *items_buf = new attr_value_t[conf_info.num];
    *items = *val;
    local size_t no_items = 1;
    local bool allow_cutoff = conf_info.allow_cutoff;

    for (local uint32 i = start_dim; i < id_info.dimensions; ++i) {
        local uint32 frag_size = id_info.dimsizes[i];
        local size_t new_no_items = no_items * frag_size;
        if (allow_cutoff) {
            for (local uint32 j = 0; j < no_items; ++j) {
                local uint32 subfrag_size = SIM_attr_is_list(items[j])
                                          ? SIM_attr_list_size(items[j])
                                          : 0;
                local attr_value_t *subfrags = subfrag_size > 0
                                             ? SIM_attr_list(items[j])
                                             : NULL;
                for (local uint32 k = 0; k < subfrag_size; ++k) {
                    /*% COVERITY copy_paste_error FALSE %*/
                    items_buf[j * frag_size + k] = subfrags[k];
                }
                for (local uint32 k = subfrag_size; k < frag_size; ++k) {
                    items_buf[j * frag_size + k] = SIM_make_attr_nil();
                }
            }
        } else {
            for (local uint32 j = 0; j < no_items; ++j) {
                local attr_value_t *subfrags = SIM_attr_list(items[j]);
                for (local uint32 k = 0; k < frag_size; ++k) {
                    items_buf[j * frag_size + k] = subfrags[k];
                }
            }
        }
        (items, items_buf) = (items_buf, items);
        no_items = new_no_items;
    }
    delete items_buf;
    for (local uint32 i = 0; i < no_items; ++i) {
        local _traitref_t traitref = {conf_info.vtable,
                                      {id_info.id, i + flat_index_offset}};
        local set_error_t status = cast(&traitref, _conf_attribute *)
                                   ->set_attribute(items[i]);
        if (status != Sim_Set_Ok) {
            delete items;
            return status;
        }
    }
    delete items;
    return Sim_Set_Ok;
}

extern typedef struct {} _vtable_list_t;
extern typedef struct {} _dml_port_object_assoc_t;

extern void *_DML_register_attributes(
    conf_class_t *, const _id_info_t *, const _dml_port_object_assoc_t *,
    const _vtable_list_t *, sequence(_conf_attribute),
    _dml_attr_conf_info_t (*)(_conf_attribute),
    attr_value_t (*get)(conf_object_t *, void *),
    set_error_t (*set)(conf_object_t *, attr_value_t *, void *),
    attr_value_t (*port_get)(conf_object_t *, void *),
    set_error_t (*port_set)(conf_object_t *, attr_value_t *, void *));

extern const _vtable_list_t *_each___conf_attribute;
extern const _dml_port_object_assoc_t *_port_object_assocs;

independent startup method _register_all_attributes() {
    _DML_register_attributes(SIM_get_class(dev.classname),
                             _id_infos,
                             _port_object_assocs,
                             _each___conf_attribute,
                             each _conf_attribute in (dev),
                             &_get_attribute_info,
                             &_get_attribute_attr_trampoline,
                             &_set_attribute_attr_trampoline,
                             &_get_attribute_attr_portobj_trampoline,
                             &_set_attribute_attr_portobj_trampoline);
}

/**
## Attribute templates

Four templates are used to create a simple checkpointable attribute with
standard types. Each store the attribute value in a member `val`,
provide default implementations of methods `get` and `set` according to the
type, and provide a default implementation of `init` that initializes
`val` using the `init_val` parameter also provided by the template (whose
default definition simply zero-initializes `val`.) These four templates are:

<dl><dt>

bool\_attr
</dt><dd>

boolean-valued attribute, `val` has type
`bool`
</dd><dt>

int64\_attr
</dt><dd>

integer-valued attribute, `val` has type
`int64`
</dd><dt>

uint64\_attr
</dt><dd>

integer-valued attribute, `val` has type
`uint64`
</dd><dt>

double\_attr
</dt><dd>

floating-point-valued attribute, `val` has type
`double`
</dd></dl>

In addition, three templates can be used to define a pseudo attribute,
and cannot be used with the above templates:

<dl><dt>

pseudo\_attr
</dt><dd>

Pseudo attribute. Will not be
checkpointed. Methods `get` and `set` are abstract.
</dd><dt>

read\_only\_attr
</dt><dd>

Pseudo attribute that cannot be written. Method `get` is
  abstract.
</dd><dt>

write\_only\_attr
</dt><dd>

Pseudo attribute that cannot be read. Method `set` is
  abstract
</dd></dl>

These templates are not compatible with the `bool_attr`, `uint64_attr`,
`int64_attr`, or `float_attr` templates.
*/
template bool_attr is (attribute, init) {
    param type = "b";
    param init_val : bool;
    param init_val default false;
    session bool val;
    shared method init() default {
        val = init_val;
    }
    shared method get() -> (attr_value_t) default {
        return SIM_make_attr_boolean(val);
    }
    shared method set(attr_value_t val) throws default {
        this.val = SIM_attr_boolean(val);
    }
}

template uint64_attr is (attribute, init) {
    param type = "i";
    param init_val : uint64;
    param init_val default 0;
    session uint64 val;
    shared method init() default {
        val = init_val;
    }
    shared method get() -> (attr_value_t) default {
        return SIM_make_attr_uint64(val);
    }
    shared method set(attr_value_t val) throws default {
        if (!SIM_attr_is_uint64(val)) {
            SIM_c_attribute_error("negative integer value: %lld",
                                  cast(SIM_attr_integer(val), int64));
            throw;
        }
        this.val = SIM_attr_integer(val);
    }
}

template int64_attr is (attribute, init) {
    param type = "i";
    param init_val : int64;
    param init_val default 0;
    session int64 val;
    shared method init() default {
        val = init_val;
    }
    shared method get() -> (attr_value_t) default {
        return SIM_make_attr_int64(val);
    }
    shared method set(attr_value_t val) throws default {
        if (!SIM_attr_is_int64(val)) {
            SIM_c_attribute_error("integer value too large: %llu",
                                  cast(SIM_attr_integer(val), uint64));
            throw;
        }
        this.val = SIM_attr_integer(val);
    }
}

template double_attr is (attribute, init) {
    param type = "f";
    param init_val : double;
    param init_val default 0.0;
    session double val;
    shared method init() default {
        val = init_val;
    }
    shared method get() -> (attr_value_t) default {
        return SIM_make_attr_floating(val);
    }
    shared method set(attr_value_t val) throws default {
        this.val = SIM_attr_floating(val);
    }
}

template pseudo_attr {
    is attribute;
    param configuration = "pseudo";
}

template read_only_attr is pseudo_attr {
    param writable = false;
    shared method set(attr_value_t val) throws {
        assert false;
    }
}

template write_only_attr is pseudo_attr {
    param readable = false;
    shared method get() -> (attr_value_t) {
        assert false;
    }
}

/**
## Connect objects

The `connect` template contains the following methods:

<dl><dt>

<small>validate(conf\_object\_t \*obj) -&gt; (bool)</small>
</dt><dd>

Called when Simics attempts to assign a new target object. If the return value
is `false`, the attempted connection will fail, and any existing connection
will be kept. The default is to return `true`.

If connecting to a port interface (rather than a port object), then
a session variable `port`, of type `char *`, is set to
the new port name during the `validate` call. This will be
removed in future versions of Simics.

</dd><dt>

<small>set(conf\_object\_t \*obj)</small>
</dt><dd>

Called after validation, to assign a new target object. Can be
overridden to add side-effects before or after the assignment
</dd><dt>

<small>get\_attribute -&gt; (attr\_value\_t),
set\_attribute(attr\_value\_t value) -&gt; (set\_error\_t)</small>
</dt><dd>

Internal, not intended to be used directly. Called by Simics for accessing
the attribute value.
</dd></dl>

The `connect` template contains the following parameters:

<dl><dt>

configuration [`"required"` | `"optional"` | `"pseudo"` | `"none"`]
</dt><dd>

Specifies how Simics treats the automatically created
[attribute](#attribute-objects)
corresponding to the connect object. The default value is `"optional"`.

The attribute can be set to a nil value only if this parameter is `"optional"`
or `"pseudo"`. In an array of connects, this applies element-wise.</dd><dt>

internal [bool]
</dt><dd>

Specifies whether the [attribute](#attribute-objects) should be internal.
</dd></dl>
*/
template connect is _conf_attribute {
    session conf_object_t *obj;
    session const char *port;

    shared method validate(conf_object_t *obj) -> (bool) default {
        return true;
    }

    param objtype = "connect";
    param _is_simics_object = false;
    // limitations for connects are not recognized
    param limitations = undefined;
    param _attr_type = configuration == "required" #? "o|[os]" #: "o|[os]|n";

    param readable = true;
    param writable = true;
    // a connect is configuration, not state
    param persistent = false;

    param _each_interface : sequence(interface);
    param _each_interface = each interface in (this);

    param _interfaces_doc auto;

    shared method set_attribute(attr_value_t value) -> (set_error_t) {
        local conf_object_t *obj = NULL;
        local const char *port = NULL;

        // Extract the new references
        if (SIM_attr_is_object(value))
            obj = SIM_attr_object(value);
        else if (SIM_attr_is_list(value)) {
            obj  = SIM_attr_object(SIM_attr_list_item(value, 0));
            port = SIM_attr_string(SIM_attr_list_item(value, 1));
        }

        // Exit early if there is no change.
        if (obj == this.obj && (
                this.port == NULL ? port == NULL
                : (port != NULL && strcmp(port, this.port) == 0)))
            return Sim_Set_Ok;

        // Check if the new setting is valid
        if (obj) {
            local bool valid = true;
            foreach iface in (this._each_interface) {
                if (iface._required) {
                    if (SIM_c_get_port_interface(obj, iface.name, port)
                        == NULL) {
                        if (port)
                            SIM_c_attribute_error(
                                "Interface '%s' not found for port '%s' in"
                                + " object '%s'",
                                iface.name, port, SIM_object_name(obj));
                        else
                            SIM_c_attribute_error(
                                "The %s object does not implement the"
                                + " required %s interface",
                                SIM_object_name(obj), iface.name);
                        valid = false;
                    }
                }
            }
            if (!valid)
                return Sim_Set_Interface_Not_Found;
            local const char *old_port = this.port;
            this.port = port;
            local bool ok = validate(obj);
            this.port = old_port;
            if (!ok) {
                return Sim_Set_Illegal_Value;
            }
        }

        // Commit the change
        if (this.port)
            MM_FREE(cast(this.port, void *));
        this.port = port ? MM_STRDUP(port) : NULL;
        /*% COVERITY var_deref_model %*/
        this.set(obj);
        return Sim_Set_Ok;
    }

    shared method set(conf_object_t *obj) default {
        this.obj = obj;
        foreach iface in (this._each_interface) {
            iface.val = obj == NULL ? NULL
                : SIM_c_get_port_interface(obj, iface.name, this.port);
        }
    }

    shared method get_attribute() -> (attr_value_t) {
        if (port) {
            return SIM_make_attr_list(2, SIM_make_attr_object(obj),
                                      SIM_make_attr_string(port));
        } else
            return SIM_make_attr_object(obj);
    }
}

/**
## Connect templates

A `connect` object can instantiate the template
`init_as_subobj`. This causes the connect to automatically
set itself to an automatically created object. This can be used to create
a private helper object.

The `init_as_subobj` template accepts one parameter,
`classname`. This defines the class of the automatically created object.

> [!NOTE]
> The subobject class defined by the `classname` parameter is looked up
> using `SIM_get_class` while the module of the device class is being
> loaded.
> This may cause problems if the subobject class is defined within the
> same module as the device class:
> if the device class is defined before the subobject class, then the subobject
> class will not yet be defined, and the `SIM_get_class` call will fail.
> This problem can be resolved by moving the subobject class to
> a separate module.

The template also overrides the `configuration` parameter to
`"none"` by default, which makes the connect invisible to the end-user.

The `init_as_subobj` inherits the [`init`](#init) and
[`connect`](#connect-objects) templates.
*/
template init_as_subobj is (connect, init) {
    param classname : const char *;
    param configuration default "none";
    method init() default {
        local int portname_len = this._nongroup_parent.objtype == "device"
            #? 0 #: strlen(this._nongroup_parent._qname()) + 1;
        local conf_object_t *o = SIM_object_descendant(
            this._nongroup_parent.obj, this._qname() + portname_len);
        if (o == NULL) {
            // should not happen
            log critical: "subobject %s not found",
                this._qname() + portname_len;
        }
        local set_error_t err = this.set_attribute(SIM_make_attr_object(o));
        if (err != Sim_Set_Ok) {
            // unfortunately, this error will be poor, since
            // the descriptive error is hidden in a SIM_c_attribute_error
            log critical: "failed to initialize %s", this._qname();
        }
    }
}

/**
## Interface objects

The `interface` template contains one parameter,
`required`. Defaults to `true`. If overridden to `false`,
the interface is optional and the parent `connect` object can
connect to an object that does not implement the interface.

The template provides a session variable `val` of type `const void
*`. It points to the Simics interface struct of the currently connected
object. If the interface is optional, then the variable can be compared to NULL
to check whether the currently connected object implements the interface.
*/
template interface is object {
    param _required : bool;
    session const void *val;

    param objtype = "interface";
    param _is_simics_object = false;

    param required                 default true;
    param _c_type                    = name + "_interface_t";

    // limitations for interfaces are not recognized
    param limitations = undefined;

    // internal, need indirection because typed parameters are considered
    // non-constant and DMLC wants 'required' to be constant
    // TODO: DMLC should take care of this
    param _required = required;
}

extern conf_object_t *_dmllib_port_obj_from_device_obj(
    conf_object_t *dev, const char *qname, const char *prefix);
/**
## Port objects

The `port` template exposes one parameter, `obj`.
When compiling with Simics API 5 or earlier, evaluates to dev.obj.
When compiling with Simics API 6 or newer, evaluates to the
`conf_object_t *` of the port's port object.
*/
template port is object {
    param objtype = "port";
    param _is_simics_object = true;
    // limitations for ports are not recognized
    param limitations = undefined;
    param obj = dev._compat_port_obj_param #? dev.obj #: _port_obj();

    #if (parent.objtype == "group"
         #? parent._simics_namespace_clash #: false) {
        error "Cannot declare a port underneath a group named 'port' or "
            + "'bank'";
    }

    session conf_object_t *_cached_port_obj;
    shared method _port_obj() -> (conf_object_t *) {
        if (this._cached_port_obj != NULL) {
            return this._cached_port_obj;
        }
        this._cached_port_obj = _dmllib_port_obj_from_device_obj(
            dev.obj, this._qname(), "port.");
        assert this._cached_port_obj != NULL;
        return this._cached_port_obj;
    }
}

/**
## Subdevice objects

The `subdevice` template exposes one parameter, `obj`, which evaluates to the
`conf_object_t *` of the Simics object that represents the subdevice.
*/

template subdevice is object {
    param objtype = "subdevice";
    param _is_simics_object = true;
    // limitations for subdevices are not recognized
    param limitations = undefined;
    param obj = _port_obj();

    session conf_object_t *_cached_port_obj;
    shared method _port_obj() -> (conf_object_t *) {
        if (this._cached_port_obj != NULL) {
            return this._cached_port_obj;
        }
        this._cached_port_obj = SIM_object_descendant(dev.obj, this._qname());
        assert this._cached_port_obj != NULL;
        return this._cached_port_obj;
    }
    #if (this.name == "port" || this.name == "bank") {
         error "A subdevice may not be named 'port' or 'bank'";
    }
    #if (parent.objtype == "group"
         #? parent._simics_namespace_clash #: false) {
        error "Cannot declare a subdevice underneath a group named 'port' or "
            + "'bank'";
    }
}

/**
## Implement objects

The `implement` template provides no particular parameters or methods.
*/
template implement is object {
    param objtype = "implement";
    param _is_simics_object = false;

    param _c_type = name + "_interface_t";

    // limitations for implements are not recognized
    param limitations = undefined;
}

/**
## Implement templates

There is a single template for [`implement`](#implement-objects) objects,
namely `bank_io_memory`. The template can be instantiated when implementing the
`io_memory` interface, and redirects the access to a bank, specified by the
`bank` parameter.

Bank objects contain an implementation of `io_memory` that
inherits this template.
*/
template bank_io_memory is implement {
    param bank;

    method operation(generic_transaction_t *mem_op,
                     map_info_t map_info) -> (exception_type_t) {
        if (bank.io_memory_access(
                mem_op,
                (SIM_get_mem_op_physical_address(mem_op)
                 - map_info.base + map_info.start),
                NULL)) {
            return Sim_PE_No_Exception;
        } else {
            return Sim_PE_IO_Not_Taken;
        }
    }
}

template bank_transaction is implement {
    param bank;

    method issue(transaction_t *transaction, uint64 addr) -> (exception_type_t) {
        return bank.transaction_access(transaction, addr, NULL);
    }
}

method _mask(uint64 size) -> (uint64) {
    return size >= 8 ? -1 : (1 << (size * 8)) - 1;
}

// TODO(enilsson): preferably, we'd be able to remove the need for
// these methods by iterating over enabled_bytes in other methods

// An access to 0x4 with bits 0x00ffff00 enabled can either be viewed as a
// 2-byte access to 0x5, or a N-byte access to 0x4 for some Nâ¥3. We choose to
// present it as a 3-byte access to 0x4 for two reasons: first, misaligned
// bitmask is an indication that HW requires even addresses so that's probably
// natural; second, code that wants to capture accesses to an odd-addressed reg
// but forgets to check addr=4 would break anyway on an (addr=4,
// bits=0xffffffff) access.
method _enabled_bytes_to_size(uint64 enabled_bytes) -> (uint64) {
    for (local int size = 8; size > 0; --size) {
        if ((enabled_bytes & (0xff << 56)) != 0) {
            return size;
        }
        enabled_bytes = enabled_bytes << 8;
    }
    assert false;
}

// offset in a register ("least significant byte")
method _enabled_bytes_to_offset(uint64 enabled_bytes) -> (uint64) {
    for (local int offset = 0; offset <= 8; ++offset) {
        if (((enabled_bytes >> (offset * 8)) & 0xff) != 0) {
            return offset;
        }
    }
    assert false;
}

/**
## Bank objects

In addition to the `object` template, the `bank` template also inherits the
[`shown_desc`](#shown_desc) template.

The `bank` template contains the following methods:

<dl><dt>

<small>io\_memory\_access(generic\_transaction\_t \*memop, uint64 offset,
void \*aux) -&gt; (bool)</small>
</dt><dd>

Entry point for an access based on `generic_transaction_t`.
      Extracts all needed info from `memop`, calls appropriate
      memop-free methods, updates the `memop` parameter
      accordingly, and returns `true` if the access succeeded. The
      `offset` parameter is the offset of the access relative to
      the bank. The `aux` parameter is NULL by default, and is
      passed on to bank methods.  In order to pass additional information on
      the access down to register and field methods, one can override
      `io_memory_access`, decode needed information from the incoming
      memop, and call `default` with the extracted information in the
      `aux` argument.
</dd><dt>

<small>transaction\_access(transaction\_t \*t, uint64 offset, void \*aux) -&gt;
  (exception\_type\_t)</small>
</dt><dd>

Entry point for an access based on the `transaction` interface.  Extracts all
needed info from `t`, calls appropriate access methods (`read`, `write`, `get`,
`set`), and updates the `t` parameter accordingly. Returns
`Sim_PE_No_Exception` if the access succeeded, and `Sim_PE_IO_Not_Taken`
otherwise. The `offset` parameter is the offset of the access relative to the
bank. The `aux` parameter is NULL by default, and is passed on to bank methods.
In order to pass additional information on the access down to register and
field methods, one can override `transaction_access`, decode needed information
from the incoming transaction, and call `default` with the extracted
information in the `aux` argument. Accesses that bigger than 8 bytes are split
into smaller sized chunks before being completed, the exact details of which
are *undefined*.
</dd><dt>

<small>write(uint64 offset, uint64 value, uint64 enabled\_bytes,
void \*aux) throws</small>
</dt><dd>

A write operation at the given offset. Throwing an exception
makes the access fail, and is typically signaled for writes
outside registers. The default behavior is to forward the
access to registers, as follows:
1. Deduce which registers are hit by the
   access. The `offset` and `size`
   parameters of each register object is used to deduce whether
   the register is covered by the access. A register which is
   only partially covered will be considered hit if the bank
   parameter `partial` is true, and a register
   which does not fully cover the access is considered hit if
   the bank parameter `overlapping` is set.


2. If any portion of the access is not covered by a hit
   register, then the `unmapped_write` method is
   called with a bit pattern showing what parts of the access
   are unmapped. Any exception thrown by unmapped_write is
   propagated, causing the access to fail.


3. The `write_register` method is called in all hit
   registers, starting with the register at the lowest
   offset.

</dd><dt>

<small>unmapped\_write(uint64 offset, uint64 value,
uint64 bits, void \*aux) throws</small>
</dt><dd>

If an access is not fully covered by registers, then this
method is called before the access is performed. Throwing an
exception aborts the entire access. *bits* is a bit
pattern showing which bits are affected; in the lowest 'size'
bits, each 0xff byte represents the position of one unmapped
byte in the access. The *value* parameter contains the
originally written value, including parts that are mapped to
registers. Both *bits* and *value* are
expressed in the host's endianness. The default behavior is to
log a `spec-viol` message on level 1, and throw an exception.
</dd><dt>

<small>read(uint64 offset, uint64 enabled\_bytes, void \*aux) ->
(uint64 value) throws</small>
</dt><dd>

A read operation at the given offset. The access is decomposed
in the same way as in `write`. If there are
unmapped portions of the access, `unmapped_read` is
invoked, possibly aborting the operation. The return value is
composed by the results from calling `read_register` in
hit registers, combined with the result
of `unmapped_read` if the access is not fully
mapped.
</dd><dt>

<small>unmapped\_read(uint64 offset, uint64 bits, void \*aux) throws</small>
</dt><dd>

Like `unmapped_write` but for reads. The default
      implementation unconditionally throws an exception.
</dd></dl>

The `bank` template contains the following parameters:

<dl><dt>

mappable [boolean]
</dt><dd>

Controls whether a bank is visible as an interface port for the
`io_memory` interface, which makes it mappable in a memory
space.  This defaults to true.
</dd><dt>

overlapping [bool]
</dt><dd>

Specifies whether this bank allows accesses that cover more than
one register. (This translates to one or more, possibly partial,
accesses to adjacent registers.) Defaults to `true`. This parameter
must have the same value among all elements in a bank array
object, i.e., it must not depend on the index of the bank.
</dd><dt>

partial [bool]
</dt><dd>

Specifies whether this bank allows accesses that cover only parts
of a register. A partial read will read the touched register fields
(or the whole register if there are no fields) and extract the bits
covered by the read. A partial write will call the `get`
method on the touched register fields (or the whole register when
there are no fields) and replace the written bits with the written
value and then call the `write` method on the fields (or the
register) with the merged value. Defaults to `true`. This parameter
must have the same value among all elements in a bank array
object, i.e., it must not depend on the index of the bank.
</dd><dt>

register\_size [integer | undefined]
</dt><dd>

Inherited from the `device` object; provides the
default value for the `size` parameter of `register`
objects.
</dd><dt>

byte\_order [string]
</dt><dd>

Specifies the byte order used when accessing registers wider than a
single byte; inherited from `device` objects. Allowed values
are `"little-endian"` and `"big-endian"`.
This parameter must have the same value among all elements in a bank
array object, i.e., it must not depend on the index of the bank.
</dd><dt>

be_bitorder [bool]
</dt><dd>

Controls the preferred bit ordering of registers within this bank.
Whenever the register is presented to the user as a bitfield, bit 0 refers to
the least significant bit if the parameter is `false` (the default), and
to the most significant bit if the parameter is `true`. The parameter is
only a presentation hint and does not affect the model's behaviour. The
parameter is technically unrelated to the top-level `bitorder`
declaration, though in most cases the two should match.
</dd><dt>

use_io_memory [bool]
</dt><dd>

If `true`, this bank is exposed using the legacy `io_memory` interface. In this
case, the `io_memory_access` method can be called and overridden, but
the `transaction_access` method can not.

If `false`, this bank is exposed using the `transaction` interface. In this
case, the `transaction_access` method can be called and overridden, but
the `io_memory_access` method can not.

The default is inherited from `dev.use_io_memory`.</dd><dt>

obj [conf\_object\_t \*]
</dt><dd>

When compiling with Simics API 5 or earlier, evaluates to dev.obj.
When compiling with Simics API 6 or newer, evaluates to the bank's port object.

</dd></dl>
*/
template bank is (object, shown_desc) {
    #if (parent.objtype == "group"
         #? parent._simics_namespace_clash #: false) {
        error "Cannot declare a bank underneath a group named 'port' or "
            + "'bank'";
    }

    // compatibility: referencing 'obj' in a bank method must evaluate to
    // dev.obj in code that can compile on both 5 and 6
    // TODO: we should probably make obj an immutable session variable
    param obj = dev._compat_port_obj_param #? dev.obj #: _bank_obj();
    param partial : bool;
    param overlapping : bool;
    param _le_byte_order : bool;
    param _each_register : sequence(register);

    session _callback_vect_t _before_read_callbacks;
    session _callback_vect_t _after_read_callbacks;
    session _callback_vect_t _before_write_callbacks;
    session _callback_vect_t _after_write_callbacks;
    session _connection_vect_t _connections;

    // structural info
    param objtype = "bank";
    param _is_simics_object = true;
    param bank                      = this;
    param _each_register = each register in (this);

    // optional parameters
    param overlapping               default true;
    param partial                   default true;
    param mappable                  default true;
    param byte_order                default dev.byte_order;
    param _le_byte_order = byte_order == "little-endian";
    param be_bitorder : bool;
    param be_bitorder default dev.be_bitorder;

    // register defaults
    param register_size             default dev.register_size;

    // removed since 1.2; reserved for now
    param allocate                  = undefined;
    param miss_bank                 = undefined;
    param miss_bank_offset          = undefined;
    param log_group                 = undefined;

    // this carried semantics in DML 1.2; deprecated in 1.4
    param _confidentiality          = undefined;

    shared independent startup memoized method _reginfo_table()
        -> (const register *, uint64) /* table, table_size */ {
        local uint64 size = 0;
        foreach r in (this._each_register) {
            if (r.offset != unmapped_offset) {
                size++;
            }
        }
        local register *table = new register[size];
        local uint64 num = 0;
        foreach r in (this._each_register) {
            if (r.offset != unmapped_offset) {
                table[num] = r;
                num++;
            }
        }
        return (table, size);
    }

    shared method _get_register(uint32 reg) -> (register) throws default {
        local (const register *table, uint64 table_size) = _reginfo_table();
        if (reg >= table_size) {
            throw;
        }
        return table[reg];
    }

    shared method _num_registers() -> (uint32) {
        local (const register *_, uint64 table_size) = _reginfo_table();
        return table_size;
    }

    // Given two address intervals, return the location of their intersection,
    // expressed as bit indices in the first interval (using little-endian
    // bitorder, and the bank's byte order)
    shared method _intersect(uint64 offset, uint64 size,
                             uint64 roffset, uint64 rsize, bool endian_swap)
        -> (int, int) /* start, end */ {
        local int start = roffset - offset;
        local int end = start + rsize;
        if (start < 0) {
            start = 0;
        }
        if (end > size)
            end = size;
        if (this._le_byte_order || !endian_swap)
            return (start, end);
        else
            return (size - end, size - start);
    }

    shared independent startup memoized method _sorted_regs()
        -> (const register *, int) /* regs, num_mapped_regs */ {
        local int num = 0;
        foreach r in (this._each_register) {
            if (r.offset != unmapped_offset)
                ++num;
        }
        if (num == 0) {
            return (NULL, 0);
        }
        local register *src = new register[num];
        local register *dest = new register[num];
        local int i = 0;
        foreach r in (this._each_register) {
            if (r.offset != unmapped_offset) {
                src[i] = r;
                ++i;
            }
        }
        // bottom-up merge sort: with iteratively longer power-of-two interval
        // lengths, partition the list into this interval length and make each
        // interval sorted.
        for (local int size = 1; size < num; size *= 2) {
            for (local int low = 0; low < num; low += size * 2) {
                // Given that src[low:mid] and src[mid:end] are sorted,
                // merge these into dest[low..end] as a sorted interval
                local int mid = low + size;
                local int end = mid + size;
                if (mid > num) mid = num;
                if (end > num) end = num;
                local int low_idx = low;
                local int high_idx = mid;
                local int dest_idx = low;
                while (low_idx < mid || high_idx < end) {
                    if (low_idx < mid
                        && (high_idx >= end
                            || src[low_idx].offset < src[high_idx].offset)) {
                        dest[dest_idx] = src[low_idx];
                        ++low_idx;
                    } else {
                        dest[dest_idx] = src[high_idx];
                        ++high_idx;
                    }
                    ++dest_idx;
                }
            }
            // swap src and dest
            local register *tmp = src;
            src = dest;
            dest = tmp;
        }
        delete dest;
        return (src, num);
    }

    // Register dispatcher. Given the offset and size of an access, return a
    // list of registers that the access covers, and a bitmask showing 0xff for
    // all bytes of the access that were not mapped to a register. The register
    // list is stored in 'hits', assumed to be an array of size â¥ 8. The
    // register list is ordered by offset.
    shared method _dispatch(uint64 offset, uint64 size, register *hits, bool inquiry)
        -> (int, uint64) /* nhits, unmapped_bytes */ {
        local (const register *regs, int num_mapped_regs) = _sorted_regs();
        local uint64 unmapped_bytes = cast(-1, uint64)[size * 8 - 1 : 0];
        if (num_mapped_regs == 0) {
            return (0, unmapped_bytes);
        }
        // find the register with largest offset such that reg.offset <= offset
        // Binary search, maintaining the invariant first <= answer <= last
        local int first = 0;
        local int last = num_mapped_regs - 1;
        while (first < last) {
            // we pick a middle point such that last >= middle >= first + 1 ...
            local int middle = (first + last + 1) / 2;
            if (regs[middle].offset > offset) {
                // ... which guarantees last >= first here
                last = middle - 1;
            } else {
                first = middle;
            }
        }
        local int nhits = 0;
        assert first == last;
        assert last >= 0;
        for (local int i = last;
             i < num_mapped_regs && regs[i].offset < offset + size;
             ++i) {
            local register r = regs[i];
            if (offset < r.offset + r._size()
                && ((this.partial || inquiry)
                    || (offset <= r.offset
                        && offset + size >= r.offset + r._size()))
                && (this.overlapping || (
                        offset >= r.offset
                        && offset + size <= r.offset + r._size()))) {
                hits[nhits] = r;
                ++nhits;
                assert nhits <= 8;
            }
        }

        for (local int i = 0; i < nhits; i++) {
            local int start;
            local int end;
            (start, end) = this._intersect(
                offset, size, hits[i].offset, hits[i]._size(), true);
            unmapped_bytes[end * 8 - 1 : start * 8] = 0;
        }
        return (nhits, unmapped_bytes);
    }

    shared method unmapped_read(uint64 offset, uint64 bits, void *aux)
        -> (uint64) throws default {
        log spec_viol, 1, Register_Read:
            "%d byte read access at offset %#x in %s" +
            " outside registers or misaligned access",
            _enabled_bytes_to_size(bits), offset, this._qname();
        throw;
    }

    shared method unmapped_write(uint64 offset, uint64 value, uint64 bits,
                                 void *aux)
        throws default {
        log spec_viol, 1, Register_Write:
            "%d byte write access at offset %#x in %s" +
            " outside registers or misaligned access",
            _enabled_bytes_to_size(bits), offset, this._qname();
        throw;
    }

    shared method read(uint64 offset, uint64 enabled_bytes,
                       void *aux) -> (uint64) throws default {
        if (enabled_bytes == 0) {
            return 0;
        }

        local register hits[8];
        local int num_hits;
        local uint64 unmapped_bytes;

        local uint64 size = _enabled_bytes_to_size(enabled_bytes);
        (num_hits, unmapped_bytes) = this._dispatch(offset, size, hits, false);

        local uint64 readval = 0;
        if ((unmapped_bytes & enabled_bytes) != 0) {
            readval[size * 8 - 1 : 0] = this.unmapped_read(
                offset, unmapped_bytes & enabled_bytes, aux);
        }

        for (local int r = 0;  r < num_hits; ++r) {
            local int r_start;
            local int r_end;
            (r_start, r_end) = this._intersect(
                hits[r].offset, hits[r]._size(), offset, size, true);

            local int start;
            local int end;
            (start, end) = this._intersect(
                offset, size, hits[r].offset, hits[r]._size(), true);

            local uint64 r_enabled_bytes = 0;
            r_enabled_bytes[r_end * 8 - 1 : r_start * 8] =
                enabled_bytes[end * 8 - 1 : start * 8];
            if (r_enabled_bytes == 0) {
                continue;
            }

            local uint64 r_val = hits[r].read_register(r_enabled_bytes, aux);
            if (r_end - r_start == hits[r]._size()) {
                log info, 4, Register_Read:
                    "Read from register %s -> 0x%0*x",
                    hits[r]._qname(), cast(size*2, int), r_val;
            } else {
                log info, 4, Register_Read:
                    "Partial read from register %s[%d:%d] -> 0x%0*x",
                        hits[r]._qname(), r_end * 8 - 1, r_start * 8,
                        cast((r_end - r_start) * 2, int),
                        r_val[r_end * 8 - 1 : r_start * 8];
            }

            readval[end * 8 - 1 : start * 8] =
                (r_val & r_enabled_bytes)[r_end * 8 - 1 : r_start * 8];
        }

        return readval;
    }

    shared method unmapped_get(uint64 offset, uint64 bits) -> (uint64) throws
        default {
        throw;
    }

    shared method get(uint64 offset, uint64 size) -> (uint64) throws default {
        local register hits[8];
        local int num_hits;
        local uint64 unmapped_bytes;
        (num_hits, unmapped_bytes) = this._dispatch(offset, size, hits, true);

        local uint64 readval = 0;
        if (unmapped_bytes != 0) {
            readval[size * 8 - 1 : 0] = this.unmapped_get(offset,
                                                          unmapped_bytes);
        }

        for (local int r = 0;  r < num_hits; ++r) {
            local int r_start;
            local int r_end;
            (r_start, r_end) = this._intersect(
                hits[r].offset, hits[r]._size(), offset, size, true);

            local int start;
            local int end;
            (start, end) = this._intersect(
                offset, size, hits[r].offset, hits[r]._size(), true);

            local uint64 r_val = hits[r].get();
            readval[end * 8 - 1 : start * 8]
                = r_val[r_end * 8 - 1 : r_start * 8];
        }

        return readval;
    }

    shared method write(uint64 offset, uint64 value, uint64 enabled_bytes,
                 void *aux) throws default {
        if (enabled_bytes == 0) {
            return;
        }

        local register hits[8];
        local int num_hits;
        local uint64 unmapped_bytes;

        local uint64 size = _enabled_bytes_to_size(enabled_bytes);
        (num_hits, unmapped_bytes) = this._dispatch(offset, size, hits, false);
        if ((unmapped_bytes & enabled_bytes) != 0) {
            this.unmapped_write(
                offset, value, unmapped_bytes & enabled_bytes, aux);
        }

        for (local int r = 0;  r < num_hits; ++r) {
            local int r_start;
            local int r_end;
            (r_start, r_end) = this._intersect(
                hits[r].offset, hits[r]._size(), offset, size, true);

            local int start;
            local int end;
            (start, end) = this._intersect(
                offset, size, hits[r].offset, hits[r]._size(), true);

            local uint64 r_enabled_bytes = 0;
            r_enabled_bytes[r_end * 8 - 1 : r_start * 8] =
                enabled_bytes[end * 8 - 1 : start * 8];
            if (r_enabled_bytes == 0) {
                continue;
            }

            local uint64 r_value = 0;
            r_value[r_end * 8 - 1 : r_start * 8]
                = value[end * 8 - 1 : start * 8];
            if (r_end - r_start == hits[r]._size()) {
                log info, 4, Register_Write:
                "Write to register %s <- 0x%0*x",
	            hits[r]._qname(), cast(size*2, int), r_value;
            } else {
                log info, 4, Register_Write:
                    "Partial write to register %s[%d:%d] <- 0x%0*x",
                        hits[r]._qname(), r_end * 8 - 1, r_start * 8,
                        cast((r_end - r_start) * 2, int),
                        r_value[r_end * 8 - 1 : r_start * 8];
            }

            hits[r].write_register(r_value & r_enabled_bytes, r_enabled_bytes,
                                   aux);
        }
    }

    shared method set(uint64 offset, uint64 size, uint64 value) default {
        local register hits[8];
        local int num_hits;
        local uint64 unmapped_bytes;

        (num_hits, unmapped_bytes) = this._dispatch(offset, size, hits, true);
        if (unmapped_bytes != 0) {
            log info, 4: "Unmapped inquiry write at 0x%llx", offset;
        }

        for (local int r = 0;  r < num_hits; ++r) {
            local int r_start;
            local int r_end;
            (r_start, r_end) = this._intersect(
                hits[r].offset, hits[r]._size(), offset, size, true);

            local int start;
            local int end;
            (start, end) = this._intersect(
                offset, size, hits[r].offset, hits[r]._size(), true);

            local uint64 r_value = (r_start == 0 && r_end == hits[r]._size())
                ? 0 : hits[r].get();
            r_value[r_end * 8 - 1 : r_start * 8]
                = value[end * 8 - 1 : start * 8];
            if (r_end - r_start == hits[r]._size()) {
                log info, 4, Register_Write:
                "Setting register %s <- 0x%0*x",
	            hits[r]._qname(), cast(size*2, int), r_value;
            } else {
                log info, 4, Register_Write:
                    "Partially setting register %s[%d:%d] <- 0x%0*x",
                    hits[r]._qname(), r_end * 8 - 1, r_start * 8,
                    cast((r_end - r_start) * 2, int),
                    r_value[r_end * 8 - 1 : r_start * 8];
            }

            hits[r].set(r_value);
        }
    }

    shared method _memop_set_read_value(generic_transaction_t *memop, uint64 val) {
        if (this._le_byte_order)
            SIM_set_mem_op_value_le(memop, val);
        else
            SIM_set_mem_op_value_be(memop, val);
    }
    shared method _memop_write_value(generic_transaction_t *memop) -> (uint64) {
        if (this._le_byte_order)
            return SIM_get_mem_op_value_le(memop);
        else
            return SIM_get_mem_op_value_be(memop);
    }
    shared method _set_read_value(uint64 size, uint8 *buf, uint64 val) {
        assert size <= 8;
        if (this._le_byte_order) {
            local uint64_le_t v = val;
            memcpy(buf, &v, size);
        } else {
            local uint64_be_t v = val;
            memcpy(buf, cast(&v, char *) + 8 - size, size);
        }
    }
    shared method _write_value(uint64 size, const uint8 *buf) -> (uint64) {
        assert size <= 8;
        if (this._le_byte_order) {
            local uint64_le_t v;
            memcpy(&v, buf, size);
            return v;
        } else {
            local uint64_be_t v;
            memcpy(cast(&v, char *) + 8 - size, buf, size);
            return v;
        }
    }

    session conf_object_t *_cached_bank_obj;
    shared method _bank_obj() -> (conf_object_t *) {
        if (this._cached_bank_obj != NULL) {
            return this._cached_bank_obj;
        }
        this._cached_bank_obj = _dmllib_port_obj_from_device_obj(
            dev.obj, _qname(), "bank.");
        return this._cached_bank_obj;
    }

    shared method io_memory_access(generic_transaction_t *memop, uint64 offset,
                                   void *aux) -> (bool)
        default {
        local uint64 size = SIM_get_mem_op_size(memop);
        local bool inquiry = SIM_get_mem_op_inquiry(memop);
        local conf_object_t *ini = SIM_get_mem_op_initiator(memop);

        local bool success = true;
        if (inquiry) {
            if (SIM_mem_op_is_read(memop)) {
                local uint64 value;
                try {
                    value = this.get(offset, size);
                } catch {
                    success = false;
                }

                if (success) {
                    this._memop_set_read_value(memop, value);
                }
            } else {
                local uint64 writevalue = this._memop_write_value(memop);
                this.set(offset, size, writevalue);
            }
        } else {
            if (SIM_mem_op_is_read(memop)) {
                local uint64 value = 0;
                local bool inquiry_override = false;
                _callback_before_read(
                    this._bank_obj(), ini, &inquiry_override,
                    &offset, size, &_connections, &_before_read_callbacks);
                try {
                    if (inquiry_override) {
                        value = this.get(offset, size);
                    } else {
                        value = this.read(offset, _mask(size), aux);
                    }
                } catch {
                    success = false;
                }
                _callback_after_read(this._bank_obj(), ini, &offset, size,
                                     &value, &success, &_connections,
                                     &_after_read_callbacks);

                if (success) {
                    this._memop_set_read_value(memop, value);
                }
            } else {
                local uint64 writevalue = this._memop_write_value(memop);

                local bool suppress = false;
                _callback_before_write(
                    this._bank_obj(), ini, &offset, size, &writevalue,
                    &suppress, &_connections, &_before_write_callbacks);
                if (!suppress) {
                    try {
                        this.write(offset, writevalue, _mask(size), aux);
                    } catch {
                        success = false;
                    }
                }
                _callback_after_write(this._bank_obj(), ini, &offset, size,
                                      &success, &_connections,
                                      &_after_write_callbacks);
            }
        }

        return success;
    }

    shared method transaction_access(transaction_t *t, uint64 offset,
                                     void *aux) -> (exception_type_t) default {
        local uint64 size = SIM_transaction_size(t);
        local conf_object_t *ini = SIM_transaction_initiator(t);
        local uint8 buf[size];
        if (SIM_transaction_is_write(t)) {
            local buffer_t bytes;
            bytes.data = buf;
            bytes.len = size;
            SIM_get_transaction_bytes(t, bytes);
        }
        local bool inquiry = SIM_transaction_is_inquiry(t);
        local bool is_read = SIM_transaction_is_read(t);
        if (size <= 8) {
            if (!_transaction_access(ini, is_read, inquiry, offset, size,
                                     buf, aux))
                return Sim_PE_IO_Not_Taken;
        } else {
            local int sz = 8 - (offset % 8);
            local uint64 offs = 0;
            while (offs < size) {
                if (!_transaction_access(ini, is_read, inquiry,
                                         offset + offs, sz, buf + offs, aux))
                    return Sim_PE_IO_Not_Taken;
                offs += sz;
                sz = 8 > (size - offs) ? (size - offs) : 8;
            }
        }
        if (SIM_transaction_is_read(t)) {
            local bytes_t bytes;
            bytes.data = buf;
            bytes.len = size;
            SIM_set_transaction_bytes(t, bytes);
        }

        return Sim_PE_No_Exception;
    }

    shared method _transaction_access(
        conf_object_t *ini, bool is_read, bool inquiry,
        uint64 offset, uint64 size, uint8 *buf, void *aux) -> (bool) {

        local bool success = true;
        if (inquiry) {
            if (is_read) {
                local uint64 value;
                try {
                    value = this.get(offset, size);
                } catch {
                    success = false;
                }

                if (success) {
                    this._set_read_value(size, buf, value);
                }
            } else {
                local uint64 writevalue = this._write_value(size, buf);
                this.set(offset, size, writevalue);
            }
        } else {
            if (is_read) {
                local bool inquiry_override = false;
                _callback_before_read(this._bank_obj(), ini,
                                      &inquiry_override, &offset,
                                      size, &_connections, &_before_read_callbacks);
                local uint64 value = 0;
                try {
                    if (inquiry_override) {
                        value = this.get(offset, size);
                    } else {
                        value = this.read(offset, _mask(size), aux);
                    }
                } catch {
                    success = false;
                }

                _callback_after_read(this._bank_obj(), ini, &offset, size,
                                     &value, &success, &_connections,
                                     &_after_read_callbacks);

                if (success) {
                    this._set_read_value(size, buf, value);
                }
            } else {
                local uint64 writevalue = this._write_value(size, buf);

                local bool suppress = false;
                _callback_before_write(
                    this._bank_obj(), ini, &offset, size, &writevalue,
                    &suppress, &_connections, &_before_write_callbacks);
                if (!suppress) {
                    try {
                        this.write(offset, writevalue, _mask(size), aux);
                    } catch {
                        success = false;
                    }
                }
                _callback_after_write(this._bank_obj(), ini, &offset, size,
                                      &success, &_connections,
                                      &_after_write_callbacks);
            }
        }

        return success;
    }

    param use_io_memory : bool;
    param use_io_memory default dev.use_io_memory;

    #if (mappable) {
        #if (use_io_memory) {
            implement io_memory {
                is bank_io_memory;
                param bank = parent;
            }
        } #else {
            implement transaction {
                is bank_transaction;
                param bank = parent;
            }
        }
    }

    // Warning: This parameter is meant for enabling some experiments with
    // custom register_view implementations. It should not be used in
    // production code.
    param _provide_register_view default true;
    #if (_provide_register_view) {
        implement register_view {
            method description() -> (const char *) {
                // TODO: it would make sense to return NULL for no desc, but
                // iface docs doesn't explicitly specify whether this is
                // allowed.
                return bank.shown_desc == NULL ? "" : bank.shown_desc;
            }
            method big_endian_bitorder() -> (bool) {
                return bank.be_bitorder;
            }
            method number_of_registers() -> (uint32) {
                return _num_registers();
            }
            method register_info(uint32 reg) -> (attr_value_t) {
                local register r;
                try {
                    r = bank._get_register(reg);
                } catch {
                    return SIM_make_attr_nil();
                }

                local attr_value_t fields = SIM_alloc_attr_list(
                    r._num_fields());

                local uint32 idx = 0;
                foreach f in (r.fields) {
                    local attr_value_t elem = SIM_make_attr_list(
                        4,
                        SIM_make_attr_string(
                            f._qname() + strlen(r._qname()) + 1),
                        // TODO: NULL should give a nil value
                        SIM_make_attr_string(f.shown_desc == NULL ? ""
                                             : f.shown_desc),
                        SIM_make_attr_uint64(f.lsb),
                        SIM_make_attr_uint64(f.lsb + f.bitsize - 1));
                    SIM_attr_list_set_item(&fields, idx, elem);
                    idx++;
                }

                local attr_value_t ret;
                ret = SIM_make_attr_list(
                    6,
                    SIM_make_attr_string(
                        r._qname() + strlen(bank._qname()) + 1),
                    // TODO: NULL should give a nil value
                    SIM_make_attr_string(r.shown_desc == NULL ? ""
                                         : r.shown_desc),
                    SIM_make_attr_uint64(r._size()),
                    SIM_make_attr_uint64(r.offset),
                    fields,
                    SIM_make_attr_boolean(
                        byte_order == "big-endian" #? true #: false));

                return ret;
            }
            method get_register_value(uint32 reg) -> (uint64) {
                local register r;
                try {
                    r = bank._get_register(reg);
                } catch {
                    return 0;
                }

                return r.get();
            }
            method set_register_value(uint32 reg, uint64 val) {
                local register r;
                try {
                    r = bank._get_register(reg);
                } catch {
                    return;
                }

                r.set(val);
            }
        }

        implement register_view_read_only {
            method is_read_only(uint32 reg) -> (bool) {
                local register r;
                try {
                    r = bank._get_register(reg);
                } catch {
                    return false;
                }

                return r._is_read_only;
            }
        }

        implement register_view_catalog {
            method register_names() -> (attr_value_t) {
                local (const register *table, uint64 table_size)
                    = _reginfo_table();
                local attr_value_t ret = SIM_alloc_attr_list(table_size);
                local size_t bank_prefix_len = strlen(bank._qname()) + 1;
                for (local int i = 0; i < table_size; i++) {
                    SIM_attr_list_set_item(
                        &ret, i, SIM_make_attr_string(
                            table[i]._qname() + bank_prefix_len));
                }
                return ret;
            }
            method register_offsets() -> (attr_value_t) {
                local (const register *table, uint64 table_size)
                    = _reginfo_table();
                local attr_value_t ret = SIM_alloc_attr_list(table_size);
                for (local int i = 0; i < table_size; i++) {
                    SIM_attr_list_set_item(
                        &ret, i, SIM_make_attr_uint64(table[i].offset));
                }
                return ret;
            }
        }
    }

    // TODO: we should implement int_register automatically; define a dummy
    // parameter to reserve the name
    param int_register = undefined;

    implement bank_instrumentation_subscribe {
        method register_before_read(conf_object_t *connection,
                                    uint64 offset,
                                    uint64 size,
                                    before_read_callback_t before_read,
                                    void *user_data) -> (
                                        bank_callback_handle_t) {
            return _register_before_read(
                bank._bank_obj(), connection, offset, size, before_read,
                user_data, &bank._connections,
                &bank._before_read_callbacks);
        }
        method register_after_read(conf_object_t *connection,
                                   uint64 offset,
                                   uint64 size,
                                   after_read_callback_t after_read,
                                   void *user_data) -> (
                                       bank_callback_handle_t) {
            return _register_after_read(
                bank._bank_obj(), connection, offset, size, after_read,
                user_data, &bank._connections,
                &bank._after_read_callbacks);
        }

        method register_before_write(conf_object_t *connection,
                                     uint64 offset,
                                     uint64 size,
                                     before_write_callback_t before_write,
                                     void *user_data) -> (
                                         bank_callback_handle_t) {
            return _register_before_write(
                bank._bank_obj(), connection, offset, size, before_write,
                user_data, &bank._connections,
                &bank._before_write_callbacks);
        }
        method register_after_write(conf_object_t *connection,
                                    uint64 offset,
                                    uint64 size,
                                    after_write_callback_t after_write,
                                    void *user_data) -> (
                                        bank_callback_handle_t) {
            return _register_after_write(
                bank._bank_obj(), connection, offset, size, after_write,
                user_data, &bank._connections,
                &bank._after_write_callbacks);
        }

        method remove_callback(bank_callback_handle_t callback) {
            _remove_callback(callback, &bank._connections,
                             &bank._before_read_callbacks,
                             &bank._after_read_callbacks,
                             &bank._before_write_callbacks,
                             &bank._after_write_callbacks);
        }

        method remove_connection_callbacks(conf_object_t *connection) {
            _remove_connection_callbacks(
                bank._bank_obj(), connection, &bank._connections);
        }
        method enable_connection_callbacks(conf_object_t *connection) {
            _enable_connection_callbacks(connection, &bank._connections);
        }
        method disable_connection_callbacks(conf_object_t *connection) {
            _disable_connection_callbacks(connection, &bank._connections);
        }
    }

    implement instrumentation_order {
        method get_connections() -> (attr_value_t) {
            return _get_connections(&bank._connections);
        }
        method move_before(conf_object_t *connection,
                           conf_object_t *before) -> (bool) {
            return _move_before(connection, before, &bank._connections);
        }
    }
}

// The following captures errors when migrating from the io_memory interface to
// the transaction interface.
in each bank {
    #if (!use_io_memory) {
        method io_memory_access(generic_transaction_t *memop, uint64 offset,
                                void *aux) -> (bool) {
            log error: "call to io_memory_access in transaction-based bank %s",
                _qname();
            return false;
        }
    } #else {
        method transaction_access(transaction_t *t, uint64 offset,
                                  void *aux) -> (exception_type_t) {
            log error: "call to transaction_access in io_memory-based bank %s",
                _qname();
            return Sim_PE_IO_Not_Taken;
        }
    }
}

/**
## Register objects

In addition to [`object`](#object), the `register` template inherits the
templates [`get`](#get), [`set`](#set), [`shown_desc`](#shown_desc),
[`read_register`](#read_register), [`write_register`](#write_register), and
[`init_val`](#init_val).

The `register` template contains the following parameters:

<dl><dt>

val [integer]
</dt><dd>

The contents of the register.
Manipulating `val` is a simpler, but less safe
alternative to using `get_val()` and `set_val()` &mdash; unlike `set_val()`,
it is *undefined behavior* to write a value to `val` larger than what the
register can hold.

</dd><dt>

size [integer]
</dt><dd>

The size (width) of the register, in bytes. This parameter
can also be specified using the "<code>size <em>n</em></code>" short-hand
syntax for register objects. The default value is provided by the
`register_size` parameter of the enclosing `bank`
object.
</dd><dt>

bitsize [integer]
</dt><dd>

The size (width) of the register, in bits. This is equivalent to the
value of the `size` parameter multiplied by 8, and cannot be
overridden.
</dd><dt>

offset [integer]
</dt><dd>

The address offset of the register, in bytes relative to the start
address of the bank that contains it. This parameter can also be
specified using the "<code>@ <em>n</em></code>" short-hand syntax for register
objects. There is no default value. If the register inherits the
`unmapped` template, the register is not mapped to an address.
This parameter must have the same value among all elements in a bank
array object, i.e., it must not depend on the index of the bank.
</dd><dt>

fields [list of references]
</dt><dd>

A list of references to all the `field` objects of a register
object.
</dd><dt>

init\_val [integer]
</dt><dd>

The value used by the default implementation of the
`init` method, when the device is instantiated. The value is
also used by the default implementations of hard reset, soft reset and
power-on reset. Defaults to 0.
</dd><dt>

configuration [`"required"` | `"optional"` | `"pseudo"` | `"none"`]
</dt><dd>

Specifies how Simics treats the automatically created [attribute]
(#attribute-objects) corresponding to the register. The default value is
`"optional"`.
</dd><dt>

persistent [bool]
</dt><dd>

Specifies whether the register [attribute](#attribute-objects)
should be persistent.
</dd><dt>

internal [bool]
</dt><dd>

Specifies whether the register [attribute](#attribute-objects)
should be internal, default is `true`.
</dd></dl>

The `register` template provides the following
overridable methods:

<dl><dt>

`read_unmapped_bits(uint64 unmapped_enabled_bits, void *aux) -> (uint64)`
</dt><dd>

`read_unmapped_bits` is used by the default implementation of
`read_register` to read the bits not covered by fields from
a register, possibly with side-effects.

The default implementation of `read_unmapped_bits`
acts similarly to if the unmapped regions of the register were covered by
fields, the `value` of the register is masked by
`unmapped_enabled_bits` and returned.

</dd><dt>

`write_unmapped_bits(uint64 val, uint64 enabled_bits, void *aux)`.
</dt><dd>

The `write_unmapped_bits` method is called from
the default implementation of the `write_register` method
when `enabled_bytes` specifies
bytes not completely covered by field in the register (and the register
has at least one field).
`unmapped_enabled_bits` is defined as in the
`read_unmapped_bits` method. `val` is the
`val` argument passed to `write_register`, masked with
the bits not covered by fields.

Default behaviour of `write_unmapped_bits` is to compare
the `unmapped_enabled_bits` in `value` to those
in the register `val`; if they do not match, a
message of type `spec-viol` is logged for each bitrange
that does not match, but `val` is not modified.

</dd></dl>
*/
template register is (_conf_attribute, get, set, shown_desc,
                      _bitsize, read_register, write_register,
                      init_val) {
    session uint64 val;

    param objtype = "register";
    param _is_simics_object = false;
    param internal default true;
    param bank = this._nongroup_parent;
    param bitsize                   = this.size * 8;
    param fields : sequence(field);
    param fields                    = each field in (this);
    param _get_fields : sequence(_get_field);
    param _get_fields = each _get_field in (this);
    param _set_fields : sequence(_set_field);
    param _set_fields = each _set_field in (this);
    param _read_fields : sequence(_read_field);
    param _read_fields = each _read_field in (this);
    param _write_fields : sequence(_write_field);
    param _write_fields = each _write_field in (this);
    param _le_byte_order            = bank._le_byte_order;

    // temporary 1.2-specific stuff
    param _attr_type                 = "i";

    // required parameters
    param size                      default bank.register_size;

    // optional parameters
    param regnum                    default undefined;

    // this carried semantics in DML 1.2; deprecated in 1.4
    param _confidentiality          = undefined;
    param log_group = undefined;

    param is_register = true;

    param lsb = 0;

    param _is_read_only default false;

    shared method set_attribute(attr_value_t value) -> (set_error_t) {
        this.set(SIM_attr_integer(value));
        return Sim_Set_Ok;
    }

    shared method get_attribute() -> (attr_value_t) {
        return SIM_make_attr_uint64(this.get());
    }

    param offset : uint64;
    param _le_byte_order : bool;
    param _is_read_only : bool;
    param mapped : bool;
    param mapped = offset != unmapped_offset;

    shared independent method _size() -> (int) { return this.bitsize / 8; }
    shared method _num_fields() -> (uint32) {
        local uint32 num_fields = 0;
        foreach f in (fields) {
            num_fields++;
        }
        return num_fields;
    }

    shared independent method _field_bits() -> (uint64) {
        local uint64 bits = 0;
        foreach f in (this.fields) {
            bits[f.lsb + f.bitsize - 1 : f.lsb] = -1;
        }
        return bits;
    }

    // fills in the passed array with all fields in this register, and returns
    // the number of elements and a bitmask showing bits not covered by fields.
    shared method _get_get_fields(_get_field *fields) -> (int, uint64) /* n, unmapped */ {
        local uint64 unmapped;
        unmapped[this.bitsize - 1 : 0 ] = -1;
        local int n = 0;
        local uint64 lsbs = 0;

        // counting sort
        foreach f in (_get_fields) {
            local int lsb = f.lsb;
            lsbs[lsb] = 1;
            unmapped[lsb + f.bitsize - 1 : lsb] = 0;
            ++n;
        }

        foreach f in (_get_fields) {
            fields[bit_count64(lsbs[f.lsb : 0]) - 1] = f;
        }
        return (n, unmapped);
    }

    // fills in the passed array with all fields in this register, and returns
    // the number of elements and a bitmask showing bits not covered by fields.
    shared method _get_set_fields(_set_field *fields) -> (int, uint64) /* n, unmapped */ {
        local uint64 unmapped;
        unmapped[this.bitsize - 1 : 0 ] = -1;
        local int n = 0;
        local uint64 lsbs = 0;

        // counting sort
        foreach f in (_set_fields) {
            local int lsb = f.lsb;
            lsbs[lsb] = 1;
            unmapped[lsb + f.bitsize - 1 : lsb] = 0;
            ++n;
        }

        foreach f in (_set_fields) {
            fields[bit_count64(lsbs[f.lsb : 0]) - 1] = f;
        }
        return (n, unmapped);
    }

    // fills in the passed array with all fields in this register, and returns
    // the number of elements and a bitmask showing bits not covered by fields.
    shared method _get_write_fields(_write_field *fields) -> (int, uint64) /* n, unmapped */ {
        local uint64 unmapped;
        unmapped[this.bitsize - 1 : 0 ] = -1;
        local int n = 0;
        local uint64 lsbs = 0;

        // counting sort
        foreach f in (_write_fields) {
            local int lsb = f.lsb;
            lsbs[lsb] = 1;
            unmapped[lsb + f.bitsize - 1 : lsb] = 0;
            ++n;
        }

        foreach f in (_write_fields) {
            fields[bit_count64(lsbs[f.lsb : 0]) - 1] = f;
        }
        return (n, unmapped);
    }

    // fills in the passed array with all fields in this register, and returns
    // the number of elements and a bitmask showing bits not covered by fields.
    shared method _get_read_fields(_read_field *fields) -> (int, uint64) /* n, unmapped */ {
        local uint64 unmapped;
        unmapped[this.bitsize - 1 : 0 ] = -1;
        local int n = 0;
        local uint64 lsbs = 0;

        // counting sort
        foreach f in (_read_fields) {
            local int lsb = f.lsb;
            lsbs[lsb] = 1;
            unmapped[lsb + f.bitsize - 1 : lsb] = 0;
            ++n;
        }

        foreach f in (_read_fields) {
            fields[bit_count64(lsbs[f.lsb : 0]) - 1] = f;
        }
        return (n, unmapped);
    }

    // Reset register to init_val, except bits covered by fields. Only intended
    // for use by template init_val
    shared method _default_init() {
        local uint64 mapped = this._field_bits();
        // In registers with fields, let fields take care of their own bits. In
        // registers without fields, all bits are set.
        // Similar to set_val, do not allow values that do not fit in the
        // register to be set
        this.val = ((this.val & mapped) |
                    (this.init_val & ~mapped))[bitsize-1:0];
    }

    shared method read_unmapped_bits(uint64 enabled_bits, void *aux) -> (uint64) default {
        return this.val & enabled_bits;
    }

    // TODO: stand-in for SIMICS-22264. Inline and remove when longer needed
    shared method _base_read_register(uint64 enabled_bytes, void *aux)-> (uint64) {
        if (enabled_bytes == 0) {
            return 0;
        }

        local uint64 field_bits = _field_bits();
        if (field_bits == 0) {
           // if no fields, then default is to return the value
           return val & enabled_bytes;
        }
        local int num_fields;
        local _read_field fields[64];
        local uint64 unmapped;
        (num_fields, unmapped) = this._get_read_fields(fields);
        local uint64 default_access_bits = unmapped & field_bits;
        local uint64 unmapped_bits = unmapped & ~field_bits;
        local uint64 val = (this.val & default_access_bits & enabled_bytes);

        local int r_lsb = _enabled_bytes_to_offset(enabled_bytes) * 8;
        for (local int f = 0; f < num_fields; f++) {
            local int f_lsb = fields[f].lsb;
            local int f_msb = f_lsb + fields[f].bitsize - 1;

            local uint64 f_enabled_bytes = enabled_bytes[f_msb : f_lsb];
            if (f_enabled_bytes != 0) {
                val[f_msb : f_lsb]
                    = fields[f].read_field(f_enabled_bytes,
                                           aux) & f_enabled_bytes;
            }
        }
        // Read unmapped bits
        if ((unmapped_bits & enabled_bytes) != 0)
            // Since overridden read_unmapped_bits might not respect
            // enabled_bits, mask return value
            val = val |
                (read_unmapped_bits(unmapped_bits & enabled_bytes, aux)
                 & (unmapped_bits & enabled_bytes));
        return val;
    }

    shared method read_register(uint64 enabled_bytes, void *aux)-> (uint64) default {
        return _base_read_register(enabled_bytes, aux);
    }

    shared method write_unmapped_bits(uint64 value,
                                      uint64 enabled_bits,
                                      void *aux) default {
        local int lsb = _enabled_bytes_to_offset(enabled_bits) * 8;

        // If any bits are written outside fields, then that's fine as long as
        // they match the current storage. If not, signal a spec-viol.
        local uint64 write_outside_fields
            = ((enabled_bits & value) ^
               (this.val & value)) << lsb;

        if (write_outside_fields != 0) {
            local int unmapped_msb = -1;
            local strbuf_t ranges;
            sb_init(&ranges);
            // Collect the unmapped ranges that were written to, and format them
            // into a log message
            for (local int i = this.bitsize; i >= -1; i--) {
                if (i >= 0 && enabled_bits[i]) {
                    if (unmapped_msb < 0)
                        unmapped_msb = i;
                } else if (unmapped_msb >= 0) {
                    // found an unmapped bitrange @ [unmapped_msb : i+1]
                    if (write_outside_fields[unmapped_msb : i + 1] != 0) {
                        local char written[65];
                        local char current[65];
                        for (local int bit = i + 1; bit <= unmapped_msb;
                             bit++) {
                            written[bit - i - 1] = value[bit - lsb]
                                ? '1' : '0';
                            current[bit - i - 1]
                                = this.val[bit] ? '1' : '0';
                        }
                        sb_addfmt(&ranges, "\n\t%d:%d (value written = 0b%s,"
                                  + " previous value = 0b%s)",
                                  unmapped_msb, cast(i + 1, int),
                                  written, current);
                        written[unmapped_msb - i] = 0;
                        current[unmapped_msb - i] = 0;
                    }
                    unmapped_msb = -1;
                }
            }
            log spec_viol, 1 then 5:
                "Write outside fields in register %s, bitranges;%s",
                _qname(), sb_str(&ranges);
            sb_free(&ranges);
        }
    }

    // TODO: stand-in for SIMICS-22264. Inline and remove when longer needed
    shared method _base_write_register(uint64 value, uint64 enabled_bytes,
                                       void *aux) {
        local uint64 field_bits = _field_bits();
        if (field_bits == 0) {
            this.val = (this.val & ~enabled_bytes) | (value & enabled_bytes);
            return;
        }
        local int num_fields;
        local _write_field fields[64];
        local uint64 unmapped;
        (num_fields, unmapped) = this._get_write_fields(fields);
        local uint64 default_write_bits = unmapped & field_bits;
        local uint64 unmapped_bits = unmapped & ~field_bits;
        if (enabled_bytes == 0) {
            return;
        }

        local int r_lsb = _enabled_bytes_to_offset(enabled_bytes) * 8;
        local int r_msb = _enabled_bytes_to_size(enabled_bytes) * 8 - 1;
        for (local int f = 0; f < num_fields; f++) {
            local int f_lsb = fields[f].lsb;
            local int f_msb = f_lsb + fields[f].bitsize - 1;

            local uint64 f_enabled_bytes = enabled_bytes[f_msb : f_lsb];
            if (f_enabled_bytes != 0) {
                local uint64 f_value = value[f_msb : f_lsb];
                fields[f].write_field(
                    f_value & f_enabled_bytes, f_enabled_bytes, aux);
            }
        }

        this.val = (this.val & ~(default_write_bits & enabled_bytes))
                   | (value & default_write_bits & enabled_bytes);

        if ((unmapped_bits & enabled_bytes) != 0)
            write_unmapped_bits(value & unmapped_bits,
                                unmapped_bits & enabled_bytes, aux);
    }

    shared method write_register(uint64 value, uint64 enabled_bytes,
                                 void *aux) default {
        _base_write_register(value, enabled_bytes, aux);
    }

    // Do not allow values larger than register to be set
    shared method set_val(uint64 value) {
        this.val = value[bitsize - 1 : 0];
    }
    shared method get_val() -> (uint64) {
        return this.val[bitsize - 1 : 0];
    }

    shared method _default_get() -> (uint64) {
        local _get_field fields[64];
        local int num;
        local uint64 unmapped;
        (num, unmapped) = this._get_get_fields(fields);
        local uint64 val = get_val() & unmapped;
        for (local int i = 0; i < num; i++) {
            local int lsb = fields[i].lsb;
            val[lsb + fields[i].bitsize - 1 : lsb] = fields[i].get();
        }
        return val;
    }

    shared method _default_set(uint64 value) {
        local _set_field fields[64];
        local int num;
        local uint64 unmapped;
        (num, unmapped) = this._get_set_fields(fields);
        this.val = ((this.val & ~unmapped) |
                    (value & unmapped))[bitsize-1:0];
        for (local int i = 0; i < num; i++) {
            local int lsb = fields[i].lsb;
            fields[i].set(value[lsb + fields[i].bitsize - 1 : lsb]);
        }
    }
}

template _lsb {
    param lsb : uint8;
}

/**
## Field objects

In addition to [`object`](#object), the `field` template inherits the templates
[`init_val`](#init_val) and [`shown_desc`](#shown_desc).

The template inherits methods `get`, `set` and
`init`, and the parameter `init_val`

The `field` template contains the following parameters:

<dl><dt>

val [integer]
</dt><dd>

The bitslice of the parent register corresponding to the field.
Manipulating `val` is a simpler alternative to using `get_val()` and
`set_val()`, while being just as safe (unlike with register objects).
Unlike `get_val()` and `set_val()`, `val` is not a member of the `field`
template type, and thus can't be used in certain contexts.
</dd><dt>

reg [reference]
</dt><dd>

Always refers to the containing register object.
</dd><dt>

lsb [integer]
</dt><dd>

Required parameter. The bit number in the containing register of the
field's least significant bit. Represented in little-endian bit order,
regardless of `bitorder` declarations. The preferred way of defining
this parameter is to use the "<code>[<em>highbit</em>:<em>lowbit</em>]</code>"
short-hand syntax for field ranges, whose interpretation *is* dependent
on the `bitorder` declaration of the file. Care must be taken when
referring to this parameter in a big-endian bit numbering system - if possible,
put such code in a separate file that uses little-endian bit order
interpretation.
</dd><dt>

msb [integer]
</dt><dd>

Required parameter. The bit number in the containing register of the
field's most significant bit. Represented in little-endian bit order. See
`lsb` for details.
</dd><dt>

bitsize [integer]
</dt><dd>

The size (width) of the field, in bits. This is automatically set
from the `lsb` and `msb` parameters and cannot be
overridden.
</dd><dt>

init\_val [integer]
</dt><dd>

The value used by the default implementation of the
`init` method, when the device is instantiated. The value is
also used by the default implementations of hard reset, soft reset and
power-on reset. Defaults to 0.
</dd></dl>
*/
template field is (object, _bitsize, _lsb, init_val, shown_desc, _get, _set) {
    param reg : register;

    shared method get_val() -> (uint64) {
        return reg.val[lsb + bitsize - 1 : lsb];
    }

    shared method set_val(uint64 val) {
        reg.val[lsb + bitsize - 1 : lsb] = val;
    }

    shared method _default_get() -> (uint64) {
        return this.get_val();
    }
    shared method _default_set(uint64 value) {
        this.set_val(value);
    }

    shared method _default_init() {
        set_val(init_val);
    }

    // structural info
    param objtype = "field";
    param _is_simics_object = false;
    param _reg    = this._nongroup_parent;
    param reg     = cast(_reg, register);
    param _desc   = defined this.desc #? this.desc #: "";

    param val     = _reg.val[msb:lsb];

    // required parameters
    param msb;
    param bitsize = msb - lsb + 1;

    // Inherited parameters
    param allocate                  = undefined;
    param _default_init_val         default _reg.init_val[msb:lsb];

    // this carried semantics in DML 1.2; deprecated in 1.4
    param _confidentiality          = undefined;

    param is_register = false;
    param bank = _reg.bank;

    #if (persistent != _reg.persistent) {
        // This may happen while migrating from DML 1.2. Bug 22034.
        error "field-local override of the persistent parameter is currently"
                + " not supported";
    }
}

/**
## Templates for registers and fields
This section lists templates that are specific for `register` and
`field` objects.

All templates (except `read_register` and
`write_register`) are applicable to both registers and
fields. When writing a template that is applicable to both registers and
fields, one should normally inherit one or more of the `read`,
`write`, `get` and `set` methods.

Some methods have an argument `void *aux`. By default, that argument is
NULL. The value can be overridden to carry arbitrary extra information about
the access; this is done by overriding the `io_memory_access` method
in the parent [bank](#bank-objects).

### get\_val

Provides a single non-overrideable method `get_val() -> (uint64)`. In
a register, it returns the value of the .val member; in a field, it
returns the bits of the parent register's `val` member that are
covered by the field.

`get_val` is very similar to [`get`](#get); the difference is that `get_val`
is unaffected if `get` is overridden. Thus, `get_val` is slightly more
efficient, at the cost of flexibility. It is generally advisable to
use `get`.
*/
template get_val {
    // default implementation provided by register/field template
    shared method get_val() -> (uint64);
    shared method _default_get() -> (uint64);
}

/**
### set\_val

Provides a single non-overrideable method
`set_val(uint64)`. In a register, it sets the value of
the .val member; in a field, it sets the bits in the parent
register's `val` member that are covered by the field.

`set_val` is very similar to (`set`)[#set); the difference is
that `set_val` is unaffected if `set` is
overridden. Thus, `set_val` is slightly more efficient, at the
cost of flexibility. It is generally advisable to use `set`.
*/
template set_val {
    // default implementation provided by register/field template
    shared method set_val(uint64 value);
    shared method _default_set(uint64 value);
}

// _get and _set are only for internal use by the library. It is implemented by
// templates that do not override the default get/set implementation, but which
// provide shared methods that access the value of a register or field.  The
// Users should use the 'get' and 'set' templates instead. Registers make
// optimizations based on the assumption that get/set are overridden only on
// fields that implement get/set.
template _get is get_val {
    // retrieve value of register or field, without side-effects. For
    // inspection and checkpointing.
    shared method get() -> (uint64) default { return this._default_get(); }
}
template _set is set_val {
    // Set value of register or field, without side-effects. For injection and
    // checkpointing.
    shared method set(uint64 value) default { this._default_set(value); }
}

/**
### get

Extends the [`get_val`](#get_val) template. Provides a single
overrideable method `get() -> (uint64)`, which retrieves the
register's value, without side-effects, used for checkpointing and
inspection. The default is to retrieve the value using the
`get_val` method.

In a field, this template must be explicitly instantiated in order for an
override to take effect. Note however that field objects do provide a
callable default implementation of the method.
*/
template get is _get {
    // Marker template, should be used when overriding get
}

/**
### set

Extends the [`set_val`](#set_val) template. Provides a single
overrideable method `set(uint64)`, which modifies the register's
value, without triggering other side-effects. Used for checkpointing and
inspection. The default is to set the value using the `set_val`
method.

In a field, this template must be explicitly instantiated in order for an
override to take effect. Note however that field objects do provide a
callable default implementation of the method.
*/
template set is _set {
    // Marker template, should be used when overriding set
}

/**
### read\_register

Implemented only by registers, not applicable to fields.

Provides a single abstract method
`read_register(uint64 enabled_bytes, void *aux) -> (uint64)`.

The method reads from a register, possibly with side-effects. The
returned value is represented in the host's native endianness. The
`enabled_bytes` argument defines which bytes of the register is
accessed, as a bitmask; each byte of the returned value has
significance only if the corresponding byte in `enabled_bytes` is
0xff. If the access covers more than one register, then the parts of
`enabled_bytes` that correspond to other registers are still zero.

Register objects provide a default implementation of
`read_register`. The implementation invokes the `read_field` method of
all sub-fields at least partially covered by `enabled_bytes`, in order
from least to most significant bit. Bits not covered by fields are
retrieved by calling the `read_unmapped_bits`, with
`unmapped_enabled_bits` set as the `enabled_bytes` not covered by
fields. If a register implements no fields, then the
`read_unmapped_bits` is not called by default.

If a register inherits the `read_field` or `read` templates, then that
template takes precedence over `read_register`, and the register's
read behaviour is specified by the `read_field` or `read` method.
*/
template read_register {
    shared method read_register(uint64 enabled_bytes, void *aux) -> (uint64);
}

/**
### write\_register

Implemented only by registers, not applicable to fields.

Provides a single abstract method:
`write_register(uint64 value, uint64 enabled_bytes, void *aux)`.

The method writes to the register, possibly with side-effects. The
`enabled_bytes` parameter is defined as in the `read_register` method.

Register objects provide a default implementation of write_register.
The default behaviour depends on whether the register has fields:

* If the register has no fields, then
  the default behaviour is to set the register's `val` member to the
  new value, using the `set` method.

* If the register has fields, then the default behavior is to
  invoke the `write_field` method of all sub-fields covered at
  least partially by `enabled_bytes`, in order from
  least to most significant bit. Then `write_unmapped_bits`
  is called with the enabled bits that were not covered by fields.

  If a register inherits the `write` or
  `write_field` template, then that template takes precedence
  over `write_register`, and the register's write behaviour is
  specified by the `write` (or `write_field`) method.
*/
template write_register {
    shared method write_register(uint64 val, uint64 enabled_bytes, void *aux);
}

/**
### read\_field

Provides a single abstract method
`read_field(uint64 enabled_bits, void *aux) -> (uint64)`.

The method reads from a field or register, possibly with
side-effects. The returned value is represented in the host's native
endianness. The `enabled_bits` argument defines which bits of the
register is accessed, as a bitmask; each bit of the returned value has
significance only if the corresponding bit in `enabled_bits` is 1. If
the access covers more than one field, then the parts of
`enabled_bits` that correspond to other fields are still zero.

The `read_field` template is *not* implemented by
fields or registers by default, and must be explicitly instantiated in
order for a method override to have effect.
`read_field` is the interface used for access by registers;
in most cases, it is easier to express read operations using the
`read` template.

Note that instantiating `read_field` on a register means that
register reads behave as if the register consists of one single field; a
read access will ignore any actual field subobjects in the register.
*/
template read_field {
    shared method read_field(uint64 enabled_bits, void *aux) -> (uint64);
}

/**
### write\_field

Provides a single abstract method
`write_field(uint64 value, uint64 enabled_bits, void *aux)`.

The method writes to a field or register, possibly with
side-effects. The value is represented in the host's native
endianness. The `enabled_bits` argument is defined as in the
`read_field` method.

The `write_field` template is *not* implemented by fields or registers
by default, and must be explicitly instantiated in order for a method
override to have effect.  `write_field` is the interface used for
access by registers; in most cases, it is easier to express write
operations using the `write` template.

Note that instantiating `write_field` on a register means that
register writes behave as if the register consists of one single
field; a write access will ignore any actual field subobjects in the
register.  This is often useful in read-only registers, as it allows
reads to propagate to fields, while a violating write can be handled
centrally for the whole register.
*/
template write_field {
    shared method write_field(uint64 val, uint64 enabled_bits, void *aux);
}

template _reg_read_as_field is (register, read_register, read_field) {
    shared method read_register(uint64 enabled_bytes, void *aux)
        -> (uint64) {
        return enabled_bytes == 0 ? 0
            : this.read_field(enabled_bytes, aux) & enabled_bytes;
    }
}

in each (read_field, register) { is _reg_read_as_field; }

template _reg_write_as_field is (register, write_register, write_field) {
    shared method write_register(uint64 val, uint64 enabled_bytes, void *aux) {
        if (enabled_bytes != 0) {
            this.write_field(val & enabled_bytes, enabled_bytes, aux);
        }
    }
}

in each (write_field, register) { is _reg_write_as_field; }

template _bitsize {
    // Must be a multiple of 8 for registers, but not for fields.
    param bitsize : uint8;
}

/**
### read

Extends templates [`read_field`](#read_field) and [`get_val`](#get_val).

Provides a single overrideable method `read() -> (uint64)`.

The method reads from a field or register, possibly with
side-effects. The returned value is represented in the host's native
endianness. The default behaviour is to retrieve the value using the
`get` method.

The `read` template is *not* implemented by fields or registers by
default, and must be explicitly instantiated in order for a method
override to have effect.

Note that instantiating `read` on a register means that register reads
behave as if the register consists of one single field; a read access
will ignore any actual field subobjects in the register.
*/
template read is (read_field, _get) {
    shared method read_field(uint64 enabled_bits, void *aux) -> (uint64) {
        return enabled_bits == 0 ? 0 : this.read() & enabled_bits;
    }
    // convenience method for simple whole-field access
    shared method read() -> (uint64) default {
        return get();
    }
}

/**
### write

Extends templates [`write_field`](#write_field), [`get_val`](#get_val) and
[`set_val`](#set_val).

Provides a single overrideable method `write(uint64)`.

The method writes to a field or register, possibly with
side-effects. The value is represented in the host's native
endianness. The default behaviour is to set the value using the `set`
method.

The `write` template is *not* implemented by fields or registers by
default, and must be explicitly instantiated in order for a method
override to have effect.

Note that instantiating `write` on a register means that register
writes behave as if the register consists of one single field; a write
access will ignore any actual field subobjects in the register.
*/
template write is (write_field, _get, _set) {
    shared method write_field(uint64 val, uint64 enabled_bits, void *aux) {
        if (enabled_bits != 0) {
            local uint64 patched = this.get() & ~enabled_bits;
            this.write(patched | (val & enabled_bits));
        }
    }
    // convenience method for simple whole-field access
    shared method write(uint64 val) default {
        set(val);
    }
}

/**
### init\_val

Extends the [`init`](#init) template.

Provides a parameter `init_val : uint64`, defining the initial value
of the register's `val` member when the object is created. In a field,
defines the initial value of the bits of `val` that are covered by
this field. The parameter is also used by default reset methods.

The template is inherited by both registers and fields. The value is 0
by default. In a register with fields, parameter overrides are
permitted both in the register and in the field objects:


* if the parameter is overridden *only* in the register, then this
  defines the full value of the register.

* if the parameter is overridden both in the register and in some fields,
  then the field overrides take precedence and define the value of the bits
  covered by the field

On a technical level, the default value of `init_val` in a field is
the field's corresponding bits in the parent register's `init_val`;
furthermore, the `init_val` template provides a default
implementation of the `init` method which in register objects sets
bits in `val` not covered by fields, and in field objects sets
corresponding bits of the parent register's `val` member.
*/
// The init_val parameter, only for use by registers and fields.
template init_val is init {
    param init_val default _init_val;
    param _init_val default _default_init_val;
    param init_val : uint64;
    shared method init() default {
        this._default_init();
    }
    // implemented by fields and registers
    shared method _default_init();
    param _default_init_val default 0;
}

extern const char *_DML_get_qname(_identity_t, const _id_info_t *,
                                  dml_qname_cache_t *, const char *);
template _qname {
    shared method _qname() -> (const char *) {
        local _qname ref = this;
        return _DML_get_qname(cast(&ref, _traitref_t *)->id, _id_infos,
                              &_qname_cache, dev.name);
    }
}

template _read_field is (read_field, _lsb, _bitsize) {}
in each (read_field, field) { is _read_field; }
template _write_field is (write_field, _lsb, _bitsize) {}
in each (write_field, field) { is _write_field; }
template _get_field is (get, _lsb, _bitsize) {}
in each (get, field) { is _get_field; }
template _set_field is (set, _lsb, _bitsize) {}
in each (set, field) { is _set_field; }

extern int (*const DML_pointer_eq)(void *data, void *match_data);

/**
## Event objects

The `event` template contains little functionality in itself; it
requires one of six predefined templates `simple_time_event`,
`simple_cycle_event`, `uint64_time_event`,
`uint64_cycle_event`, `custom_time_event`, and
`custom_cycle_event` to be instantiated. These templates expose the
methods `event` and `post`, and possibly others.

In addition to the [`object`](#object) template, the `event` template inherits
the [`shown_desc`](#shown_desc) template.
*/
template event is (object, shown_desc) {
    // hack: using double pointer here, since the automatic initialization of
    // the evclass pointer happens after vtables are initialized
    param _pevclass : event_class_t *const*;
    param _pevclass = &evclass;
    param objtype = "event";
    param _is_simics_object = false;
    param limitations = undefined;
    // Internal. TODO: should be soft-coded, US1591
    param evclass auto;

    // hack to get a helpful error message
    param _ok default false;

    #if (!_ok) {
        error "Need to instantiate one of the templates"
            + " {simple,uint64,custom}_{time,cycle}_event";
    }

    // implemented by simple_event, custom_event or uint64_event
    shared method _callback(void *user);
    shared method _describe_event(void *data) -> (char *);
    shared method _get_event_info(void *data) -> (attr_value_t);
    shared method _set_event_info(attr_value_t info) -> (void *);
    shared method _destroy(void *data);

    // internal, automatically invoked on object deletion
    method _cancel_all() {
        if (!SIM_object_clock(dev.obj))
            // without a clock, we cannot have posted any events
            return;
        SIM_event_cancel_time(dev.obj, evclass, dev.obj, NULL, NULL);
    }
    // internal callbacks, invoked by auto-generated callback functions
    method __describe_event(void *data) -> (char *) default {
        return _describe_event(data);
    }
    method __get_event_info(void *data) -> (attr_value_t) {
        return _get_event_info(data);
    }
    method __set_event_info(attr_value_t info) -> (void *) {
        return _set_event_info(info);
    }
    method __destroy(void *data) {
        _destroy(data);
    }
    method __callback(void *user) { this._callback(user); }
}

/**
## Event templates

Each `event` object is required to instantiate one of six
predefined templates: `simple_time_event`, `simple_cycle_event`,
`uint64_time_event`, `uint64_cycle_event`,
`custom_time_event`, and `custom_cycle_event`. These are defined as follows:

* The `simple_*_event` templates are used for events that carry no
  data

* The `uint64_*_event` templates are used for events parameterized
  with a single 64-bit integer value

* The `custom_*_event` templates are used for events that carry more
  complex data; the user must supply explicit serialization and deserialization
  methods.

* In the `*_time_event` templates, time is provided in seconds, as a
  floating-point number


* In the `*_cycle_event` templates, time is provided in cycles, as
  a 64-bit integer


The following methods are defined by all six templates:

<dl><dt>

<small>event()</small>, <small>event(uint64 data)</small>, <small>event(void
\*data)</small>
</dt><dd>

Abstract method, called when the event is triggered. When one of
the `custom_*_event` templates is used, the `event`
method is responsible for deallocating the data.
</dd><dt>

<small>post(time), post(time, uint64 data), post(time, void \*data)</small>
</dt><dd>

Non-overrideable method. Posts the event on the associated queue of the
device. The time argument is specified in cycles or seconds, depending on which
template was instantiated. The event will be triggered after the specified
amount of time has elapsed. The data parameter in a `uint64` or
`custom` event will be passed on to the event() method.
</dd></dl>

The following methods are specific to the `simple_time_event`,
`simple_cycle_event`, `uint64_time_event` and
`uint64_cycle_event` templates:

<dl><dt>

<small>remove(), remove(uint64 data)</small>
</dt><dd>

Removes all events of this type with matching data from
the queue.
</dd><dt>

<small>posted() -&gt; (bool), posted(uint64 value) -&gt; (bool)</small>
</dt><dd>

Returns `true` if the event is in the queue, and
`false` otherwise.
</dd><dt>

<small>next(), next(uint64 data) -&gt; (double or cycles\_t)</small>
</dt><dd>

Returns the time to the next occurrence of the event in the queue
(relative to the current time), in cycles or seconds depending on which
event template was instantiated. If there is no such event in the
queue, a negative value is returned.
</dd></dl>

The following methods are specific to the `custom_time_event`
and `custom_cycle_event` templates:

<dl><dt>

<small>get\_event\_info(void \*data) -&gt; (attr\_value\_t)</small>
</dt><dd>

This method is called once for each pending event instance when
saving a checkpoint.  It should create an attribute value that can be
used to restore the event.  The `data` parameter is the
user data provided in the `post` call.  The default
implementation always returns a nil value.
</dd><dt>

<small>set\_event\_info(attr\_value\_t info) -&gt; (void \*)</small>
</dt><dd>

This method is used to restore event information when loading a
checkpoint.  It should use the attribute value to create a user data
pointer, as if it had been provided in a `post`. The default
implementation only checks that the checkpointed information is
nil.
</dd><dt>

<small>destroy(void \*data)</small>
</dt><dd>

This method is called on any posted events when the device object is deleted.
<!-- (and also on `SIM_event_cancel_*`, but that function is not exposed for
custom events so no need to mention) -->

If memory was allocated for the `data` argument to `post`, then `destroy`
should free this memory.

The `destroy` method is *not* called automatically when an event is triggered;
therefore, the method should typically also be called explicitly from the
`event` method.
</dd></dl>
*/
template _event is event {
}

template _time_event is _event {
    shared method _post(double when, void *data) {
        local conf_object_t *clk = SIM_object_clock(dev.obj);
        if (clk == NULL)
            log error: "The 'queue' attribute is not set,"
                + " cannot post event";
        else
            SIM_event_post_time(clk, *_pevclass, dev.obj, when, data);
    }
    shared method _next(void *data) -> (double) {
        return SIM_event_find_next_time(dev.obj, *_pevclass,
                                        dev.obj, DML_pointer_eq, data);
    }
}

template _cycle_event is _event {
    shared method _post(uint64 when, void *data) {
        local conf_object_t *clk = SIM_object_clock(dev.obj);
        if (clk == NULL)
            log error: "The 'queue' attribute is not set,"
                + " cannot post event";
        else
            SIM_event_post_cycle(clk, *_pevclass, dev.obj, when, data);
    }
    shared method _next(void *data) -> (uint64) {
        return SIM_event_find_next_cycle(dev.obj, *_pevclass,
                                         dev.obj, DML_pointer_eq, data);
    }
}

template _simple_event is _event {
    param _ok = true;

    shared method event();

    shared method _describe_event(void *data) -> (char *) {
        return MM_STRDUP(shown_desc != NULL ? shown_desc : _qname());
    }
    shared method _get_event_info(void *data) -> (attr_value_t) {
        if (data != NULL) {
            // cannot happen
            log error: "%s: non-NULL event data", _qname();
        }
        return SIM_make_attr_nil();
    }
    shared method _set_event_info(attr_value_t info) -> (void *) {
        if (!SIM_attr_is_nil(info)) {
            log error: "%s: strange event info", _qname();
        }
        return NULL;
    }
    shared method _callback(void *data) { event(); }
    shared method _destroy(void *data) {}

    shared method posted() -> (bool) {
        return SIM_event_find_next_cycle(dev.obj, *_pevclass,
                                         dev.obj, DML_pointer_eq, NULL) >= 0;
    }

    shared method remove() {
        SIM_event_cancel_time(dev.obj, *_pevclass, dev.obj,
                              DML_pointer_eq, NULL);
    }
}

template simple_time_event is (_simple_event, _time_event) {
    shared method post(double when) {
        _post(when, NULL);
    }
    shared method next() -> (double) {
        return _next(NULL);
    }
}

template simple_cycle_event is (_simple_event, _cycle_event) {
    shared method post(cycles_t when) {
        _post(when, NULL);
    }
    shared method next() -> (cycles_t) {
        return _next(NULL);
    }
}

template _custom_event is _event {
    shared method event(void *user);
    shared method get_event_info(void *data) -> (attr_value_t);
    shared method set_event_info(attr_value_t info) -> (void *);
    shared method destroy(void *data);

    shared method _callback(void *data) { event(data); }
    shared method _describe_event(void *data) -> (char *) {
        return MM_STRDUP(shown_desc != NULL ? shown_desc : _qname());
    }
    shared method _get_event_info(void *data) -> (attr_value_t) {
        return get_event_info(data);
    }
    shared method _set_event_info(attr_value_t info) -> (void *) {
        return set_event_info(info);
    }
    shared method _destroy(void *data) { destroy(data); }
    param _ok = true;

    // these methods are disallowed on custom_*_event, because they would place
    // additional requirements on set_event_info. These requirements would be
    // hard to satisfy, unless the data is so simple that it just as well can
    // fit in a uint64_*_event. And if it can, then uint64_event should be used
    // instead.
    method posted(void *data) -> (bool) {
        error "posted() not supported by custom_*_event; use uint64_*_event"
            + " instead";
    }
    method remove(void *data) {
        error "remove() not supported by custom_*_event; use uint64_*_event"
            + " instead";
    }
    method next(void *data) -> (cycles_t) {
        error "next() not supported by custom_*_event; use uint64_*_event"
            + " instead";
    }
}

template custom_time_event is (_custom_event, _time_event) {
    shared method post(double when, void *data) {
        _post(when, data);
    }
}

template custom_cycle_event is (_custom_event, _cycle_event) {
    shared method post(cycles_t when, void *data) {
        _post(when, data);
    }
}

template _uint64_event is _event {
    param _ok = true;
    shared method _callback(void *user) {
        event(cast(user, uintptr_t));
    }
    shared method _describe_event(void *data) -> (char *) {
        return _DML_describe_uint64_event(
            shown_desc != NULL ? shown_desc : _qname(), cast(data, uintptr_t));
    }
    shared method _get_event_info(void *data) -> (attr_value_t) {
        return SIM_make_attr_uint64(cast(data, uintptr_t));
    }
    shared method _set_event_info(attr_value_t info) -> (void *) {
        if (!SIM_attr_is_uint64(info))
            // indicates broken checkpoint
            log error: "negative integer in event info: %d",
                SIM_attr_integer(info);
        return _int_to_voidp(SIM_attr_integer(info));
    }
    shared method _destroy(void *data) {}

    shared method _int_to_voidp(uint64 val) -> (void *) {
        // would fail on a 32-bit host
        assert sizeoftype(uintptr_t) == sizeoftype(uint64);
        return cast(cast(val, uintptr_t), void *);
    }

    shared method posted(uint64 data) -> (bool) {
        return SIM_event_find_next_cycle(dev.obj, *_pevclass,
                                         dev.obj, DML_pointer_eq,
                                         _int_to_voidp(data)) >= 0;
    }

    shared method remove(uint64 data) {
        SIM_event_cancel_time(dev.obj, *_pevclass, dev.obj,
                              DML_pointer_eq, _int_to_voidp(data));
    }

    shared method event(uint64 data);
}

template uint64_time_event is (_uint64_event, _time_event) {
    shared method post(double when, uint64 data) {
        _post(when, _int_to_voidp(data));
    }
    shared method next(uint64 data) -> (double) {
        return _next(_int_to_voidp(data));
    }
}

template uint64_cycle_event is (_uint64_event, _cycle_event) {
    shared method post(cycles_t when, uint64 data) {
        _post(when, _int_to_voidp(data));
    }
    shared method next(uint64 data) -> (cycles_t) {
        return _next(_int_to_voidp(data));
    }
}
