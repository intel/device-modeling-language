/*
  Â© 2010-2023 Intel Corporation
  SPDX-License-Identifier: 0BSD
*/

/* DML runtime utilities needed by the C code generated by dmlc */

#ifndef SIMICS_DML_RAII_TYPES_H
#define SIMICS_DML_RAII_TYPES_H

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <simics/util/alloc.h>
#include <simics/util/help-macros.h>

// Smallest power of two >= x, except _DML_BITCEIL(0) == 0
#define _DML_BITCEIL(x) \
    ((uint32)(x) <= 1 ? (uint32)(x) : (1 << (32 - __builtin_clz((x) - 1))))
// Largest power of two <= x, except _DML_BITFLOOR(0) == 0
#define _DML_BITFLOOR(x) \
    ((uint32)(x) <= 1 ? (uint32)(x) : (1 << (31 - __builtin_clz(x))))

// Variant of strbuf, but where 0-initialization is valid.
// Invariants:
// - size > len OR size == len == 0
// - size > 0 implies s != NULL and s[len] == '\0'
typedef struct {
    char *s;
    uint32 size;
    uint32 len;
} _dml_string_t;

/* minimum allocation size */
#define _DML_STRING_INITIAL_SIZE 32

/* return string as C-string, always 0-terminated.
   Only guaranteed valid as long as the argument is alive and
   unmodified.
   May be written to, but only at indices less than len
   (the final NUL character may not be written to.) */
UNUSED static inline char *
_dml_string_str(_dml_string_t s) {
    return s.s ? s.s : (char *)"";
}

#define DML_STRING_INBOUNDS(v, i)                           \
    ASSERT_FMT((i) >= 0 && (i) < (v).len,                   \
               "OOB index %u for DML string of length %u",  \
               (unsigned) i, (v).len)

#define DML_STRING_CHAR(str, i) (*({                                           \
        _dml_string_t __string = (str);                                        \
        uint32 __index = (i);                                                  \
        DML_STRING_INBOUNDS(__string, __index);                                \
        &__string.s[__index];                                                  \
    }))

UNUSED static inline void
_dml_string_init(_dml_string_t *s) {
	s->s = NULL;
	s->size = 0;
	s->len = 0;
}

UNUSED static void
_dml_string_realloc(_dml_string_t *s, uint32 new_size) {
    // new_size is a power of two or 0
    ASSERT((new_size & (new_size - 1)) == 0);
    if (unlikely(new_size == s->size)) {
        return;
    }
    // TODO(RAII) This path is unused. Remove?
    if (unlikely(new_size == 0)) {
        MM_FREE(s->s);
        s->s = NULL;
        s->size = s->len = 0;
        return;
    }
    s->s = MM_REALLOC_SZ(s->s, new_size, char);
    s->size = new_size;
}

UNUSED static void
_dml_string_realloc_for_len(_dml_string_t *s, uint32 new_len) {
    ASSERT(s->len < s->size || (s->len == 0 && s->size == 0));
    if (s->len == new_len) {
        return;
    }
    uint32 new_size = s->size;
    if ((s->size > _DML_STRING_INITIAL_SIZE && new_len + 1 < s->size/4)) {
        new_size = MAX(_DML_STRING_INITIAL_SIZE, _DML_BITCEIL(new_len + 1)*2);
    } else if (new_len + 1 > s->size) {
        new_size = MAX(_DML_STRING_INITIAL_SIZE, _DML_BITCEIL(new_len + 1));
    }
    // This assert also catches if the buf grows to be larger than
    // 2^32-1 elements
    ASSERT(new_size >= new_len);
    if (new_size != s->size)
        _dml_string_realloc(s, new_size);
}

UNUSED static void
_dml_string_resize(_dml_string_t *s, uint32 new_len) {
    uint32 prev_len = s->len;
    if (prev_len == new_len) return;
    _dml_string_realloc_for_len(s, new_len);
    s->len = new_len;
    if (s->size) {
        if (prev_len > new_len) {
            s->s[new_len] = '\0';
        } else {
            memset(s->s + prev_len + 1, 0, new_len - prev_len);
        }
    }
}

UNUSED __attribute__ ((const)) static inline bool
_dml_pointers_overlap(const void *const orig, const void *const possible_deriv,
                      const size_t orig_size) {
    return (uintptr_t)(orig) + orig_size > (uintptr_t)possible_deriv
        && (uintptr_t)possible_deriv >= (uintptr_t)orig;
}

/* set a string to the contents of a C-string */
UNUSED static void
_dml_string_set(_dml_string_t *s, const char *str) {
    if (unlikely(_dml_pointers_overlap(s->s, str, s->size))) {
        uint32 new_len = s->len - (uint32)((uintptr_t)str - (uintptr_t)s->s);
        if (new_len == s->len) return;
        memmove(s->s, str, new_len + 1);
        _dml_string_realloc_for_len(s, new_len);
        s->len = new_len;
        return;
    }
    uint32 len = strlen(str);
    _dml_string_realloc_for_len(s, len);
    if (s->size)
        memcpy(s->s, str, len + 1);
    s->len = len;
}

/* make a string empty */
UNUSED static inline void
_dml_string_clear(_dml_string_t *s)
{
    _dml_string_realloc_for_len(s, 0);
    if (s->size)
        s->s[0] = '\0';
    s->len = 0;
}

/* set a string to the contents of another string */
UNUSED static void
_dml_string_copy(_dml_string_t *dst, _dml_string_t src) {
    if (src.s == dst->s) {
        ASSERT(dst->len == src.len && dst->size == src.size);
        return;
    }
    if (src.len) {
        _dml_string_realloc_for_len(dst, src.len);
        memcpy(dst->s, src.s, src.len + 1);
        dst->len = src.len;
    } else {
        _dml_string_clear(dst);
    }
}

/* Free storage associated with a string, making it empty.
   The string should not be used after calling this function. */
UNUSED static void
_dml_string_free(_dml_string_t s)
{
    MM_FREE(s.s);
}

UNUSED static inline void
_dml_string_move(_dml_string_t *dst, _dml_string_t src) {
    _dml_string_free(*dst);
    *dst = src;
}

/* append s2 to s1 */
UNUSED static void
_dml_string_cat(_dml_string_t *s1, _dml_string_t s2)
{
    if (s2.len == 0) return;
    if (unlikely(s1->s == s2.s)) {
        ASSERT(s1->len == s2.len && s1->size == s2.size);
        _dml_string_realloc_for_len(s1, 2*s2.len);
        memcpy(s1->s + s2.len, s1->s, s2.len);
        s1->len = 2*s2.len;
        s1->s[s1->len] = '\0';
    } else {
        _dml_string_realloc_for_len(s1, s1->len + s2.len);
        memcpy(s1->s + s1->len, s2.s, s2.len + 1);
        s1->len += s2.len;
    }
}

/* append a C-string to a strbuf */
UNUSED static void
_dml_string_addstr(_dml_string_t *s, const char *str)
{
    if (unlikely(_dml_pointers_overlap(s->s, str, s->size))) {
        uint32 offset = (uintptr_t)str - (uintptr_t)s->s;
        uint32 new_len = 2*s->len - offset;
        if (new_len == s->len) return;
        _dml_string_realloc_for_len(s, new_len);
        memcpy(s->s + s->len, s->s + offset, s->len - offset);
        s->s[new_len] = '\0';
        s->len = new_len;
        return;
    }
    uint32 len = strlen(str);
    if (!len)
        return;
    _dml_string_realloc_for_len(s, s->len + len);
    memcpy(s->s + s->len, str, len + 1);
    s->len += len;
}

/* append a C-string to a strbuf */
UNUSED static void
_dml_string_addstr_before(const char *str, _dml_string_t *s)
{
    if (unlikely(_dml_pointers_overlap(s->s, str, s->size))) {
        uint32 offset = (uintptr_t)str - (uintptr_t)s->s;
        uint32 len = s->len - offset;
        if (!len) return;
        _dml_string_realloc_for_len(s, s->len + len);
        memmove(s->s + len, s->s, s->len + 1);
        memcpy(s->s, s->s + len + offset, len);
        s->len += len;
        return;
    }
    uint32 len = strlen(str);
    if (!len) return;
    _dml_string_realloc_for_len(s, s->len + len);
    memmove(s->s + len, s->s, s->len + 1);
    memcpy(s->s, str, len);
    s->len += len;
}

/* append a counted string to a strbuf */
UNUSED static void
_dml_string_addmem(_dml_string_t *s, const char *str, uint32 len)
{
    if (!len)
        return;
    if (unlikely(_dml_pointers_overlap(s->s, str, s->size))) {
        uint32 offset = (uintptr_t)str - (uintptr_t)s->s;
        // + 1 as including the NUL byte is allowed
        ASSERT(len <= s->len - offset + 1);
        _dml_string_realloc_for_len(s, s->len + len);
        memcpy(s->s + s->len, s->s + offset, len);
        s->len += len;
        s->s[s->len] = '\0';
        return;
    }
    _dml_string_realloc_for_len(s, s->len + len);
    memcpy(s->s + s->len, str, len);
    s->len += len;
    s->s[s->len] = '\0';
}

/* add a character to a string */
UNUSED static void
_dml_string_addc(_dml_string_t *s, char c)
{
    _dml_string_realloc_for_len(s, s->len + 1);
    s->s[s->len++] = c;
    s->s[s->len] = '\0';
}

/* add a character repeated a given number of times to a string */
UNUSED static void
_dml_string_addchars(_dml_string_t *s, char c, unsigned n)
{
    _dml_string_realloc_for_len(s, s->len + n);
    memset(s->s + s->len, c, n);
    s->len += n;
    s->s[s->len] = '\0';
}

/* return a copy of a string */
UNUSED static inline _dml_string_t
_dml_string_dupe(_dml_string_t s)
{
    _dml_string_t new_s = {0};
    _dml_string_cat(&new_s, s);
    return new_s;
}

/* Delete at most n characters from position start.
   If start is negative, count from the end. */
UNUSED static void
_dml_string_delete(_dml_string_t *s, int start, unsigned n)
{
    if (start < 0)
        start = s->len + start;

    /* Avoid deleting too many characters. */
    if (start + n > s->len)
        n = s->len - start;

    if (s->len)
        memmove(s->s + start, s->s + start + n,
                s->len - (start + n) + 1);
    _dml_string_realloc_for_len(s, s->len - n);
    s->len -= n;
}

/* Insert n characters from str at index start (start <= s->len) */
UNUSED static void
_dml_string_insertmem(_dml_string_t *s, uint32 start, const char *str, uint32 n)
{
    ASSERT(start <= s->len);
    if (!n) return;
    bool overlap = _dml_pointers_overlap(s->s, str, s->size);
    if (unlikely(overlap)) {
        char *duped_str = MM_MALLOC(n, char);
        memcpy(duped_str, str, n);
        str = duped_str;
    }
    _dml_string_realloc_for_len(s, s->len + n);
    memmove(s->s + start + n, s->s + start, s->len - start + 1);
    memcpy(s->s + start, str, n);
    s->len += n;
    if (unlikely(overlap)) {
        MM_FREE((char *)str);
    }
}

/* Insert a zero-terminated string at index start (start <= s->len) */
UNUSED static inline void
_dml_string_insertstr(_dml_string_t *s, unsigned start, const char *str)
{
    _dml_string_insertmem(s, start, str, strlen(str));
}

/* return a fresh strbuf initialised to a copy of a C string */
UNUSED static _dml_string_t
_dml_string_new(const char *init)
{
    _dml_string_t s = {0};
    _dml_string_set(&s, init);
    return s;
}


/* return a fresh strbuf initialised to a copy of a counted C string */
UNUSED static _dml_string_t
_dml_string_new_counted(const char *init, uint32 size)
{
    _dml_string_t s = {0};
    _dml_string_addmem(&s, init, size);
    return s;
}

/* return allocated C-string, and clear strbuf */
UNUSED static char *
_dml_string_detach(_dml_string_t *s)
{
    char *detached = s->s;
    if (s->size == 0) {
        /* special case: returned malloced zero-sized string */
        detached = MM_MALLOC(1, char);
        *detached = 0;
    }
    _dml_string_init(s);
    return detached;
}

/* output a string to a file. return number of characters written */
UNUSED static int
_dml_string_write(_dml_string_t s, FILE *f)
{
    return fwrite(_dml_string_str(s), 1, s.len, f);
}

/* append formatted text to string */
UNUSED static void
_dml_string_vaddfmt(_dml_string_t *s, const char *format, va_list va)
{
    va_list va2;
    va_copy(va2, va);
    int need = vsnprintf(NULL, 0, format, va2);
    va_end(va2);
    ASSERT(need >= 0);
    // Inefficient, but avoids aliasing issues
    char *tmp = MM_MALLOC(need + 1, char);
    int need2 = vsnprintf(tmp, need + 1, format, va);
    ASSERT(need == need2);
    _dml_string_realloc_for_len(s, s->len + need);
    if (s->size)
        memcpy(s->s + s->len, tmp, need + 1);
    s->len += need;
    MM_FREE(tmp);
}

/* append formatted text to string */
UNUSED PRINTF_FORMAT(2, 3) static void
_dml_string_addfmt(_dml_string_t *s, const char *format, ...)
{
    va_list va;

    va_start(va, format);
    _dml_string_vaddfmt(s, format, va);
    va_end(va);
}

/* return a fresh DML string initialised to a formatted string */
UNUSED static _dml_string_t
_dml_string_vnewf(const char *format, va_list va)
{
    va_list va2;
    va_copy(va2, va);
    int need = vsnprintf(NULL, 0, format, va2);
    va_end(va2);
    ASSERT(need >= 0);
    _dml_string_t s = {0};
    if (!need)
        return s;
    _dml_string_realloc_for_len(&s, need);
    int need2 = vsnprintf(s.s, need + 1, format, va);
    ASSERT(need == need2);
    s.len = need;
    return s;
}

/* return a fresh DML string initialised to a formatted string */
UNUSED PRINTF_FORMAT(1, 2) static _dml_string_t
_dml_string_newf(const char *format, ...)
{
    va_list va;
    va_start(va, format);
    _dml_string_t s = _dml_string_vnewf(format, va);
    va_end(va);
    return s;
}


/* assign formatted text to string */
UNUSED static void
_dml_string_vfmt(_dml_string_t *s, const char *format, va_list va)
{
    _dml_string_move(s, _dml_string_vnewf(format, va));
}

/* assign formatted text to string */
UNUSED static void
PRINTF_FORMAT(2, 3)
_dml_string_fmt(_dml_string_t *s, const char *format, ...)
{
    va_list va;
    va_start(va, format);
    _dml_string_vfmt(s, format, va);
    va_end(va);
}

/* Add character, escaped if not printable or if delimiter */
UNUSED static void
_dml_string_addesc(_dml_string_t *s, char c, char delim)
{
    static const char ctrlchars[] = {
        0, 0, 0, 0, 0, 0, 0, 'a', 'b', 't', 'n', 'v', 'f', 'r'
    };
    unsigned char uc = c;
    _dml_string_realloc_for_len(s, s->len + 4); /* room for "\377" */
    /* Don't escape values in 0x80..0xff - it would severely reduce
       readability of UTF-8 strings */
    if (uc < 0x20 || uc == 0x7f) {
        /* control char */
        s->s[s->len++] = '\\';
        if (uc < sizeof ctrlchars && ctrlchars[uc])
            s->s[s->len++] = ctrlchars[uc];
        else {
            sprintf(s->s + s->len, "%03o", uc);
            s->len += 3;
        }
    } else {
        /* printable */
        if (uc == delim || uc == '\\')
            s->s[s->len++] = '\\';
        s->s[s->len++] = uc;
    }
    s->s[s->len] = '\0';
}

/* Read a line from f into s, replacing previous contents if any, and
   return true. If EOF was encountered before anything could be read,
   return false. The contents of s are then undefined.
   The buffer will not contain the terminating newline. The last line of
   a stream will be read in even if not newline-terminated. */
UNUSED static bool
_dml_string_readline(_dml_string_t *s, FILE *f)
{
    /* BUG: This routine cannot read lines containing null bytes,
       because fgets() does not tell us how many bytes it reads.

       We could pad the buffer with nonzero bytes before calling
       fgets() and detect the last null byte, but that would be
       slow and complicate the code. Or we could do a simpler
       solution based on getc_unlocked(), but we would have to
       use plain getc() on Windows and that is quite slow. */

    unsigned min_room = 128;
    unsigned got = 0;
    for (;;) {
        unsigned room = s->len - got;
        if (room < min_room) {
            room = min_room;
            _dml_string_resize(s, got + room);
        }
        if (!fgets(s->s + got, room, f)) {
            if (got > 0)
                break;
            else
                return false;
        }
        got += strlen(s->s + got);
        if (got > 0 && s->s[got - 1] == '\n') {
            got--;
            break;
        }
    }
    _dml_string_resize(s, got);
    return true;
}



// Invariants:
// - size is a power of two, or 0
// - elements == NULL if and only if size == 0
// - len <= size
// - if size != 0 then start < size else start == 0
typedef struct {
    char *elements;
    uint32 size;
    uint32 start;
    uint32 len;
} _dml_vect_t;

#define DML_VECT_INDEX(v, i) \
    (((v).start + (i)) & ((v).size - 1))


#define DML_VECT_ELEMENTS(t, v) \
    ((typeof(t) *)(_dml_vect_elements(sizeof(t), &(v)))

// TODO(RAII): consider removal
#define DML_VECT_ELEMENTS_FALLBACK(t, v, duped) (({                           \
        _dml_vect_t __vect = v;                                               \
        (typeof(t) *)(__vect.start + __vect.len <= __vect.size                \
                      ? __vect.elements + __vect.start*sizeof(t)              \
                      : _dml_vect_elements(sizeof(t), &duped));               \
    }))

#define DML_VECT_INBOUNDS(v, i)                             \
    ASSERT_FMT((i) >= 0 && (i) < (v).len,                   \
               "OOB index %u for DML vector of length %u",  \
               (unsigned) i, (v).len)

#define DML_VECT_ELEM_UNSAFE(t, v, i)                       \
    (((typeof(t) *)(v).elements)[DML_VECT_INDEX((v), (i))])

#define DML_VECT_ELEM(t, v, i) (*({                                     \
        _dml_vect_t __vect = v;                                         \
        uint32 __index = i;                                             \
        DML_VECT_INBOUNDS(__vect, __index);                             \
        &DML_VECT_ELEM_UNSAFE(t, __vect, __index);                      \
    }))

#define DML_VECT_REMOVE(t, v, i) (({                                        \
        _dml_vect_t *__vect = &(v);                                         \
        uint32 __index = i;                                                 \
        DML_VECT_INBOUNDS(*__vect, __index);                                \
        typeof(t) __popped = DML_VECT_ELEM_UNSAFE(t, *__vect, __index);     \
        _dml_vect_remove(sizeof(t), __vect, __index);                       \
        __popped;                                                           \
    }))

#define DML_VECT_NEW_ELEM_AT(t, v, i) (*(typeof(t) *)({                     \
        _dml_vect_t *__vect = &(v);                                         \
        uint32 __index = i;                                                 \
        ASSERT_FMT(__index >= 0 && __index <= __vect->len,                  \
                   "OOB insertion index %u for DML vector of length %u",    \
                   (unsigned) __index, __vect->len);                        \
        _dml_vect_new_at(sizeof(t), __vect, __index);                       \
    }))

#define DML_VECT_NEW_ELEM_AT_BACK(t, v) (*({                                  \
        _dml_vect_t *__vect = &(v);                                           \
        _dml_vect_resize(sizeof(t), __vect, __vect->len + 1, false);          \
        &DML_VECT_ELEM_UNSAFE(t, *__vect, __vect->len - 1);                   \
    }))

#define DML_VECT_NEW_ELEM_AT_FRONT(t, v) \
    (DML_VECT_NEW_ELEM_AT(t, v, 0, e))

#define DML_VECT_POP_BACK(t, v) (({                                           \
        _dml_vect_t *__vect = &(v);                                           \
        ASSERT_MSG(__vect->len >= 0, ".pop_back(): DML vector is empty");     \
        typeof(t) __popped = DML_VECT_ELEM_UNSAFE(t, *__vect, vect->len - 1); \
        _dml_vect_remove(sizeof(t), __vect, vect->len - 1);                   \
        __popped;                                                             \
    }))

#define DML_VECT_POP_FRONT(t, v) (({                                          \
        _dml_vect_t *__vect = &(v);                                           \
        ASSERT_MSG(__vect->len > 0, ".pop_front(): DML vector is empty");     \
        typeof(t) __popped = DML_VECT_ELEM_UNSAFE(t, *__vect, 0);             \
        _dml_vect_remove(sizeof(t), __vect, 0);                               \
        __popped;                                                             \
    }))

#define DML_VECT_INITIAL_ELEMS(elem_size)   \
    MAX(1, _DML_BITFLOOR(32 / (elem_size)))


UNUSED static void
_dml_vect_realloc(size_t elem_size, _dml_vect_t *v, uint32 new_size) {
    // new_size is a power of two or 0
    ASSERT((new_size & (new_size - 1)) == 0);
    // This assert also catches if the buf grows to be larger than
    // 2^32-1 elements
    ASSERT(new_size >= v->len);

    if (unlikely(new_size == v->size)) return;

    // TODO(RAII) This path is unused. Remove?
    if (unlikely(new_size == 0)) {
        MM_FREE(v->elements);
        v->elements = NULL;
        v->size = v->start = v->len = 0;
        return;
    }
    if (new_size > v->size) {
        ASSERT(new_size >= v->start + v->len);
        v->elements = MM_REALLOC_SZ(v->elements, new_size*elem_size, char);
        if (v->start + v->len > v->size)
            memcpy(v->elements + v->size*elem_size,
                   v->elements,
                   (v->len - (v->size - v->start))*elem_size);
    } else {
        // If moving elements is necessary...
        if (v->start + v->len > new_size) {
            if (v->start < new_size) {
                // No preexisting wraparound. Induce wraparound
                memcpy(v->elements,
                       v->elements + new_size*elem_size,
                       (v->len - (new_size - v->start))*elem_size);
            } else {
                // Preexisting wraparound. Move start segment back.
                uint32 start_segment_len = v->size - v->start;
                memcpy(v->elements + (new_size - start_segment_len)*elem_size,
                       v->elements + v->start*elem_size,
                       start_segment_len*elem_size);
                v->start = new_size - start_segment_len;
            }
        }
        v->elements = MM_REALLOC_SZ(v->elements, new_size*elem_size, char);
    }
    v->size = new_size;
}

// Internal. Realtime O(n), amortized O(1)
UNUSED static void
_dml_vect_force(size_t elem_size, _dml_vect_t *v) {
    if (v->len == 0) {
        v->start = 0;
    }
    if (v->len < v->size/4 && v->size > DML_VECT_INITIAL_ELEMS(elem_size)) {
        uint32 new_size;
        if (v->len == 0) {
            new_size = MAX(DML_VECT_INITIAL_ELEMS(elem_size), 2);
        } else {
            new_size = _DML_BITCEIL(v->len);
            new_size = MAX(DML_VECT_INITIAL_ELEMS(elem_size), new_size*2);
        }
        _dml_vect_realloc(elem_size, v, new_size);
    }
}

UNUSED static void
_dml_vect_clear(size_t elem_size, _dml_vect_t *v) {
    v->len = 0;
    _dml_vect_force(elem_size, v);
}

// Realtime O(max(new_len, n)), amortized O(|new_len - n|)
UNUSED static void
_dml_vect_resize(size_t elem_size, _dml_vect_t *v, uint32 new_len,
                 bool zero_init_new) {
    uint32 prev_len = v->len;
    ASSERT(prev_len <= v->size);
    if (new_len == prev_len)
        return;
    v->len = new_len;
    if (new_len <= v->size) {
        _dml_vect_force(elem_size, v);
    } else {
        uint32 new_size = MAX(DML_VECT_INITIAL_ELEMS(elem_size),
                              _DML_BITCEIL(new_len));
        if (new_size != v->size)
            _dml_vect_realloc(elem_size, v, new_size);
    }
    if (zero_init_new && new_len > prev_len) {
        if (v->start + prev_len < v->size) {
            uint32 mid_segment_len = MIN(new_len - prev_len,
                                         v->size - v->start - prev_len);
            memset(v->elements + (v->start + prev_len)*elem_size,
                   0,
                   mid_segment_len*elem_size);
            if (mid_segment_len < new_len - prev_len) {
                memset(v->elements,
                       0,
                       (new_len - prev_len - mid_segment_len)*elem_size);
            }
        } else {
            memset(v->elements + (v->start + prev_len - v->size)*elem_size,
                   0,
                   (new_len - prev_len)*elem_size);
        }
    }
}

UNUSED static void
_dml_vect_resize_destructive(
    size_t elem_size, _dml_vect_t *v, uint32 new_len) {
    v->start = 0;
    _dml_vect_resize(elem_size, v, new_len, false);
}

// O(1) if i is 0 or 1 elements from either end, O(n) otherwise
UNUSED static void
_dml_vect_remove(size_t elem_size, _dml_vect_t *v, uint32 i) {
    ASSERT(i < v->len);

    // Special cases
    if (i == v->len - 1) {
        goto done;
    } else if (i == v->len - 2) {
        memcpy(v->elements + DML_VECT_INDEX(*v, i)*elem_size,
               v->elements + DML_VECT_INDEX(*v, v->len - 1)*elem_size,
               elem_size);
        goto done;
    }
    switch (i) {
    case 0:
        v->start = (v->start + 1) & (v->size - 1);
        goto done;
    case 1:
        memcpy(v->elements + DML_VECT_INDEX(*v, 1)*elem_size,
               v->elements + v->start*elem_size,
               elem_size);
        v->start = (v->start + 1) & (v->size - 1);
        goto done;
    }

    if (v->start + v->len > v->size) {
        // If the vector is discontinuous, then whatever segment the index is
        // in is moved.
        if (v->start + i < v->size) {
            memmove(v->elements + (v->start + 1)*elem_size,
                    v->elements + v->start*elem_size,
                    i*elem_size);
            ++v->start;
        } else {
            uint32 index = v->start + i - v->size;
            memmove(v->elements + index*elem_size,
                    v->elements + (index + 1)*elem_size,
                    (v->len - 1 - i)*elem_size);
        }
    } else {
        // Otherwise, whatever end is closest to the index is moved
        // TODO(RAII): consider always moving the back end in order to avoid
        // contributing to future discontinuity
        if (i < v->len/2) {
            memmove(v->elements + (v->start + 1)*elem_size,
                    v->elements + v->start*elem_size,
                    i*elem_size);
            v->start = (v->start + 1) & (v->size - 1);
        } else {
            memmove(v->elements + (v->start + i)*elem_size,
                    v->elements + (v->start + i + 1)*elem_size,
                    (v->len - 1 - i)*elem_size);
        }
    }
  done:
    --v->len;
    _dml_vect_force(elem_size, v);
}

// O(1) amortized if i is 0 or 1 elements from either end, O(n) otherwise
UNUSED static void *
_dml_vect_new_at(size_t elem_size, _dml_vect_t *v, uint32 i) {
    ASSERT(i <= v->len);
    _dml_vect_resize(elem_size, v, v->len + 1, false);

    // Special cases
    if (i == v->len - 1) {
        goto done;
    } else if (i == v->len - 2) {
        memcpy(v->elements + DML_VECT_INDEX(*v, v->len - 1)*elem_size,
               v->elements + DML_VECT_INDEX(*v, i)*elem_size,
               elem_size);
        goto done;
    }
    switch (i) {
    case 0:
        v->start = (v->start - 1) & (v->size - 1);
        goto done;
    case 1:
        memcpy(v->elements + v->start,
               v->elements + DML_VECT_INDEX(*v, 1)*elem_size,
               elem_size);
        goto done;
    }

    if (v->start + v->len > v->size) {
        // If the vector is discontinuous, then whatever segment the index is
        // in is moved.
        if (v->start + i < v->size) {
            memmove(v->elements + (v->start - 1)*elem_size,
                    v->elements + v->start*elem_size,
                    i*elem_size);
            --v->start;
        } else {
            uint32 index = v->start + i - v->size;
            memmove(v->elements + (index + 1)*elem_size,
                    v->elements + index*elem_size,
                    (v->len - i - 1)*elem_size);
        }
    } else {
        // Otherwise, whatever end is closest to the index is moved, if
        // it can be done without incurring wrap-around
        // TODO(RAII): consider always moving the back end in order to avoid
        // contributing to future discontinuity
        if (v->start && i < v->len/2) {
            memmove(v->elements + (v->start - 1)*elem_size,
                    v->elements + v->start*elem_size,
                    i*elem_size);
            --v->start;
        } else {
            memmove(v->elements + (v->start + i + 1)*elem_size,
                    v->elements + (v->start + i)*elem_size,
                    (v->len - 1 - i)*elem_size);
        }
    }
  done:
    return v->elements + DML_VECT_INDEX(*v, i)*elem_size;
}

// Amortized O(1)
UNUSED static void
_dml_vect_replace_with_back(size_t elem_size, _dml_vect_t *v, uint32 i) {
    ASSERT(i < v->len);
    if (i != v->len - 1) {
        memcpy(v->elements + DML_VECT_INDEX(*v, i)*elem_size,
               v->elements + DML_VECT_INDEX(*v, v->len - 1)*elem_size,
               elem_size);
    }
    --v->len;
    _dml_vect_force(elem_size, v);
}

// Amortized O(1)
UNUSED static void
_dml_vect_replace_with_front(size_t elem_size, _dml_vect_t *v, uint32 i) {
    ASSERT(i < v->len);
    if (i != 0) {
        memcpy(v->elements + DML_VECT_INDEX(*v, i)*elem_size,
               v->elements + v->start*elem_size,
               elem_size);
    }
    ++v->start;
    --v->len;
    _dml_vect_force(elem_size, v);
}

// Realtime O(n), hopefully fast
UNUSED static void
_dml_vect_reinit_size(size_t elem_size, _dml_vect_t *v, size_t size) {
    if (!v->size && !size)
        return;
    v->size = MAX(DML_VECT_INITIAL_ELEMS(elem_size), size);
    v->elements = MM_REALLOC_SZ(v->elements, v->size*elem_size, char);
    v->len = v->start = 0;
}

UNUSED static void *
_dml_vect_elements(size_t elem_size, _dml_vect_t *v) {
    // Fast path, O(1) realtime -- the vect is already continuous
    if (v->start + v->len <= v->size) {
        return v->elements + v->start*elem_size;
    }

    // Slow path, O(n) realtime. Reorder the vect into one continuous segment,
    // offset 1/4 into the buf, thus leaving room for at least n/4 future
    // elements at either end.
    // This guarantees O(1) amortized behavior -- the slow path can only be
    // encountered again if Omega(n) elements have been removed or added since.

    // Grow the buffer if we're starting to run out of elements
    if (v->len*2 > v->size) {
        _dml_vect_realloc(elem_size, v, v->size*2);
    }
    uint32 offset = v->size/4;
    if (v->start + v->len <= v->size) {
        // The vect is continuous as a result of realloc.
        // Move it to 1/4 through the buffer if not there already.
        if (v->start != offset) {
            // In this path overlap between the current vect segment and
            // the location of the desired vect segment is guaranteed.
            memmove(v->elements + offset*elem_size,
                    v->elements + v->start*elem_size,
                    v->len*elem_size);
        }
    } else {
        // The vect is discontinuous. Only possible if realloc didn't happen,
        // meaning v->len*2 <= v->size. This also implies v->start > v->len
        uint32 start_segment_len = v->size - v->start;
        uint32 end_segment_len = v->len - start_segment_len;

        if (offset < end_segment_len) {
            // Current end segment overlaps with desired vect segment.
            // This implies (proof omitted): offset + v->len <= v->start
            // SO: may memmove the end segment, then copy the start segment
            memmove(v->elements + (offset + start_segment_len)*elem_size,
                    v->elements,
                    end_segment_len*elem_size);
            memcpy(v->elements + offset*elem_size,
                   v->elements + v->start*elem_size,
                   start_segment_len*elem_size);
        } else {
            // Either no overlap, or current start segment overlaps with
            // desired vect segment.
            // We have that offset >= end_segment_len
            // SO: may memmove the start segment, then copy the end segment
            memmove(v->elements + offset*elem_size,
                    v->elements + v->start*elem_size,
                    start_segment_len);
            memcpy(v->elements + (offset + start_segment_len)*elem_size,
                   v->elements,
                   end_segment_len*elem_size);
        }
    }
    v->start = offset;
    return v->elements + offset*elem_size;
}


// O(n)
UNUSED static void
_dml_vect_copy_to_index(size_t elem_size, _dml_vect_t *tgt, _dml_vect_t src,
                        uint32 i) {
    // Aliasing must be dealt with before this call!
    ASSERT(src.elements != tgt->elements);
    ASSERT(i + src.len <= tgt->len);

    uint32 tgt_start = DML_VECT_INDEX(*tgt, i);
    uint32 src_start_len = MIN(src.len, src.size - src.start);
    uint32 tgt_start_len = MIN(src.len, tgt->size - tgt_start);

    memcpy(tgt->elements + tgt_start*elem_size,
           src.elements + src.start*elem_size,
           MIN(src_start_len, tgt_start_len)*elem_size);
    if (src_start_len < tgt_start_len) {
        memcpy(tgt->elements + (tgt_start + src_start_len)*elem_size,
               src.elements,
               (tgt_start_len - src_start_len)*elem_size);
    } else if (tgt_start_len < src_start_len) {
        memcpy(tgt->elements,
               src.elements + (src.start + tgt_start_len)*elem_size,
               (src_start_len - tgt_start_len)*elem_size);
    }

    uint32 remainder_offset = MAX(src_start_len, tgt_start_len);
    if (remainder_offset != src.len) {
        memcpy(tgt->elements
               + DML_VECT_INDEX(*tgt, i + remainder_offset)*elem_size,
               src.elements + DML_VECT_INDEX(src, remainder_offset)*elem_size,
               src.len - remainder_offset);
    }
}

UNUSED static void _dml_vect_free(_dml_vect_t v) {
    MM_FREE(v.elements);
}

// O(n)
UNUSED static void
_dml_vect_copy(size_t elem_size, _dml_vect_t *tgt, _dml_vect_t src) {
    if (unlikely((uintptr_t)tgt->elements == (uintptr_t)src.elements)) {
        ASSERT(tgt->size == src.size && tgt->len == src.len
               && tgt->start == src.start);
        return;
    }
    _dml_vect_reinit_size(elem_size, tgt, src.size);
    tgt->len = src.len;
    _dml_vect_copy_to_index(elem_size, tgt, src, 0);
}

// O(n)
UNUSED static _dml_vect_t
_dml_vect_dupe(size_t elem_size, _dml_vect_t src) {
    _dml_vect_t v = {0};
    _dml_vect_copy(elem_size, &v, src);
    return v;
}

// O(n)
UNUSED static void
_dml_vect_append(size_t elem_size, _dml_vect_t *tgt, _dml_vect_t src) {
    if (src.len == 0) return;
    uint32 appendat_index = tgt->len;
    if (unlikely((uintptr_t)tgt->elements == (uintptr_t)src.elements)) {
        ASSERT(tgt->size == src.size && tgt->len == src.len
               && tgt->start == src.start);
        _dml_vect_resize(elem_size, tgt, tgt->len*2, false);
        // TODO(RAII) Rewrite. I believe the logic to be correct, but it is
        // horribly headache inducing
        if (appendat_index*2 <= tgt->size - tgt->start) {
            memcpy(tgt->elements + (tgt->start + appendat_index)*elem_size,
                   tgt->elements + tgt->start*elem_size,
                   appendat_index*elem_size);
        } else if (appendat_index <= tgt->size - tgt->start) {
            uint32 tgt_start_len = tgt->size - tgt->start - appendat_index;
            if (tgt_start_len) {
                memcpy(tgt->elements + (tgt->start + appendat_index)*elem_size,
                       tgt->elements + tgt->start*elem_size,
                       tgt_start_len*elem_size);
            }
            memcpy(tgt->elements,
                   tgt->elements + (tgt->start + tgt_start_len)*elem_size,
                   (appendat_index - tgt_start_len)*elem_size);
        } else {
            uint32 tgt_start_index = DML_VECT_INDEX(*tgt, appendat_index);
            uint32 src_start_len = tgt->size - tgt->start;
            memcpy(tgt->elements + tgt_start_index*elem_size,
                   tgt->elements + tgt->start*elem_size,
                   src_start_len*elem_size);
            memcpy(tgt->elements + (tgt_start_index + src_start_len)*elem_size,
                   tgt->elements,
                   (appendat_index - src_start_len)*elem_size);
        }
    } else {
        _dml_vect_resize(elem_size, tgt, tgt->len + src.len, false);
        _dml_vect_copy_to_index(elem_size, tgt, src, appendat_index);
    }
}

UNUSED static _dml_vect_t
_dml_vect_from_array(size_t elem_size, const void *src, uint32 no_elements) {
    _dml_vect_t v = {0};
    _dml_vect_resize(elem_size, &v, no_elements, false);
    if (v.size)
        memcpy(v.elements, src, no_elements*elem_size);
    return v;
}

UNUSED static void
_dml_vect_set_array(size_t elem_size, _dml_vect_t *tgt, const void *src,
                    uint32 no_elements) {
    if (!no_elements) {
        _dml_vect_clear(elem_size, tgt);
        return;
    }

    bool overlap = _dml_pointers_overlap(tgt->elements, src,
                                         tgt->size*elem_size);

    if (unlikely(overlap)) {
        uint8 *duped_src = MM_MALLOC(no_elements*elem_size, uint8);
        memcpy(duped_src, src, no_elements*elem_size);
        src = duped_src;
    }

    _dml_vect_resize_destructive(elem_size, tgt, no_elements);
    memcpy(tgt->elements, src, no_elements*elem_size);

    if (unlikely(overlap))
        MM_FREE((uint8 *)src);
}

UNUSED static void
_dml_vect_append_array(size_t elem_size, _dml_vect_t *tgt, const void *src,
                       uint32 no_elements) {
    if (!no_elements)
        return;
    bool overlap = _dml_pointers_overlap(tgt->elements, src,
                                         tgt->size*elem_size);
    if (unlikely(overlap)) {
        uint8 *duped_src = MM_MALLOC(no_elements*elem_size, uint8);
        memcpy(duped_src, src, no_elements*elem_size);
        src = duped_src;
    }
    uint32 prev_len = tgt->len;
    _dml_vect_resize(elem_size, tgt, tgt->len + no_elements, false);
    uint32 copyat_start = DML_VECT_INDEX(*tgt, prev_len);
    uint32 tgt_start_len = tgt->size - copyat_start;

    memcpy(tgt->elements + copyat_start*elem_size, src,
           MIN(no_elements, tgt_start_len)*elem_size);
    if (tgt_start_len < no_elements) {
        memcpy(tgt->elements, (uint8 *)src + tgt_start_len*elem_size,
               (no_elements - tgt_start_len)*elem_size);
    }

    if (unlikely(overlap))
        MM_FREE((void *)src);
}

UNUSED static _dml_vect_t
_dml_vect_from_string(_dml_string_t s) {
    if (!s.size) return (_dml_vect_t) {0};
    uint32 new_size = _DML_BITCEIL(s.size);
    if (s.size != new_size)
        s.s = MM_REALLOC_SZ(s.s, new_size, char);
    return (_dml_vect_t) {.elements = s.s, .size = new_size, .len = s.len};
}

UNUSED static _dml_string_t
_dml_string_from_vect(_dml_vect_t v) {
    if (!v.size) return (_dml_string_t) {0};
    if (v.start) {
        (void)_dml_vect_elements(sizeof(char), &v);
        memmove(v.elements, v.elements + v.start, v.len);
    }
    return (_dml_string_t) { .s = v.elements, .size = v.size, .len = v.len };
}

#endif
