/*
  Â© 2010 Intel Corporation
  SPDX-License-Identifier: 0BSD
*/

/* DML runtime utilities needed by the C code generated by dmlc */

#ifndef SIMICS_DMLLIB_H
#define SIMICS_DMLLIB_H

#include <stddef.h>

#include <simics/base/event.h>
#include <simics/base/types.h>
#include <simics/base/log.h>
#include <simics/base/conf-object.h>
#include <simics/base/version.h>
#include <simics/util/swabber.h>
#include <simics/base/object-locks.h>
#include <simics/model-iface/bank-instrumentation.h>
#include <simics/simulator/conf-object.h>
#include <simics/util/alloc.h>
#include <simics/util/hashtab.h>
#include <simics/util/help-macros.h>
#include <simics/util/strbuf.h>
#include <simics/util/swabber.h>

// Copy bits from y given by mask into corresponding bits in x and return the
// result
static inline uint64 DML_combine_bits(uint64 x, uint64 y, uint64 mask)
{
        return (x & ~mask) | (y & mask);
}

#define DML_ASSERT(filename, lineno, expr) do {         \
    if (unlikely(!(expr)))                              \
        assert_error((lineno), (filename), "", NULL);   \
} while (0)

static inline uint64 DML_shlu(uint64 a, uint64 b)
{
        return b > 63 ? 0 : a << b;
}

PRINTF_FORMAT(1, 2) UNUSED static void
_signal_critical_error(const char *restrict format, ...) {
    va_list va;
    va_start(va, format);
    char msg[512];
    vsnprintf(msg, 512, format, va);
    va_end(va);
    VT_critical_error(msg, msg);
}

UNUSED static void
_DML_fault(const char *filename, int lineno, const char *msg)
{
    _signal_critical_error("%s:%d: %s", filename, lineno, msg);
}

static inline int64 DML_shl(int64 a, int64 b, const char *filename, int lineno)
{
        if (unlikely(b < 0)) {
                _DML_fault(filename, lineno, "negative shift count");
                return 0;
        }
        return b > 63 ? 0 : (uint64)a << b;
}

static inline uint64 DML_shru(uint64 a, uint64 b)
{
        return b > 63 ? 0 : a >> b;
}

static inline int64 DML_shr(int64 a, int64 b, const char *filename, int lineno)
{
        if (unlikely(b < 0)) {
                _DML_fault(filename, lineno, "negative shift count");
                return 0;
        }
        return b > 63 ? (a > 0 ? 0 : -1) : a >> b;
}

static inline uint64 DML_divu(uint64 a, uint64 b,
                              const char *filename, int lineno)
{
        if (unlikely(b == 0)) {
                _DML_fault(filename, lineno, "integer division by zero");
                return 0;
        }
        return a / b;
}

static inline int64 DML_div(int64 a, int64 b, const char *filename, int lineno)
{
        if (unlikely(b == 0)) {
                _DML_fault(filename, lineno, "integer division by zero");
                return 0;
        }
        return a / b;
}

static inline uint64 DML_modu(uint64 a, uint64 b,
                              const char *filename, int lineno)
{
        if (unlikely(b == 0)) {
                _DML_fault(filename, lineno, "integer modulo by zero");
                return 0;
        }
        return a % b;
}

static inline int64 DML_mod(int64 a, int64 b, const char *filename, int lineno)
{
        if (unlikely(b == 0)) {
                _DML_fault(filename, lineno, "integer modulo by zero");
                return 0;
        }
        return a % b;
}

static inline bool
DML_lt_iu(int64 a, uint64 b)
{
        return (uint64)a < b || ((a | b) >> 63);
}

static inline bool
DML_lt_ui(uint64 a, int64 b)
{
        return a < (uint64)b && !((a | b) >> 63);
}

static inline bool
DML_leq_iu(int64 a, uint64 b)
{
        return (uint64)a <= b || ((a | b) >> 63);
}

static inline bool
DML_leq_ui(uint64 a, int64 b)
{
        return a <= (uint64)b && !((a | b) >> 63);
}

// compare signed and unsigned: return true if bits are equal and neither sign
// bit is set
static inline bool
DML_eq(uint64 a, uint64 b)
{
        return ((a ^ b) | ((b | a) >> 63)) == 0;
}


typedef struct {
    uint32 id;
    uint32 encoded_index;
} _identity_t;

typedef struct {
    const char *logname;
    const uint32 *dimsizes;
    uint32 dimensions;
    uint32 id;
} _id_info_t;

typedef struct {
    void *trait;
    _identity_t id;
} _traitref_t;

typedef _identity_t _hookref_t;

// List of vtables of a specific trait in one specific object
typedef struct {
        // trait vtable instance
        void *vtable;
        // total number of elements (product of object's dimsizes)
        uint32 num;
        // The unique object id
        uint32 id;
} _vtable_list_t;

typedef struct {
        // index in global list of _vtable_list_t
        uint32 base_idx;
        // number of _vtable_list_t elements to iterate
        uint32 num;
        // When iterating inside an array, the vtable_list_t instances show
        // number of elements globally. If one or more outer object array index
        // is fixed in the 'in each' expression, then these members show which
        // subset to iterate through from each vtable_list_t: Iteration in a
        // vtable_list_t starts at array_idx * num/array_size, and we iterate
        // through num/array_size elements.
        uint32 array_idx;
        uint32 array_size;
} _each_in_t;

typedef struct {
        uint32 array_idx;
        uint32 array_size;
        union {
                _each_in_t *array;
                struct {
                        uint32 base_idx;
                        uint32 num;
                };
        };
} _each_in_param_t;

UNUSED static uint64 _count_eachin(_each_in_t each_in,
                                   const _vtable_list_t *base) {
        uint64 count = 0;
        for (int i = 0; i < each_in.num; ++i) {
                count += base[each_in.base_idx + i].num / each_in.array_size;
        }
        return count;
}

// Upcast a trait reference expression expr of type 'from' to a corresponding
// trait reference of an ancestor trait, given that the vtable of the new trait
// is found as from.ancestry. E.g.: If a trait y extends z, and x extends y,
// and xyz is a reference to trait x, then UPCAST(xyz, x, y.z) yields a trait
// reference to the z trait.
#define UPCAST(expr, from, ancestry)                            \
    ({_traitref_t __tref = expr;                                \
      __tref.trait = (char *)(__tref.trait)                     \
                     + offsetof(struct _ ## from, ancestry);    \
      __tref;})

// Downcast a trait reference expression expr to a corresponding trait
// reference with vtable type of trait 'to',
// given that expr's vtable type is found as to.ancestry. E.g.: If a trait y
// extends z, and x extends y, and xyz is a reference to trait x upcast to
// trait z, then DOWNCAST(xyz, x, y.z) yields a trait reference to the x trait,
// and UPCAST(DOWNCAST(xyz, x, y.z), x, y.z) == xyz.
// This is similar to the container_of macro in Linux.
#define DOWNCAST(expr, to, ancestry)                            \
        ({_traitref_t __tref = expr;                            \
          __tref.trait = (char *)(__tref.trait)                 \
                         - offsetof(struct _ ## to, ancestry);  \
          __tref;})

#define CALL_TRAIT_METHOD(type, method, dev, traitref, ...)             \
        ({_traitref_t __tref = traitref;                                \
          ((struct _ ## type *) __tref.trait)->method(dev, __tref,      \
                                                      __VA_ARGS__);})
#define CALL_TRAIT_METHOD0(type, method, dev, traitref)                 \
        ({_traitref_t __tref = traitref;                                \
          ((struct _ ## type *) __tref.trait)->method(dev, __tref);})
#define CALL_INDEPENDENT_TRAIT_METHOD(type, method, traitref, ...)       \
        ({_traitref_t __tref = traitref;                                      \
          ((struct _ ## type *) __tref.trait)->method(__tref, __VA_ARGS__);})
#define CALL_INDEPENDENT_TRAIT_METHOD0(type, method, traitref)     \
    ({_traitref_t __tref = traitref;                                    \
      ((struct _ ## type *) __tref.trait)->method(__tref);})

// A parameter is represented in the vtable using a pointer that points to the
// parameter value. A parameter whose value varies across indices is stored as
// an array of all values, indexed by encoded_index. This is marked by setting
// bit 0 of the vtable's pointer to 1. A parameter that stays constant across
// indices is represented as a single value, this is marked by setting bit 0 of
// the pointer to 0. Parameter values are always stored with an alignment of at
// least 2.
#define VTABLE_PARAM(traitref, vtable_type, member)                     \
        ({_traitref_t __tref = traitref;                                     \
          uintptr_t __member                                                 \
              = (uintptr_t)((vtable_type *)__tref.trait)->member;            \
          ((typeof(((vtable_type*)NULL)->member))(__member & ~1))[           \
             (__member & 1) ? __tref.id.encoded_index : 0]; })

// Similar to VTABLE_PARAM: a very common parameter is a sequence(T) with the
// value (each T in this). This is by far the most common param whose value
// depends on index, and therefore warrants a special case.
// Unlike ordinary params, which are represented as pointers to values,
// sequence params are represented directly as _each_in_t values.
// Three cases:
// * The general case: `j < 3 ? each T in foo[5-i] : each T in bar[17+i]`
//   here the _each_in_t value is interpreted as a tagged union, indicated by
//   an out-of-band `starti` value that causes `base` to be re-interpreted as
//   an array of each_in_t, similar to odd-addressed pointers in VTABLE_PARAM.
// * The most common case: `each T in this`, where the value depends on the
//   indices of `this`, in that .array_idx is set to encoded_index. This
//   is represented by an out-of-band value in `array_idx` in the vtable.
// * Other values of `array_idx` represent a literal sequence that doesn't
//   depend on encoded_index
static UNUSED _each_in_t
_vtable_sequence_param(_traitref_t traitref, size_t vtable_member_offset)
{
        _each_in_param_t p = *(_each_in_param_t *)((char *)traitref.trait
                                                   + vtable_member_offset);
        if (unlikely(p.array_size == 0)) {
                return p.array[traitref.id.encoded_index];
        } else {
                return (_each_in_t){
                        .base_idx = p.base_idx,
                        .num = p.num,
                        .array_idx = p.array_idx == 0xffffffffu
                        ? traitref.id.encoded_index : p.array_idx,
                        .array_size = p.array_size};
        }
}

#define VTABLE_SESSION(dev, traitref, vtable_type, member, var_type)    \
      ({_traitref_t __tref = traitref;                                  \
        (var_type)((uintptr_t)dev + ((vtable_type *)__tref.trait)->member) \
           + __tref.id.encoded_index; })

#define VTABLE_HOOK(traitref, vtable_type, member, coeff, offset)           \
    ({_traitref_t __tref = traitref;                                        \
        (_hookref_t){ .id = ((vtable_type *)__tref.trait)->member,          \
                      .encoded_index = __tref.id.encoded_index * (coeff)    \
                                       + (offset)}; })

#define _raw_load_uint8_be_t   UNALIGNED_LOAD_BE8
#define _raw_load_uint16_be_t  UNALIGNED_LOAD_BE16
#define _raw_load_uint32_be_t  UNALIGNED_LOAD_BE32
#define _raw_load_uint64_be_t  UNALIGNED_LOAD_BE64
#define _raw_load_uint8_le_t   UNALIGNED_LOAD_LE8
#define _raw_load_uint16_le_t  UNALIGNED_LOAD_LE16
#define _raw_load_uint32_le_t  UNALIGNED_LOAD_LE32
#define _raw_load_uint64_le_t  UNALIGNED_LOAD_LE64
#define _raw_store_uint8_be_t  UNALIGNED_STORE_BE8
#define _raw_store_uint16_be_t UNALIGNED_STORE_BE16
#define _raw_store_uint32_be_t UNALIGNED_STORE_BE32
#define _raw_store_uint64_be_t UNALIGNED_STORE_BE64
#define _raw_store_uint8_le_t  UNALIGNED_STORE_LE8
#define _raw_store_uint16_le_t UNALIGNED_STORE_LE16
#define _raw_store_uint32_le_t UNALIGNED_STORE_LE32
#define _raw_store_uint64_le_t UNALIGNED_STORE_LE64

static inline int8
_raw_load_int8_be_t(const void *addr)
{
        return (int8)_raw_load_uint8_be_t(addr);
}

static inline int16
_raw_load_int16_be_t(const void *addr)
{
        return (int16)_raw_load_uint16_be_t(addr);
}

static inline int32
_raw_load_int32_be_t(const void *addr)
{
        return (int32)_raw_load_uint32_be_t(addr);
}

static inline int64
_raw_load_int64_be_t(const void *addr)
{
        return (int64)_raw_load_uint64_be_t(addr);
}

static inline int8
_raw_load_int8_le_t(const void *addr)
{
        return (int8)_raw_load_uint8_le_t(addr);
}

static inline int16
_raw_load_int16_le_t(const void *addr)
{
        return (int16)_raw_load_uint16_le_t(addr);
}

static inline int32
_raw_load_int32_le_t(const void *addr)
{
        return (int32)_raw_load_uint32_le_t(addr);
}

static inline int64
_raw_load_int64_le_t(const void *addr)
{
        return (int64)_raw_load_uint64_le_t(addr);
}

static inline uint32
_raw_load_uint24_be_t(const void *addr)
{
        return _raw_load_uint8_be_t(addr) << 16 |
                _raw_load_uint16_be_t((char *)addr + 1);
}

static inline int32
_raw_load_int24_be_t(const void *addr)
{
        return ((int32)_raw_load_uint24_be_t(addr) << 8) >> 8;
}

static inline void
_raw_store_uint24_be_t(void *addr, uint32 v)
{
        _raw_store_uint8_be_t(addr, v >> 16);
        _raw_store_uint16_be_t((char *)addr + 1, v & 0xffff);
}

static inline uint64
_raw_load_uint40_be_t(const void *addr)
{
        return (uint64)_raw_load_uint8_be_t(addr) << 32
               | _raw_load_uint32_be_t((char *)addr + 1);
}

static inline int64
_raw_load_int40_be_t(const void *addr)
{
        return ((int64)_raw_load_uint40_be_t(addr) << 24) >> 24;
}

static inline void
_raw_store_uint40_be_t(void *addr, uint64 v)
{
        _raw_store_uint8_be_t(addr, v >> 32);
        _raw_store_uint32_be_t((char *)addr + 1, v & 0xffffffff);
}

static inline uint64
_raw_load_uint48_be_t(const void *addr)
{
        return (uint64)_raw_load_uint16_be_t(addr) << 32
               | _raw_load_uint32_be_t((char *)addr + 2);
}

static inline int64
_raw_load_int48_be_t(const void *addr)
{ return ((int64)_raw_load_uint48_be_t(addr) << 16) >> 16; }

static inline void
_raw_store_uint48_be_t(void *addr, uint64 v)
{
        _raw_store_uint16_be_t(addr, v >> 32);
        _raw_store_uint32_be_t((char *)addr + 2, v & 0xffffffff);
}

static inline uint64
_raw_load_uint56_be_t(const void *addr)
{
        return (uint64)_raw_load_uint24_be_t(addr) << 32
               | _raw_load_uint32_be_t((char *)addr + 3);
}

static inline int64
_raw_load_int56_be_t(const void *addr)
{ return ((int64)_raw_load_uint56_be_t(addr) << 8) >> 8; }

static inline void
_raw_store_uint56_be_t(void *addr, uint64 v)
{
        _raw_store_uint24_be_t(addr, v >> 32);
        _raw_store_uint32_be_t((char *)addr + 3, v & 0xffffffff);
}

static inline uint32
_raw_load_uint24_le_t(const void *addr)
{
        return _raw_load_uint8_le_t((char *)addr + 2) << 16 |
                _raw_load_uint16_le_t(addr);
}

static inline int32
_raw_load_int24_le_t(const void *addr)
{
        return ((int32)_raw_load_uint24_le_t(addr) << 8) >> 8;
}

static inline void
_raw_store_uint24_le_t(void *addr, uint32 v)
{
        _raw_store_uint8_le_t((char *)addr + 2, v >> 16);
        _raw_store_uint16_le_t(addr, v & 0xffff);
}

static inline uint64
_raw_load_uint40_le_t(const void *addr)
{
        return (uint64)_raw_load_uint8_le_t((char *)addr + 4) << 32
               | _raw_load_uint32_le_t(addr);
}

static inline int64
_raw_load_int40_le_t(const void *addr)
{
        return ((int64)_raw_load_uint40_le_t(addr) << 24) >> 24;
}

static inline void
_raw_store_uint40_le_t(void *addr, uint64 v)
{
        _raw_store_uint8_le_t((char *)addr + 4, v >> 32);
        _raw_store_uint32_le_t(addr, v & 0xffffffff);
}

static inline uint64
_raw_load_uint48_le_t(const void *addr)
{
        return (uint64)_raw_load_uint16_le_t((char *)addr + 4) << 32
               | _raw_load_uint32_le_t(addr);
}

static inline int64
_raw_load_int48_le_t(const void *addr)
{
        return ((int64)_raw_load_uint48_le_t(addr) << 16) >> 16;
}

static inline void
_raw_store_uint48_le_t(void *addr, uint64 v)
{
        _raw_store_uint16_le_t((char *)addr + 4, v >> 32);
        _raw_store_uint32_le_t(addr, v & 0xffffffff);
}

static inline uint64
_raw_load_uint56_le_t(const void *addr)
{
        return (uint64)_raw_load_uint24_le_t((char *)addr + 4) << 32
               | _raw_load_uint32_le_t(addr);
}

static inline int64
_raw_load_int56_le_t(const void *addr)
{
        return ((int64)_raw_load_uint56_le_t(addr) << 8) >> 8;
}

static inline void
_raw_store_uint56_le_t(void *addr, uint64 v)
{
        _raw_store_uint24_le_t((char *)addr + 4, v >> 32);
        _raw_store_uint32_le_t(addr, v & 0xffffffff);
}

// Define signed aliases for raw store, used in macros later
#define _raw_store_int8_be_t _raw_store_uint8_be_t
#define _raw_store_int16_be_t _raw_store_uint16_be_t
#define _raw_store_int24_be_t _raw_store_uint24_be_t
#define _raw_store_int32_be_t _raw_store_uint32_be_t
#define _raw_store_int40_be_t _raw_store_uint40_be_t
#define _raw_store_int48_be_t _raw_store_uint48_be_t
#define _raw_store_int56_be_t _raw_store_uint56_be_t
#define _raw_store_int64_be_t _raw_store_uint64_be_t
#define _raw_store_int8_le_t _raw_store_uint8_le_t
#define _raw_store_int16_le_t _raw_store_uint16_le_t
#define _raw_store_int24_le_t _raw_store_uint24_le_t
#define _raw_store_int32_le_t _raw_store_uint32_le_t
#define _raw_store_int40_le_t _raw_store_uint40_le_t
#define _raw_store_int48_le_t _raw_store_uint48_le_t
#define _raw_store_int56_le_t _raw_store_uint56_le_t
#define _raw_store_int64_le_t _raw_store_uint64_le_t

// macro definitions for endian types
#define FOR_ALL_BITSIZES(x, s, ed) \
        x(8, s, ed) x(16, s, ed)   \
        x(24, s, ed) x(32, s, ed)  \
        x(40, s, ed) x(48, s, ed)  \
        x(56, s, ed) x(64, s, ed)
#define FOR_ENDIAN_VARIANTS(x)                                 \
        FOR_ALL_BITSIZES(x, u, be) FOR_ALL_BITSIZES(x, u, le)  \
        FOR_ALL_BITSIZES(x, , be) FOR_ALL_BITSIZES(x, , le)

// declare endian types
#define DECLARE_ENDIAN_TYPE(size, sign, endian)                     \
        typedef struct { uint8 bytes[size/8]; }                 \
                sign ## int ## size ## _ ## endian ## _ ## t ;

FOR_ENDIAN_VARIANTS(DECLARE_ENDIAN_TYPE);

#undef DECLARE_ENDIAN_TYPE
#undef FOR_ALL_BITSIZES
#undef FOR_ENDIAN_VARIANTS

#define FOR_ALL_BITSIZES(x, sign, endian)               \
        x(int ## 64, sign ## int ## 8 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 16 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 24 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 32 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 40 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 48 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 56 ## _ ## endian ## _ ## t)

#define FOR_ENDIAN_VARIANTS(x)                                    \
        FOR_ALL_BITSIZES(x, , be) FOR_ALL_BITSIZES(x, , le)       \
        FOR_ALL_BITSIZES(x, u, be) FOR_ALL_BITSIZES(x, u, le)     \
        x(uint ## 64, uint ## 64_le_t) x(uint ## 64, uint ## 64_be_t) \
        x(int ## 64, int ## 64_le_t) x(int ## 64, int ## 64_be_t)

#define DEFINE_ENDIAN_LOAD(inttype, endiantype)             \
        static inline inttype                           \
        dml_load_ ## endiantype (const endiantype eint) \
        {                                               \
            return _raw_load_ ## endiantype             \
                ((void *)&(eint.bytes));                \
        };

FOR_ENDIAN_VARIANTS(DEFINE_ENDIAN_LOAD)

#undef DEFINE_ENDIAN_LOAD

#define DEFINE_ENDIAN_STORE(inttype, endiantype)                             \
        static inline endiantype                                         \
        dml_store_ ## endiantype ( inttype val )                         \
        {                                                                \
                endiantype toret;                                        \
                _raw_store_ ## endiantype ((void *)&(toret.bytes), val); \
                return toret;                                            \
        }

FOR_ENDIAN_VARIANTS(DEFINE_ENDIAN_STORE);
#undef DEFINE_ENDIAN_LOAD

// x = y is translated to dml_copy_T(&x, y) for endian types
#define DEFINE_ENDIAN_COPY(inttype, endiantype) \
        static inline endiantype \
        dml_copy_ ## endiantype ( endiantype *dest, endiantype val ) \
        { memcpy(dest, &val, sizeof(endiantype)); return val; }
FOR_ENDIAN_VARIANTS(DEFINE_ENDIAN_COPY);
#undef DEFINE_ENDIAN_COPY

#define DEFINE_PRECHANGE(inttype, endiantype)                           \
        static inline inttype                                           \
        dml_prechange_ ## endiantype (endiantype *addr, int change,     \
                                      bool post) {                      \
                uint64 orig = dml_load_ ## endiantype (*addr);          \
                *addr = dml_store_ ## endiantype(orig + change);        \
                return post ? orig : dml_load_ ## endiantype (*addr);   \
        }

FOR_ENDIAN_VARIANTS(DEFINE_PRECHANGE);
#undef DEFINE_PRECHANGE

#undef FOR_ALL_BITSIZES
#undef FOR_ENDIAN_VARIANTS


#define DML_THREAD_AWARE_IFACE_CALL(target_obj, call_expr) (({                \
        domain_lock_t *__lock;                                                 \
        SIM_ACQUIRE_TARGET(target_obj, &__lock);                              \
        __auto_type __iface_ret = call_expr;                                  \
        SIM_RELEASE_TARGET(target_obj, &__lock);                              \
        __iface_ret;                                                          \
    }))

#define DML_THREAD_AWARE_IFACE_CALL_VOID(target_obj, call_expr) (({           \
        domain_lock_t *__lock;                                                 \
        SIM_ACQUIRE_TARGET(target_obj, &__lock);                              \
        call_expr;                                                            \
        SIM_RELEASE_TARGET(target_obj, &__lock);                              \
    }))

UNUSED static attr_value_t
_serialize_identity(const _id_info_t *id_info_array, const _identity_t id) {
    if (unlikely(id.id) == 0) {
        // Zero-initialized _identity_t's are invalid.
        // This must be handled to avoid creating unrestorable checkpoints.
        // A zero-initialized _identity_t is signaled through an empty
        // logname.
        ASSERT(id.encoded_index == 0);
        return SIM_make_attr_list(2, SIM_make_attr_string(""),
                                  SIM_make_attr_list(0));
    }
    _id_info_t info = id_info_array[id.id - 1];
    attr_value_t inner = SIM_alloc_attr_list(info.dimensions);
    uint32 index = id.encoded_index;
    for (int i = info.dimensions - 1; i >= 0; --i) {
        SIM_attr_list_set_item(&inner, i,
                               SIM_make_attr_uint64(index % info.dimsizes[i]));
        index /= info.dimsizes[i];
    }
    return SIM_make_attr_list(2, SIM_make_attr_string(info.logname), inner);
}

UNUSED static set_error_t
_deserialize_identity(ht_str_table_t *id_info_ht, attr_value_t val,
                      _identity_t *out_id) {
    if (unlikely(!SIM_attr_is_list(val) || SIM_attr_list_size(val) != 2)) {
        goto bad_repr;
    }

    attr_value_t logname_attr = SIM_attr_list_item(val, 0);
    attr_value_t indices_attr = SIM_attr_list_item(val, 1);

    if (unlikely(!SIM_attr_is_string(logname_attr)
                 || !SIM_attr_is_list(indices_attr))) {
        goto bad_repr;
    }

    const char *logname = SIM_attr_string(logname_attr);

    // Serialized zero-initialized _identity_t
    if (unlikely(logname[0] == '\0')) {
        *out_id = (_identity_t) { 0 };
        return Sim_Set_Ok;
    }

    const _id_info_t *info = ht_lookup_str(id_info_ht, logname);

    if (unlikely(!info)) {
        SIM_c_attribute_error("Failed to look up node '%s' when "
                              "deserializing _identity_t", logname);
        return Sim_Set_Illegal_Value;
    }
    if (unlikely(SIM_attr_list_size(indices_attr) != info->dimensions)) {
        SIM_c_attribute_error(
            "Invalid number of indices for when attempting "
            "to deserialize _identity_t for node %s. "
            "Expected %u indices, got %u.",
            logname, info->dimensions, SIM_attr_list_size(indices_attr));
        return Sim_Set_Illegal_Value;
    }

    uint32 flat_index = 0;
    attr_value_t *indices = SIM_attr_list(indices_attr);
    for (uint32 i = 0; i < info->dimensions; ++i) {
        if (unlikely(!SIM_attr_is_integer(indices[i]))) {
            goto bad_repr;
        }
        uint32 index = SIM_attr_integer(indices[i]);
        if (unlikely(index >= info->dimsizes[i])) {
            SIM_c_attribute_error(
                "Encountered invalid index when attempting to deserialize "
                "_identity_t for node %s. The size of dimension %u is "
                "%u, but deserialized index for that dimension is %u.",
                logname, i, info->dimsizes[i], index);
            return Sim_Set_Illegal_Value;
        }

        flat_index = flat_index * info->dimsizes[i] + index;
    }

    *out_id = (_identity_t) { .id = info->id, .encoded_index = flat_index };
    return Sim_Set_Ok;

    bad_repr:
    SIM_attribute_error("invalid serialized representation of _identity_t");
    return Sim_Set_Illegal_Type;
}

UNUSED static set_error_t
_deserialize_trait_reference(ht_str_table_t *id_info_ht,
                             ht_int_table_t *vtable_ht,
                             const char *template_name,
                             attr_value_t val,
                             _traitref_t *out) {
    _identity_t id;
    set_error_t error = _deserialize_identity(id_info_ht, val, &id);
    if (unlikely(error != Sim_Set_Ok)) {
        return error;
    }
    if (unlikely(id.id == 0)) {
        // Deserialized _identity_t's id being 0 indicates the serialized
        // trait reference was zero-initialized.
        *out = (_traitref_t) { 0 };
        return Sim_Set_Ok;
    }
    void *trait = NULL;
    if (vtable_ht) {
        trait = ht_lookup_int(vtable_ht, id.id);
        if (unlikely(!trait)) {
            const char *name = SIM_attr_string(SIM_attr_list_item(val, 0));
            SIM_c_attribute_error("Failed to deserialize value of template type: "
                                  "object node '%s' doesn't instantiate %s",
                                  name, template_name);
            return Sim_Set_Illegal_Value;
        }
    }
    *out = (_traitref_t) { trait, id };
    return Sim_Set_Ok;
}

UNUSED static set_error_t
_deserialize_object_trait_reference(ht_str_table_t *id_info_ht,
                                    void *const *object_vtables,
                                    attr_value_t val,
                                    _traitref_t *out) {
    _identity_t id;
    set_error_t error = _deserialize_identity(id_info_ht, val, &id);
    if (unlikely(error != Sim_Set_Ok)) {
        return error;
    }
    if (unlikely(id.id == 0)) {
        // Deserialized _identity_t's id being 0 indicates the serialized
        // trait reference was zero-initialized.
        *out = (_traitref_t) { 0 };
        return Sim_Set_Ok;
    }
    *out = (_traitref_t) { object_vtables[id.id - 1], id };
    return Sim_Set_Ok;
}

UNUSED static inline bool
_identity_eq(const _identity_t a, const _identity_t b) {
    if (unlikely(a.id == 0 || b.id == 0)) {
        _signal_critical_error(
            "DML object identity equality check where one or both operands "
            "are not explicitly initialized. This is considered undefined "
            "behavior.");
        return false;
    }
    return a.id == b.id && a.encoded_index == b.encoded_index;
}

UNUSED static inline bool
_identity_eq_at_site(const _identity_t a, const _identity_t b,
                     const char *filename, int lineno) {
    if (unlikely(a.id == 0 || b.id == 0)) {
        _DML_fault(filename, lineno,
                   "object identity equality check where one or both operands "
                   "are not explicitly initialized. This is considered "
                   "undefined behavior.");
        return false;
    }
    return a.id == b.id && a.encoded_index == b.encoded_index;
}

typedef set_error_t (*_deserializer_t)(attr_value_t val, void *dest);
typedef attr_value_t (*_serializer_t)(const void *addr);

typedef struct {
    uint32      *indices;
    void        *args;
    _identity_t *domains;
    uint64      no_domains;
} _simple_event_data_t;

UNUSED static int
_simple_event_predicate(lang_void *_data, lang_void *match_data) {
    ASSERT(match_data);

    if (!_data) {
        return 0;
    }

    _simple_event_data_t *data = (_simple_event_data_t *)_data;
    _identity_t *domains = data->domains;
    uint64 no_domains = data->no_domains;

    _identity_t match_id = *(_identity_t *)match_data;
    for (uint64 i = 0; i < no_domains; ++i) {
        if (_identity_eq(match_id, domains[i])) {
            return 1;
        }
    }
    return 0;
}

/*
 * The modern serialized representation of after event data is a
 * pseudo-dictionary, containing entries for method indices, arguments, and
 * domains (associated objects for cancellation):
 * [["indices", [index0, index1, ...]],
 *  ["arguments", [arg0, arg1, ...]],
 *  ["domains", [domain0, domain1, ...]]
 * ]
 * The entries may appear in any order, and any entry may be omitted if not
 * applicable, (for example, a method call has no indices/arguments or
 * associated objects). If all entries may be omitted, then nil may be used as
 * the serialized representation.
 *
 * Before the introduction of domains (early 2022), after event data was
 * represented as follows:
 * [[index0, index1, ...], [arg0, arg1, ...]]
 * and when either list is empty, the other is represented directly; if both
 * are empty, nil is used.
 * This is called the legacy representation of after event data, and is
 * supported for backwards checkpoint compatibility.
 */
typedef enum {
    _Simple_Event_Data_Format_Invalid,
    _Simple_Event_Data_Format_Pseudodict,
    _Simple_Event_Data_Format_Legacy
} _simple_event_data_format_t;

UNUSED static _simple_event_data_format_t
_simple_event_data_representation(
    attr_value_t val, bool has_indices, bool has_params) {
    ASSERT(SIM_attr_is_list(val) && SIM_attr_list_size(val) > 0);
    if (SIM_attr_list_size(val) == 2 && has_indices && has_params) {
        // Either the pseudodict format, or the [indices, params] format
        // Determine by inspecting the first element:
        // [integer, ...] -> Legacy representation
        // [string, _] -> Pseudodict representation
        attr_value_t item = SIM_attr_list_item(val, 0);
        if (unlikely(!SIM_attr_is_list(item)
                     || SIM_attr_list_size(item) == 0)) {
            return _Simple_Event_Data_Format_Invalid;
        }
        attr_value_t inner_item = SIM_attr_list_item(item, 0);
        if (SIM_attr_is_integer(inner_item)) {
            return _Simple_Event_Data_Format_Legacy;
        } else if (SIM_attr_list_size(item) == 2
                   && SIM_attr_is_string(inner_item)) {
            return _Simple_Event_Data_Format_Pseudodict;
        }
    } else {
        // Either the pseudodict format, or [index0, ...] or [param0, ...]
        // Determine by inspecting the first element:
        // [string, _] -> Pseudodict representation
        // integer and has_indices and !has_params -> Legacy representation
        // anything and has_params and !has_indices -> Legacy representation
        // Otherwise invalid
        attr_value_t item = SIM_attr_list_item(val, 0);
        if (SIM_attr_is_list(item) && SIM_attr_list_size(item) == 2
            && SIM_attr_is_string(SIM_attr_list_item(item, 0))) {
            return _Simple_Event_Data_Format_Pseudodict;
        }  else if ((has_indices && !has_params && SIM_attr_is_integer(item))
                    || (has_params && !has_indices)) {
            return _Simple_Event_Data_Format_Legacy;
        }
    }
    return _Simple_Event_Data_Format_Invalid;
}

UNUSED static void
_free_simple_event_data(_simple_event_data_t data) {
    MM_FREE(data.indices);
    MM_FREE(data.args);
    MM_FREE(data.domains);
}

UNUSED static void
_destroy_simple_event_data(conf_object_t *_obj, lang_void *data) {
    if (data) {
        _free_simple_event_data(*(_simple_event_data_t *)data);
        MM_FREE(data);
    }
}

UNUSED static attr_value_t
_serialize_simple_event_data(
    uint32 dimensions, _serializer_t args_serializer,
    const _id_info_t *id_info_array, _simple_event_data_t *data) {

    if (!data) {
        return SIM_make_attr_nil();
    }

    uint32 entry_index = 0;
    attr_value_t entries_buf[3];

    if (dimensions) {
        attr_value_t indices_attr = SIM_alloc_attr_list(dimensions);
        attr_value_t *index_list = SIM_attr_list(indices_attr);
        for (uint32 i = 0; i < dimensions; ++i) {
            index_list[i] = SIM_make_attr_uint64(data->indices[i]);
        }
        entries_buf[entry_index++] = SIM_make_attr_list(
            2, SIM_make_attr_string("indices"), indices_attr);
    }

    if (args_serializer) {
        attr_value_t args_attr = args_serializer(data->args);
        entries_buf[entry_index++] = SIM_make_attr_list(
            2, SIM_make_attr_string("arguments"), args_attr);

    }

    if (data->no_domains) {
        attr_value_t domains_attr = SIM_alloc_attr_list(data->no_domains);
        attr_value_t *domain_list = SIM_attr_list(domains_attr);
        for (uint32 i = 0; i < data->no_domains; ++i) {
            domain_list[i] = _serialize_identity(id_info_array,
                                                 data->domains[i]);
        }
        entries_buf[entry_index++] = SIM_make_attr_list(
            2, SIM_make_attr_string("domains"), domains_attr);
    }

    attr_value_t pseudodict = SIM_alloc_attr_list(entry_index);
    attr_value_t *entry_list = SIM_attr_list(pseudodict);
    for (uint32 i = 0; i < entry_index; ++i) {
        entry_list[i] = entries_buf[i];
    }
    return pseudodict;
}

UNUSED static set_error_t
_simple_event_data_deconstruct_pseudodict(
    attr_value_t pseudodict, attr_value_t **indices_attr,
    attr_value_t **arguments_attr, attr_value_t **domains_attr) {

    attr_value_t *entries = SIM_attr_list(pseudodict);
    uint32 no_entries = SIM_attr_list_size(pseudodict);
    for (uint32 i = 0; i < no_entries; ++i) {
        if (!SIM_attr_is_list(entries[i])
            || SIM_attr_list_size(entries[i]) != 2
            || !SIM_attr_is_string(SIM_attr_list_item(entries[i], 0))) {
            SIM_attribute_error(
                "Invalid serialized representation of after event data: "
                "expected list of [key, val] entries, where 'key's are "
                "strings");
            return Sim_Set_Illegal_Type;
        }
        const char *key = SIM_attr_string(SIM_attr_list_item(entries[i], 0));
        bool duplicate = false;
        if (strcmp(key, "indices") == 0) {
            duplicate = *indices_attr != NULL;
            if (!duplicate) {
                *indices_attr = &SIM_attr_list(entries[i])[1];
            }
        } else if (strcmp(key, "arguments") == 0) {
            duplicate = *arguments_attr != NULL;
            if (!duplicate) {
                *arguments_attr = &SIM_attr_list(entries[i])[1];
            }
        } else if (strcmp(key, "domains") == 0) {
            duplicate = *domains_attr != NULL;
            if (!duplicate) {
                *domains_attr = &SIM_attr_list(entries[i])[1];
            }
        } else {
            SIM_c_attribute_error(
                "Invalid serialized value of after event data: list has entry "
                "with unknown key '%s'", key);
            return Sim_Set_Illegal_Value;
        }
        if (duplicate) {
            SIM_c_attribute_error(
                "Invalid serialized value of after event data: list has "
                "duplicate entry for key '%s'", key);
            return Sim_Set_Illegal_Value;
        }
    }
    return Sim_Set_Ok;
}


UNUSED static set_error_t
_deserialize_simple_event_indices(
    const uint32 *dimsizes, uint32 dimensions, attr_value_t *indices_attr,
    uint32 **out_indices) {

    if (indices_attr) {
        if (!SIM_attr_is_list(*indices_attr)) {
            SIM_attribute_error(
                "Invalid serialized value of after event data: provided "
                "indices is not a list");
            return Sim_Set_Illegal_Value;
        }
        if (dimensions != SIM_attr_list_size(*indices_attr)) {
            SIM_c_attribute_error(
                "Invalid serialized value of after event data: expected %u "
                "indices, got %u", dimensions,
                SIM_attr_list_size(*indices_attr));
            return Sim_Set_Illegal_Value;
        }
        if (dimensions == 0) {
            *out_indices = NULL;
            return Sim_Set_Ok;
        }

        set_error_t error = Sim_Set_Ok;
        uint32 *temp_out_indices = MM_MALLOC(dimensions, uint32);
        attr_value_t *index_list = SIM_attr_list(*indices_attr);
        for (uint32 i = 0; i < dimensions; ++i) {
            if (!SIM_attr_is_integer(index_list[i])) {
                SIM_attribute_error(
                    "Invalid serialized representation of after event data: "
                    "received indices with non-integer element");
                error = Sim_Set_Illegal_Type;
                goto error;
            }
            uint32 index = SIM_attr_integer(index_list[i]);
            if (index >= dimsizes[i]) {
                SIM_c_attribute_error(
                    "Invalid serialized value of after event data: "
                    "encountered invalid index. The size of dimension %u is "
                    "%u, but deserialized index for that dimension is %u.",
                    i, dimsizes[i], index);
                error = Sim_Set_Illegal_Value;
                goto error;
            }
            temp_out_indices[i] = index;
        }
        *out_indices = temp_out_indices;
        return Sim_Set_Ok;

      error:
        MM_FREE(temp_out_indices);
        return error;
    } else if (dimensions) {
        SIM_attribute_error(
            "Invalid serialized value of after event data: missing entry "
            "for key 'indices'");
        return Sim_Set_Illegal_Value;
    } else {
        *out_indices = NULL;
        return Sim_Set_Ok;
    }
}

UNUSED static set_error_t
_deserialize_simple_event_arguments(
    size_t args_size, _deserializer_t args_deserializer,
    attr_value_t *arguments_attr, void **out_args) {

    if (arguments_attr) {
        if (!args_deserializer) {
            if (!SIM_attr_is_list(*arguments_attr)
                || SIM_attr_list_size(*arguments_attr) != 0) {
                SIM_attribute_error(
                    "Invalid serialized value of after event data: expected "
                    "empty list as serialized value for arguments");
                return Sim_Set_Illegal_Value;
            }
            *out_args = NULL;
            return Sim_Set_Ok;
        } else {
            void *temp_out_args =
                args_size ? MM_MALLOC(args_size, uint8) : NULL;
            set_error_t error = args_deserializer(*arguments_attr,
                                                  temp_out_args);
            if (error != Sim_Set_Ok) {
                MM_FREE(temp_out_args);
                return error;
            }
            *out_args = temp_out_args;
            return Sim_Set_Ok;
        }
    } else if (args_deserializer) {
        SIM_attribute_error(
            "Invalid serialized value of after event data: missing entry "
            "for key 'arguments'");
        return Sim_Set_Illegal_Value;
    } else {
        *out_args = NULL;
        return Sim_Set_Ok;
    }
}

UNUSED static set_error_t
_deserialize_simple_event_domains(
    ht_str_table_t *id_info_ht, attr_value_t *domains_attr,
    _identity_t **out_domains, uint64 *out_no_domains) {

    if (domains_attr) {
        if (!SIM_attr_is_list(*domains_attr)) {
            SIM_attribute_error(
                "Invalid serialized representation of after event data: "
                "specified domains value is not a list.");
            return Sim_Set_Illegal_Type;
        }
        uint32 temp_out_no_domains = SIM_attr_list_size(*domains_attr);
        if (temp_out_no_domains == 0) {
            *out_no_domains = 0;
            *out_domains = NULL;
            return Sim_Set_Ok;
        }
        _identity_t *temp_out_domains = MM_MALLOC(temp_out_no_domains,
                                                  _identity_t);

        attr_value_t *ids = SIM_attr_list(*domains_attr);
        for (uint64 i = 0; i < temp_out_no_domains; ++i) {
            set_error_t error = _deserialize_identity(id_info_ht, ids[i],
                                                      &temp_out_domains[i]);
            if (error != Sim_Set_Ok) {
                MM_FREE(temp_out_domains);
                return error;
            }
        }
        *out_no_domains = temp_out_no_domains;
        *out_domains = temp_out_domains;
    } else {
        *out_no_domains = 0;
        *out_domains = NULL;
    }
    return Sim_Set_Ok;
}

UNUSED static set_error_t
_deserialize_simple_event_data(
    const uint32 *dimsizes, uint32 dimensions, size_t args_size,
    _deserializer_t args_deserializer, ht_str_table_t *id_info_ht,
    attr_value_t val, _simple_event_data_t **out) {

    *out = NULL;
    set_error_t error = Sim_Set_Ok;
    if (SIM_attr_is_nil(val)) {
        if (likely(dimensions == 0 && !args_deserializer)) {
            return Sim_Set_Ok;
        } else {
            SIM_attribute_error(
                "Invalid serialized representation of after event data: "
                "expected arguments and/or indices, instead got nil");
            return Sim_Set_Illegal_Type;
        }
    } else if (unlikely(!SIM_attr_is_list(val))) {
        SIM_attribute_error("Invalid serialized representation of after "
                            "event data: expected list");
        return Sim_Set_Illegal_Type;
    } else if (SIM_attr_list_size(val) == 0) {
        if (likely(dimensions == 0 && !args_deserializer)) {
            return Sim_Set_Ok;
        } else {
            SIM_attribute_error(
                "Invalid serialized representation of after event data: "
                "expected arguments and/or indices, instead got empty list");
            return Sim_Set_Illegal_Type;
        }
    }

    attr_value_t *indices_attr = NULL;
    attr_value_t *arguments_attr = NULL;
    attr_value_t *domains_attr = NULL;

    switch (_simple_event_data_representation(val, dimensions,
                                              args_deserializer)) {
    case _Simple_Event_Data_Format_Invalid:
        SIM_attribute_error(
            "Invalid serialized representation of after event data: "
            "can't recognize format");
        return Sim_Set_Illegal_Type;
    case _Simple_Event_Data_Format_Legacy:
        if (dimensions && args_deserializer) {
            attr_value_t *vals = SIM_attr_list(val);
            indices_attr = &vals[0];
            arguments_attr = &vals[1];
        } else if (dimensions) {
            indices_attr = &val;
        } else if (args_deserializer) {
            arguments_attr = &val;
        }
        break;
    case _Simple_Event_Data_Format_Pseudodict:
        error = _simple_event_data_deconstruct_pseudodict(
            val, &indices_attr, &arguments_attr, &domains_attr);
        if (error != Sim_Set_Ok) return error;
        break;
    }

    _simple_event_data_t temp_out = { NULL, NULL, NULL, 0 };

    error = _deserialize_simple_event_indices(
        dimsizes, dimensions, indices_attr, &temp_out.indices);
    if (error != Sim_Set_Ok) goto error;

    error = _deserialize_simple_event_arguments(
        args_size, args_deserializer, arguments_attr, &temp_out.args);
    if (error != Sim_Set_Ok) goto error;

    error = _deserialize_simple_event_domains(
        id_info_ht, domains_attr, &temp_out.domains, &temp_out.no_domains);
    if (error != Sim_Set_Ok) goto error;

    _simple_event_data_t *out_ptr = MM_MALLOC(1, _simple_event_data_t);
    *out_ptr = temp_out;
    *out = out_ptr;
    return Sim_Set_Ok;

  error:
    _free_simple_event_data(temp_out);
    return error;
}

UNUSED static _simple_event_data_t
_DML_create_simple_event_data(
    const uint32 *indices, uint32 dimensions, const void *args,
    size_t args_size, const _identity_t *domains, uint32 no_domains) {
    _simple_event_data_t data = { 0 };
    if (indices) {
        data.indices = MM_MALLOC(dimensions, uint32);
        for (uint32 i = 0; i < dimensions; ++i) {
            data.indices[i] = indices[i];
        }
    }
    if (args_size) {
        ASSERT(args);
        data.args = MM_MALLOC(args_size, uint8);
        memcpy(data.args, args, args_size);
    }
    if (no_domains) {
        data.no_domains = no_domains;
        data.domains = MM_MALLOC(no_domains, _identity_t);
        for (uint32 i = 0; i < no_domains; ++i) {
            data.domains[i] = domains[i];
        }
    }
    return data;
}
typedef struct {
    void (*callback)(conf_object_t *dev, const uint32 *indices,
                     const void *args);
    _simple_event_data_t data;
} _dml_immediate_after_queue_elem_t;

typedef QUEUE(_dml_immediate_after_queue_elem_t) _dml_immediate_after_queue_t;

typedef struct {
    // Invariant: nonempty queue implies posted (but not vice versa)
    _dml_immediate_after_queue_t queue;
    bool posted;
    // Invariant: deleted implies posted and empty queue
    bool deleted;
} _dml_immediate_after_state_t;

// Execute all pending immediate afters without relying on VT_stacked_post
// Only safe to call in global context, where SIM_transaction_wait can't happen
UNUSED static void
_DML_execute_immediate_afters_now(conf_object_t *dev,
                                  _dml_immediate_after_state_t *state) {
    while (!QEMPTY(state->queue)) {
        _dml_immediate_after_queue_elem_t elem = QREMOVE(state->queue);
        elem.callback(dev, elem.data.indices, elem.data.args);
        _free_simple_event_data(elem.data);
    }
}

UNUSED static void
_DML_execute_immediate_afters(conf_object_t *dev, lang_void *aux) {
    _dml_immediate_after_state_t *state = (_dml_immediate_after_state_t *)aux;
    // Only acquire the device if it hasn't been deleted to avoid a
    // use-after-free. There's no possibility of a data race on state->deleted
    // (nor any other part of the state if state->deleted is true) as the
    // device can only be deleted in global context.
    if (unlikely(state->deleted)) {
        ASSERT(state->posted);
        ASSERT(QEMPTY(state->queue));
        // No need to call QFREE, already done
        MM_FREE(state);
        return;
    }
    domain_lock_t *lock;
    SIM_ACQUIRE_OBJECT(dev, &lock);
    ASSERT(state->posted);
    if (unlikely(QEMPTY(state->queue))) {
        state->posted = false;
        SIM_RELEASE_OBJECT(dev, &lock);
        return;
    }
    _dml_immediate_after_queue_elem_t elem = QREMOVE(state->queue);
    if (QEMPTY(state->queue)) {
        state->posted = false;
    } else {
        VT_stacked_post(dev,
                        _DML_execute_immediate_afters,
                        (lang_void *)state);
    }
    elem.callback(dev, elem.data.indices, elem.data.args);
    _free_simple_event_data(elem.data);
    SIM_RELEASE_OBJECT(dev, &lock);
}

UNUSED static void
_DML_post_immediate_after(
    conf_object_t *dev,
    _dml_immediate_after_state_t *state,
    void (*callback)(conf_object_t *, const uint32 *, const void *),
    const uint32 *indices, uint32 dimensions, const void *args,
    size_t args_size, const _identity_t *domains, uint32 no_domains) {
    ASSERT(!state->deleted);
    _dml_immediate_after_queue_elem_t elem = {
        .callback = callback,
        .data = _DML_create_simple_event_data(
            indices, dimensions, args, args_size, domains, no_domains)
    };
    QADD(state->queue, elem);
    if (!state->posted) {
        state->posted = true;
        VT_stacked_post(dev,
                        _DML_execute_immediate_afters,
                        (lang_void *) state);
    }
}

UNUSED static void
_DML_cancel_immediate_afters(_dml_immediate_after_state_t *state,
                             _identity_t id) {
    uint32 queue_len = QLEN(state->queue);
    _dml_immediate_after_queue_t new_queue = QNULL;
    for (uint32 i = 0; i < queue_len; ++i) {
        _dml_immediate_after_queue_elem_t elem = QGET(state->queue, i);
        bool found = false;
        for (uint32 j = 0; j < elem.data.no_domains; ++j) {
            if (_identity_eq(id, elem.data.domains[j])) {
                found = true;
                break;
            }
        }
        if (found) {
            _free_simple_event_data(elem.data);
        } else {
            QADD(new_queue, elem);
        }
    }
    _dml_immediate_after_queue_t old_queue = state->queue;
    state->queue = new_queue;
    QFREE(old_queue);
}

// All auxiliary info needed to de/serialize suspended calls created
// from a specific after-on-hook.
//
// An after-on-hook is unique in respect to three things:
// 1. The message component types of the hook
// 2. The target callback, which is either...
//    a. A method, unique in respect to the specific method
//    b. send_now of a hook, unique in respect to the message component types
//       of the hook.
// 3. What message components of the hook are propagated to what parameters of
//    the target callback.
//
// Any after-on-hooks that are identical in respect to these three things
// share the same set of after-on-hook info.
typedef struct {
    const char *callback_key;
    void (*callback)(conf_object_t *dev, const uint32 *indices,
                     const void *args, const void *msg);
    _serializer_t args_serializer;
    _deserializer_t args_deserializer;
    // Size of the data args_de/serializer works with
    uint32 args_size;
    // id of the object parent of the target callback method
    uint32 method_parent_id;
} _dml_after_on_hook_info_t;

// An element of a hook queue. Currently, the only elements of a hook queue
// are calls suspended from an after-on-hook, so that's what this represents.
typedef struct {
    void (*callback)(conf_object_t *dev, const uint32 *indices,
                     const void *args, const void *msg);
    _simple_event_data_t data;
    const char *callback_key;
} _dml_hook_queue_elem_t;

// A hook queue, which may or may not have been detached.
typedef VECT(_dml_hook_queue_elem_t) _dml_hook_queue_t;

// A hook queue detached from its hook due to it being processed by a send_now
// in progress.
typedef struct _dml_detached_hook_queue {
    _dml_hook_queue_t *queue;
    // The number of elements of the detached hook queue already processed by
    // the send_now
    size_t processed_elems;
    // The detached hook queue of the next send_now on the call stack
    // (NULL if there is none). The naming is confusing because
    // _dml_detached_hook_queue acts like a stack: the detached hook queue of
    // the next send_now will be on top of this one, hence "prev", as it's
    // previous element in the stack.
    //
    // This member only gets leveraged if the thread the send_now is running on
    // gets suspended due to shenanigans like SIM_transaction_wait
    struct _dml_detached_hook_queue *prev;
    // The detached hook queue of the previous send_now in progress (NULL if
    // there is none).
    struct _dml_detached_hook_queue *next;
} _dml_detached_hook_queue_t;

// All storage associated to a specific hook, allocated as part of the device
// struct.
typedef struct {
    _dml_hook_queue_t queue;
    // Could be expanded to have additional members, if needed.
} _dml_hook_t;

// A set of auxiliary info related to a hook node. Each member is used for one
// or more of the following purposes:
// 1. resolving hook references to _dml_hook_t pointers
// 2. checkpointing hook attributes
// 3. deserializing hook references
typedef struct {
    // The offset from the device struct to the _dml_hook_t (array) allocation
    // of this hook node. Used for 1. and 2.
    size_t          device_offset;
    // The uniq of the type sequence corresponding to the message component
    // types of the hook node. Used for 3.
    uint32          typeseq_uniq;
    // The id of the hook node. Used for 2.
    uint32          hook_id;
} _dml_hook_aux_info_t;

UNUSED static set_error_t
_deserialize_hook_reference(ht_str_table_t *hook_id_info_ht,
                            const _dml_hook_aux_info_t *hook_aux_infos,
                            uint32 expected_typ_uniq,
                            attr_value_t val,
                            _hookref_t *out_hookref) {
    const char *logname = SIM_attr_string(SIM_attr_list_item(val, 0));
    _hookref_t hookref;
    set_error_t error = _deserialize_identity(hook_id_info_ht, val, &hookref);
    if (unlikely(error != Sim_Set_Ok)) {
        return error;
    }
    if (unlikely(hookref.id == 0)) {
        // Deserialized _identity_t's id being 0 indicates the serialized
        // hook reference was zero-initialized.
        *out_hookref = (_hookref_t) { 0 };
        return Sim_Set_Ok;
    }
    if (unlikely(hook_id_info_ht == NULL)) {
        SIM_c_attribute_error("Failed to look up hook '%s' when "
                              "deserializing _hookref_t", logname);
        return Sim_Set_Illegal_Value;
    }
    if (unlikely(hook_aux_infos[hookref.id - 1].typeseq_uniq
                 != expected_typ_uniq)) {
        SIM_c_attribute_error("Failed to deserialize _hookref_t: the message"
                              "component types for hook '%s' doesn't match"
                              "the message component types of the desired"
                              "hook type", logname);
        return Sim_Set_Illegal_Value;
    }
    *out_hookref = hookref;
    return Sim_Set_Ok;
}

UNUSED static inline _dml_hook_t *
_DML_resolve_hookref(void *dev, const _dml_hook_aux_info_t *hook_aux_infos,
                     _hookref_t hookref) {
    ASSERT(hookref.id);
    return (_dml_hook_t *)((uintptr_t)dev
                           + hook_aux_infos[hookref.id - 1].device_offset)
         + hookref.encoded_index;
}

UNUSED static void
_DML_free_hook_queue(_dml_hook_queue_t *q) {
    VFORT(*q, _dml_hook_queue_elem_t, elem) {
        _free_simple_event_data(elem.data);
    }
    VFREE(*q);
}

UNUSED static void
_DML_attach_callback_to_hook(
    _dml_hook_t *hook, const _dml_after_on_hook_info_t *info,
    const uint32 *indices, uint32 dimensions, const void *args,
    const _identity_t *domains, uint32 no_domains) {
    uint32 args_size = info->args_size;
    _dml_hook_queue_elem_t elem = {
        .callback = info->callback,
        .callback_key = info->callback_key,
        .data = _DML_create_simple_event_data(
            indices, dimensions, args, args_size, domains, no_domains)};
    VADD(hook->queue, elem);
}

UNUSED static uint64
_DML_send_hook(conf_object_t *dev,
               _dml_detached_hook_queue_t **detached_queue_stack,
               _dml_hook_t *hook, const void *msg) {
    _dml_hook_queue_t detached_queue = hook->queue;
    _dml_detached_hook_queue_t detached_queue_ref =
        { .queue = &detached_queue };
    if (!*detached_queue_stack) {
        *detached_queue_stack = &detached_queue_ref;
    } else {
        ASSERT(!(*detached_queue_stack)->prev);
        (*detached_queue_stack)->prev = &detached_queue_ref;
        detached_queue_ref.next = *detached_queue_stack;
        *detached_queue_stack = &detached_queue_ref;
    }
    VINIT(hook->queue);
    // The use of VFORI+VGET instead of VFOREACH or VFORT is important, here!
    // The detached_queue.elements pointer _can plausibly be changed_
    // as a result of the callbacks, which VFOREACH and VFORT can't handle!
    VFORI(detached_queue, i) {
        _dml_hook_queue_elem_t elem = VGET(detached_queue, i);
        ++detached_queue_ref.processed_elems;
        elem.callback(dev, elem.data.indices, elem.data.args, msg);
        _free_simple_event_data(elem.data);
    }
    if (detached_queue_ref.next) {
        detached_queue_ref.next->prev = detached_queue_ref.prev;
    }
    if (likely(detached_queue_ref.prev == NULL)) {
        ASSERT(*detached_queue_stack == &detached_queue_ref);
        *detached_queue_stack = detached_queue_ref.next;
    } else {
        // There is an unfinished send_now in progress that started *after*
        // this one! This is only possible with thread suspension shenanigans
        // like SIM_transaction_wait in play.
        detached_queue_ref.prev->next = detached_queue_ref.next;
    }
    // The length of the detached queue _after it has been processed_
    // indicates how many callbacks have been resolved.
    // The length of the queue before processing is not good enough since
    // elements later in the queue can actually be removed during
    // the loop.
    uint64 no_resolved_callbacks = VLEN(detached_queue);
    VFREE(detached_queue);
    return no_resolved_callbacks;
}


UNUSED static void
_DML_cancel_afters_in_hook_queue(
    _dml_hook_queue_t *queue, _identity_t id, uint32 start_offset) {
    uint32 queue_len = VLEN(*queue);
    if (start_offset >= queue_len) {
        return;
    }
    _dml_hook_queue_t new_queue = VNULL;
    if (start_offset > 0) {
        VCOPY(new_queue, *queue);
        VTRUNCATE(new_queue, start_offset);
    }

    for (uint32 i = start_offset; i < queue_len; ++i) {
        _dml_hook_queue_elem_t elem = VGET(*queue, i);
        bool found = false;
        for (uint32 j = 0; j < elem.data.no_domains; ++j) {
            if (_identity_eq(id, elem.data.domains[j])) {
                found = true;
                break;
            }
        }
        if (found) {
            _free_simple_event_data(elem.data);
        } else {
            VADD(new_queue, elem);
        }
    }
    _dml_hook_queue_t old_queue = *queue;
    *queue = new_queue;
    VFREE(old_queue);
}

UNUSED static void
_DML_cancel_afters_in_detached_hook_queues(
    _dml_detached_hook_queue_t *stack, _identity_t id) {
    ASSERT(stack == NULL || stack->prev == NULL);
    while (stack) {
        _DML_cancel_afters_in_hook_queue(stack->queue, id,
                                         stack->processed_elems);
        stack = stack->next;
    }
}

// Hook attributes:
//
// Excluding array wrapping, a hook attribute is conceptually of the form
// "[[sa]*]", which represents the hook queue. Each element of the hook queue
// is represented through the corresponding element of the list -- though it
// may look like it, this is _not_ a pseudodictionary. Instead the idea is
// that for each inner element "[sa]", the string is a tag which simultaneously
// tells what kind of element has been serialized, and what serialized
// representation it uses. The "a" should therefore be processed according to
// what the tag tells.
//
// Currently, there exists only one kind of hook queue element -- a call
// suspended by an after-on-hook -- and only one representation for that
// element kind. So currently, there is only one valid tag, "after".
// Once coroutines are introduced, we may introduce the tag "coroutine", and
// if we want to change the serialized representation of after-on-hook elems,
// we can tag that representation using the tag "after1".
//
// The "after" representation (what "a" actually is with that tag) is as
// follows:
//
//  [ s                    [i*]      [a*]          [[s[i*]]*]           ]
//    ^ after-on-hook key  ^indices  ^arguments    ^after domains
//                                                  (list of identities)
//
// The after-on-hook key is used to look up the _dml_after_on_hook_into_t
// needed to deserialize this element.

// val is a serialization of an after elem of a hook queue, minus the tag
UNUSED static set_error_t
_DML_deserialize_hook_queue_elem_after(ht_str_table_t *callback_ht,
                                       ht_str_table_t *id_info_ht,
                                       const _id_info_t *id_infos,
                                       attr_value_t val,
                                       _dml_hook_queue_elem_t *e) {
    _simple_event_data_t data = { 0 };

    const char *callback_key    = SIM_attr_string(SIM_attr_list_item(val, 0));
    attr_value_t indices_attr   = SIM_attr_list_item(val, 1);
    attr_value_t arguments_attr = SIM_attr_list_item(val, 2);
    attr_value_t domains_attr   = SIM_attr_list_item(val, 3);

    set_error_t error = Sim_Set_Ok;

    _dml_after_on_hook_info_t *callback_info = ht_lookup_str(callback_ht,
                                                             callback_key);
    if (unlikely(!callback_info)) {
        SIM_c_attribute_error("Failed lookup using after callback key: '%s'",
                              callback_key);
        error = Sim_Set_Illegal_Value;
        goto error;
    }

    _id_info_t id_info = id_infos[callback_info->method_parent_id - 1];
    error = _deserialize_simple_event_indices(
        id_info.dimsizes, id_info.dimensions, &indices_attr,
        &data.indices);
    if (unlikely(error != Sim_Set_Ok)) {
        goto error;
    }

    error = _deserialize_simple_event_arguments(
        callback_info->args_size, callback_info->args_deserializer,
        &arguments_attr, &data.args);
    if (unlikely(error != Sim_Set_Ok)) {
        goto error;
    }

    error = _deserialize_simple_event_domains(
        id_info_ht, &domains_attr, &data.domains, &data.no_domains);
    if (unlikely(error != Sim_Set_Ok)) {
        goto error;
    }

    e->callback = callback_info->callback;
    e->data = data;
    e->callback_key = callback_info->callback_key;
    return Sim_Set_Ok;
  error:
    _free_simple_event_data(data);
    return error;
}

// Serializes an after elem of a hook queue, and INCLUDES the "after" tag
UNUSED static attr_value_t
_DML_serialize_hook_queue_elem_after(ht_str_table_t *callback_ht,
                                     const _id_info_t *id_infos,
                                     _dml_hook_queue_elem_t elem) {
    _dml_after_on_hook_info_t *callback_info =
        ht_lookup_str(callback_ht, elem.callback_key);
    ASSERT(callback_info);
    _id_info_t id_info = id_infos[callback_info->method_parent_id - 1];
    attr_value_t callback_key_attr
        = SIM_make_attr_string(callback_info->callback_key);

    attr_value_t indices_attr = SIM_alloc_attr_list(id_info.dimensions);
    attr_value_t *indices_attr_list = SIM_attr_list(indices_attr);
    for (uint32 i = 0; i < id_info.dimensions; ++i) {
        indices_attr_list[i] = SIM_make_attr_uint64(elem.data.indices[i]);
    }
    attr_value_t arguments_attr =
          callback_info->args_serializer
        ? callback_info->args_serializer(elem.data.args)
        : SIM_make_attr_list(0);

    attr_value_t domains_attr = SIM_alloc_attr_list(elem.data.no_domains);
    attr_value_t *domains_attr_list = SIM_attr_list(domains_attr);
    for (uint32 i = 0; i < elem.data.no_domains; ++i) {
        domains_attr_list[i] = _serialize_identity(id_infos,
                                                   elem.data.domains[i]);
    }

    return SIM_make_attr_list(2, SIM_make_attr_string("after"),
                              SIM_make_attr_list(4, callback_key_attr,
                                                 indices_attr, arguments_attr,
                                                 domains_attr));
}

UNUSED static set_error_t
_DML_deserialize_hook_queue(ht_str_table_t *callback_ht,
                            ht_str_table_t *id_info_ht,
                            const _id_info_t *id_infos,
                            attr_value_t val,
                            _dml_hook_queue_t *q) {
    uint32 queue_len = SIM_attr_list_size(val);
    _dml_hook_queue_t temp_q = VNULL;
    set_error_t error = Sim_Set_Ok;
    VRESIZE(temp_q, queue_len);
    uint32 i = 0;
    for (; i < queue_len; ++i) {
        attr_value_t item = SIM_attr_list_item(val, i);
        const char *elem_kind = SIM_attr_string(SIM_attr_list_item(item,
                                                                       0));
        if (unlikely(strcmp(elem_kind, "after") != 0)) {
            SIM_c_attribute_error("Illegal hook queue elem kind '%s' when "
                                  "deserializing hook queue", elem_kind);
            error = Sim_Set_Illegal_Value;
            goto error;
        }
        _dml_hook_queue_elem_t elem;
        error = _DML_deserialize_hook_queue_elem_after(
            callback_ht, id_info_ht, id_infos, SIM_attr_list_item(item, 1),
            &elem);
        if (unlikely(error != Sim_Set_Ok)) {
            goto error;
        }
        VSET(temp_q, i, elem);
    }
    _DML_free_hook_queue(q);
    *q = temp_q;
    return Sim_Set_Ok;
  error:
    VTRUNCATE(temp_q, i);
    _DML_free_hook_queue(&temp_q);
    return error;
}


UNUSED static attr_value_t
_DML_serialize_hook_queue(ht_str_table_t *callback_ht,
                          const _id_info_t *id_infos,
                          _dml_hook_queue_t *q) {
    attr_value_t out = SIM_alloc_attr_list(VLEN(*q));
    attr_value_t *out_list = SIM_attr_list(out);
    VFORI(*q, i) {
        out_list[i] = _DML_serialize_hook_queue_elem_after(callback_ht,
                                                           id_infos,
                                                           VGET(*q, i));
    }
    return out;
}


UNUSED static void
_DML_register_hook_attribute(conf_class_t *cls, const char *attrname,
                             get_attr_t getter, set_attr_t setter,
                             const _dml_hook_aux_info_t *aux_info,
                             _id_info_t hook_id_info, uint32 port_dims) {

    // Conceptually, "[[sa]*]". Since the only elem representation is that of
    // "after", instead of "a" that representation is used directly.
    strbuf_t type = sb_newf("[[s[s[i*][a*][[s[i*]]*]]]*]");
    for (uint32 i = 0; i < hook_id_info.dimensions - port_dims; ++i) {
        char *tmp_type = sb_detach(&type);
        sb_addfmt(&type, "[%s{%d}]", tmp_type,
                  hook_id_info.dimsizes[hook_id_info.dimensions - 1 - i]);
        MM_FREE(tmp_type);
    }
    SIM_register_typed_attribute(cls, attrname, getter, (lang_void *) aux_info,
                                 setter, (lang_void *) aux_info,
                                 Sim_Attr_Optional | Sim_Attr_Internal,
                                 sb_str(&type), NULL, "hook");
    sb_free(&type);
}

UNUSED static void
_DML_register_subobj_connect(conf_class_t *cls,
                             const char *classname, const char *port,
                             const char *desc)
{
        conf_class_t *port_cls = SIM_get_class(classname);
        if (port_cls == NULL) {
                char short_buf[256];
                snprintf(short_buf, 256, "Class '%s' not found", classname);
                char long_buf[256];
                snprintf(long_buf, 256,
                         "Failed to look up class '%s'"
                         " when registering port '%s'"
                         " in class '%s'", classname, port,
                         SIM_get_class_name(cls));
                VT_critical_error(short_buf, long_buf);
                return;
        }
        SIM_register_port(cls, port, port_cls, desc);
}

typedef struct {
        conf_object_t obj;
        conf_object_t *dev;
        int ndims;
        const uint32 *indices;
} _port_object_t;

UNUSED static conf_object_t *
_port_class_alloc_object(lang_void *data)
{
        return (conf_object_t *)MM_ZALLOC(1, _port_object_t);
}
UNUSED static lang_void *
_port_class_init_object(conf_object_t *obj, lang_void *data)
{
        _port_object_t *po = (_port_object_t *)obj;
        if (po->dev == NULL) {
                // can happen when restoring a checkpoint after reducing an
                // object array size
                SIM_LOG_ERROR(obj, 0, "Port object not recognized by parent");
                return NULL;
        }
        return obj;
}
UNUSED static int
_port_class_delete_instance(conf_object_t *obj)
{
        MM_FREE(obj);
        return 0;
}
UNUSED static conf_class_t *
_register_port_class(const char *name, const char *desc, const char *doc) {
        class_data_t cd = {
                .alloc_object = _port_class_alloc_object,
                .init_object = _port_class_init_object,
                .delete_instance = _port_class_delete_instance,
                .description = doc,
                .class_desc = desc,
        };
        return SIM_register_class(name, &cd);
}

UNUSED static conf_object_t *
_init_port_object(conf_object_t *dev, const char *portname, int ndims,
                  const uint32 *indices)
{
        _port_object_t *po = (_port_object_t *)SIM_object_descendant(
                dev, portname);
        ASSERT(po != NULL);
        po->dev = dev;
        po->ndims = ndims;
        po->indices = indices;
        return &po->obj;
}

UNUSED static conf_object_t *
_dmllib_port_obj_from_device_obj(
        conf_object_t *dev, const char *qname, const char *port_prefix)
{
        // HACK: This function finds the conf-object of a port by mangling
        // qname. Currently, the extra .port/.bank namespace can only appears
        // once, as the second last namespace component, because we don't allow
        // nested ports. Thus, the port name differs from qname only by this
        // one inserted namespace.
        const char *dot = strrchr(qname, '.');
        const char *suffix = dot == NULL ? qname : dot + 1;
        int prefix_len = suffix - qname;
        char name[strlen(qname) + strlen(port_prefix) + 1];
        sprintf(name, "%.*s%s%s", prefix_len, qname, port_prefix, suffix);
        conf_object_t *ret = SIM_object_descendant(dev, name);
        ASSERT(ret);
        return ret;
}

/*
Before Simics 6, there were no port objects, so attributes in ports and banks
were registered on the device object using the name <portname>_<attrname>.  In
Simics 6, attributes are instead registered on the port object, but with a
proxy pseudo attribute registered on the device object for compatibility.

There are two functions for registering an attribute on a port class, with a
proxy on the device class: _register_port_attr registers an attribute on a
single port, and _register_port_array_attr registers an attribute on a
one-dimensional port array. Multi-dimensional port arrays don't exist in 5 and
thus don't need proxy attributes.
*/
typedef struct {
        ptrdiff_t port_obj_offset;
        const char *attrname;
        get_attr_t get;
        set_attr_t set;
        void *getset_data;
} _port_attr_t;
static attr_value_t
_get_legacy_proxy_attr(lang_void *ptr, conf_object_t *obj, attr_value_t *idx)
{
        ASSERT(SIM_attr_is_nil(*idx));
        _port_attr_t *port = (_port_attr_t *)ptr;
        conf_object_t *portobj = *(conf_object_t **)(
                (uintptr_t)obj + port->port_obj_offset);
        return port->get(port->getset_data, portobj, NULL);
}
static set_error_t
_set_legacy_proxy_attr(lang_void *ptr, conf_object_t *obj, attr_value_t *val,
                      attr_value_t *idx)
{
        ASSERT(SIM_attr_is_nil(*idx));
        _port_attr_t *port = (_port_attr_t *)ptr;
        conf_object_t *portobj = *(conf_object_t **)(
                (uintptr_t)obj + port->port_obj_offset);
        if (port->attrname == NULL || SIM_object_is_configured(portobj)) {
                return port->set(port->getset_data, portobj, val, NULL);
        } else {
                // port attribute is registered as required; need to propagate
                // value through API call to fulfil requirement
                return SIM_set_attribute_default(portobj, port->attrname, *val);
        }
}

UNUSED static void
_register_port_attr_no_aux(conf_class_t *portcls, const char *attrname,
                           get_attr_t getter, set_attr_t setter,
                           attr_attr_t attr, const char *type, const char *desc)
{
        SIM_register_typed_attribute(
                portcls, attrname, getter, NULL, setter, NULL,
                attr, type, NULL, desc);
}

// port_obj_offset is the offset within the device struct of a pointer to the
// port object.
UNUSED static void
_register_port_legacy_proxy_attr(conf_class_t *devcls, conf_class_t *portcls,
                                 ptrdiff_t port_obj_offset, bool is_bank,
                                 const char *portname, const char *attrname,
                                 get_attr_t getter, set_attr_t setter,
                                 attr_attr_t attr, const char *type,
                                 const char *desc, void *getset_data)
{
        _port_attr_t *data = MM_MALLOC(1, _port_attr_t);
        data->port_obj_offset = port_obj_offset;
        if ((attr & Sim_Attr_Flag_Mask) == Sim_Attr_Required) {
                ASSERT(setter);
                data->attrname = MM_STRDUP(attrname);
        } else {
                data->attrname = NULL;
        }
        data->get = getter;
        data->set = setter;
        data->getset_data = getset_data;
        char name[strlen(portname) + strlen(attrname) + 2];
        sprintf(name, "%s_%s", portname, attrname);
        strbuf_t proxy_desc = sb_newf(
                "Proxy attribute for %s.%s.%s",
                is_bank ? "bank" : "port", portname, attrname);
        SIM_register_typed_attribute(
                devcls, name,
                getter ? _get_legacy_proxy_attr : NULL, data,
                setter ? _set_legacy_proxy_attr : NULL, data,
                (attr_attr_t)(Sim_Attr_Pseudo | Sim_Attr_Internal),
                type, NULL, sb_str(&proxy_desc));
        sb_free(&proxy_desc);
}

UNUSED static void
_register_port_attr(conf_class_t *devcls, conf_class_t *portcls,
                    ptrdiff_t port_obj_offset, bool is_bank,
                    const char *portname, const char *attrname,
                    get_attr_t getter, set_attr_t setter,
                    attr_attr_t attr, const char *type, const char *desc) {
    _register_port_attr_no_aux(portcls, attrname, getter, setter, attr, type,
                               desc);
    _register_port_legacy_proxy_attr(devcls, portcls, port_obj_offset, is_bank,
                                     portname, attrname, getter, setter, attr,
                                     type, desc, NULL);
}

typedef struct {
        ptrdiff_t port_obj_base_offset;
        const char *attrname;
        get_attr_t get;
        set_attr_t set;
        void *getset_data;
        uint32 array_size;
} _port_array_attr_t;
static attr_value_t
_get_legacy_proxy_array_attr(lang_void *ptr, conf_object_t *obj,
                             attr_value_t *idx)
{
        ASSERT(SIM_attr_is_nil(*idx));
        _port_array_attr_t *port = (_port_array_attr_t *)ptr;
        conf_object_t **port_obj_ptr_base = (conf_object_t **)(
                (uintptr_t)obj + port->port_obj_base_offset);
        attr_value_t vals = SIM_alloc_attr_list(port->array_size);
        for (uint32 i = 0; i < port->array_size; i++) {
                conf_object_t *port_obj = port_obj_ptr_base[i];
                attr_value_t val = port->get(port->getset_data, port_obj,
                                             NULL);
                if (SIM_attr_is_invalid(val)) {
                        SIM_attr_free(&vals);
                        return val;
                }
                SIM_attr_list_set_item(&vals, i, val);
        }
        return vals;
}
static set_error_t
_set_legacy_proxy_array_attr(lang_void *ptr, conf_object_t *obj,
                             attr_value_t *vals, attr_value_t *idx)
{
        ASSERT(SIM_attr_is_nil(*idx));
        _port_array_attr_t *port = (_port_array_attr_t *)ptr;
        conf_object_t **port_obj_ptr_base = (conf_object_t **)(
                (uintptr_t)obj + port->port_obj_base_offset);
        for (uint32 i = 0; i < port->array_size; i++) {
                conf_object_t *port_obj = port_obj_ptr_base[i];
                attr_value_t val = SIM_attr_list_item(*vals, i);
                set_error_t err;
                if (port->attrname == NULL
                    || SIM_object_is_configured(port_obj)) {
                        err = port->set(port->getset_data, port_obj, &val,
                                        NULL);
                } else {
                        // port attribute is registered as required; need to
                        // propagate value through API call to fulfil
                        // requirement
                        err = SIM_set_attribute_default(port_obj,
                                                        port->attrname, val);
                }
                if (err != Sim_Set_Ok) {
                        return err;
                }
        }
        return Sim_Set_Ok;
}
// port_obj_offset is the offset within the device struct of the first pointer
// to a port object. Remaining port objects are stored consecutively in memory.
UNUSED static void
_register_port_array_legacy_proxy_attr(
    conf_class_t *devcls, conf_class_t *portcls, ptrdiff_t port_obj_offset,
    uint32 array_size, bool is_bank, const char *portname,
    const char *attrname, get_attr_t getter, set_attr_t setter,
    attr_attr_t attr, const char *type, const char *desc, void *getset_data) {
        _port_array_attr_t *data = MM_MALLOC(1, _port_array_attr_t);
        data->port_obj_base_offset = port_obj_offset;
        if ((attr & Sim_Attr_Flag_Mask) == Sim_Attr_Required) {
            ASSERT(setter);
            data->attrname = MM_STRDUP(attrname);
        } else {
            data->attrname = NULL;
        }
        data->get = getter;
        data->set = setter;
        data->array_size = array_size;
        data->getset_data = getset_data;
        char name[strlen(portname) + strlen(attrname) + 2];
        sprintf(name, "%s_%s", portname, attrname);
        strbuf_t proxy_desc = sb_newf("Proxy attribute for %s.%s[].%s",
                                      is_bank ? "bank" : "port",
                                      portname, attrname);
        strbuf_t proxy_type = sb_newf("[%s{%d}]", type, array_size);
        SIM_register_typed_attribute(
                devcls, name,
                getter ? _get_legacy_proxy_array_attr : NULL, data,
                setter ? _set_legacy_proxy_array_attr : NULL, data,
                (attr_attr_t)(Sim_Attr_Pseudo | Sim_Attr_Internal),
                sb_str(&proxy_type), NULL, sb_str(&proxy_desc));
        sb_free(&proxy_type);
        sb_free(&proxy_desc);
}

UNUSED static void
_register_port_array_attr(conf_class_t *devcls, conf_class_t *portcls,
                          ptrdiff_t port_obj_offset, uint32 array_size,
                          bool is_bank, const char *portname,
                          const char *attrname, get_attr_t getter,
                          set_attr_t setter, attr_attr_t attr,
                          const char *type, const char *desc) {
    _register_port_attr_no_aux(portcls, attrname, getter, setter, attr, type,
                               desc);
    _register_port_array_legacy_proxy_attr(devcls, portcls, port_obj_offset,
                                           array_size, is_bank, portname,
                                           attrname, getter, setter, attr,
                                           type, desc, NULL);
}


typedef struct {
        char *bufs[4];
        unsigned char i;
} dml_qname_cache_t;

#include <stdarg.h>

UNUSED PRINTF_FORMAT(2, 3) static const char *
__qname(dml_qname_cache_t *cache, const char *fmt, ...)
{
        va_list va;
        char *s;
        /* rotate between four buffers */
        if (!cache->bufs[cache->i])
                cache->bufs[cache->i] = MM_MALLOC(256, char);
        s = cache->bufs[cache->i];
        cache->i = (cache->i + 1) % 4;

        va_start(va, fmt);
        vsnprintf(s, 256, fmt, va);
        va_end(va);
        return (const char *)s;
}

UNUSED static const char *
_DML_get_qname(_identity_t id, const _id_info_t *id_infos,
               dml_qname_cache_t *cache, const char *dev_name) {
    _id_info_t info = id_infos[id.id - 1];

    const char *logname = info.logname;

    // In order to distinguish the device object from any other, its id_info
    // logname is always "dev", but we want its name when it comes to qname.
    if (strcmp(logname, "dev") == 0) {
        return dev_name;
    }

    if (info.dimensions == 0) {
        return logname;
    }

    uint32 indices[info.dimensions];
    uint32 index = id.encoded_index;
    for (int32 i = info.dimensions - 1; i >= 0; --i) {
        indices[i] = index % info.dimsizes[i];
        index /= info.dimsizes[i];
    }

    strbuf_t qname_buf = SB_INIT;
    for (uint32 i = 0; i < info.dimensions; ++i) {
        const char *next_index = strchr(logname, '%');
        ASSERT(next_index && next_index[1] == 'u');
        sb_addfmt(&qname_buf, "%.*s%u", (int)(next_index - logname),
                  logname, indices[i]);
        logname = next_index + 2;
    }
    ASSERT(!strchr(logname, '%'));
    const char *qname = __qname(cache, "%s%s", sb_str(&qname_buf), logname);
    sb_free(&qname_buf);
    return qname;
}

static inline int
DML_pointer_eq(lang_void *data, lang_void *match_data)
{ return data == match_data; }

typedef bool (*_dml_reg_read_t)(void *dev, const uint16 *idx,
                                uint64 *result);
typedef bool (*_dml_reg_write_t)(void *dev, const uint16 *idx, uint64 val);
typedef struct {
        const char *name;
        unsigned dim;
        _dml_reg_read_t read;
        _dml_reg_write_t write;
} _dml_reg_t;

typedef struct {
        int64 num;
        uint32 reg;
        const uint16 *idx;
} _dml_reg_number_t;

static inline const _dml_reg_number_t *
_DML_find_regnum(const _dml_reg_number_t *map, uint32 maplen, uint32 regnum)
{
        uint32 i;
        for (i = 0; i < maplen; i++) {
                if (map[i].num == regnum)
                        return &map[i];
        }
        return NULL;
}

/* returns a static string */
static const char *
_DML_regname_unindexed(const _dml_reg_t *regs, const _dml_reg_number_t *map)
{
        const _dml_reg_t *reg = &regs[map->reg];

        if (reg->dim == 0)
                return reg->name;
        return NULL;
}

/* returns an allocated string to be freed by the caller */
static inline char *
_DML_regname_indexed(const _dml_reg_t *regs, const _dml_reg_number_t *map)
{
        const _dml_reg_t *reg = &regs[map->reg];

        strbuf_t name = SB_INIT;

        const char *src = reg->name;
        const uint16 *idxp = map->idx;
        
        for (int dim = reg->dim; dim > 0; dim--) {
                while (*src != '[')
                        sb_addc(&name, *src++);
                src++;
                sb_addfmt(&name, "[%u", *idxp++);
        }
        sb_addstr(&name, src);
        return sb_detach(&name);
}

static inline const char *
_DML_make_regname(const _dml_reg_t *regs, const _dml_reg_number_t *map)
{
        if (!map)
                return NULL;

        const char *name = _DML_regname_unindexed(regs, map);
        if (name)
                return name;                 /* statically allocated */
        else {
                /* Here we leak memory! We should probably put it in a
                   per-instance hash table instead. See SIMICS-9055. */
                return _DML_regname_indexed(regs, map);
        }
}

static inline const _dml_reg_number_t *
_DML_find_regname(const _dml_reg_number_t *map, int maplen,
                  const char *name, const _dml_reg_t *regs)
{
        for (int i = 0; i < maplen; i++) {
                const char *name_unindexed =
                        _DML_regname_unindexed(regs, &map[i]);
                bool found = false;
                if (name_unindexed) {
                        found = (strcmp(name, name_unindexed) == 0);
                } else {
                        char *name_indexed = 
                                _DML_regname_indexed(regs, &map[i]);
                        found = (strcmp(name, name_indexed) == 0);
                        MM_FREE(name_indexed);
                }
                if (found)
                        return &map[i];
        }
        return NULL;
}

static inline uint64
_DML_read_reg(void *dev, const _dml_reg_number_t *map, const _dml_reg_t *regs)
{
        const _dml_reg_t *reg = &regs[map->reg];
        uint64 result;
        // This will currently ignore exceptions in getters
        reg->read(dev, map->idx, &result);
        return result;
}

static inline void
_DML_write_reg(void *dev, const _dml_reg_number_t *map, const _dml_reg_t *regs,
               uint64 val)
{
        const _dml_reg_t *reg = &regs[map->reg];
        // This will currently ignore exceptions in getters
        reg->write(dev, map->idx, val);
}

// This snipped is used from 1.4/dml-builtins.dml, mainly to avoid having to
// import sprintf into DML
static inline char *
_DML_describe_uint64_event(const char *base, uint64 data)
{
        char desc[strlen(base) + 25];
        sprintf(desc, "%s: %llu", base, data);
        return MM_STRDUP(desc);
}

typedef enum {
        Callback_Before_Read,
        Callback_After_Read,
        Callback_Before_Write,
        Callback_After_Write
} _callback_type_t;

typedef union _callback {
        before_read_callback_t before_read;
        after_read_callback_t after_read;
        before_write_callback_t before_write;
        after_write_callback_t after_write;
} _callback_t;

typedef struct _callback_entry {
        uint64 offset;
        uint64 size;
        lang_void *user_data;
        _callback_t callback;
} _callback_entry_t;

typedef VECT(_callback_entry_t *) _callback_vect_t;

typedef struct _connection_entry {
        conf_object_t *connection;
        bool enabled;

        _callback_vect_t before_read_callbacks;
        _callback_vect_t after_read_callbacks;
        _callback_vect_t before_write_callbacks;
        _callback_vect_t after_write_callbacks;
} _connection_entry_t;

typedef VECT(_connection_entry_t *) _connection_vect_t;

static _connection_entry_t *
_new_connection_entry(conf_object_t *connection)
{
        _connection_entry_t *entry = MM_ZALLOC(1, _connection_entry_t);
        entry->connection = connection;
        entry->enabled = true;
        return entry;
}

static _connection_entry_t *
_get_or_new_connection_entry(conf_object_t *connection,
                             _connection_vect_t *connections)
{
        _connection_entry_t *found = NULL;
        VFOREACH_T(*connections, _connection_entry_t *, cur) {
                if ((*cur)->connection == connection) {
                        found = *cur;
                        break;
                }
        }

        if (!found) {
                found = _new_connection_entry(connection);
                VADD(*connections, found);
        }

        return found;
}

static _callback_entry_t *
_new_callback_entry(uint64 offset, uint64 size, lang_void *user_data,
                    _callback_t callback)
{
        _callback_entry_t *entry = MM_ZALLOC(1, _callback_entry_t);
        entry->offset = offset;
        entry->size = size;
        entry->user_data = user_data;
        entry->callback = callback;

        return entry;
}

static bank_callback_handle_t
_register_callback(_callback_entry_t *entry, _callback_vect_t *callbacks)
{
        VADD(*callbacks, entry);
        return (bank_callback_handle_t)entry;
}

UNUSED static bank_callback_handle_t
_register_before_read(conf_object_t *bank,
                      conf_object_t *connection,
                      uint64 offset,
                      uint64 size,
                      before_read_callback_t before_read,
                      lang_void *user_data,
                      _connection_vect_t *connections,
                      _callback_vect_t *anonymous_callbacks)
{
        _callback_t callback = (_callback_t){.before_read = before_read};
        if (!connection) {
                return _register_callback(
                        _new_callback_entry(offset, size, user_data, callback),
                        anonymous_callbacks);
        }

        _connection_entry_t *entry = _get_or_new_connection_entry(connection,
                                                                  connections);
        return _register_callback(
                _new_callback_entry(offset, size, user_data, callback),
                &entry->before_read_callbacks);
}
UNUSED static bank_callback_handle_t
_register_after_read(conf_object_t *bank,
                     conf_object_t *connection,
                     uint64 offset,
                     uint64 size,
                     after_read_callback_t after_read,
                     lang_void *user_data,
                     _connection_vect_t *connections,
                     _callback_vect_t *anonymous_callbacks)
{
        _callback_t callback = (_callback_t){.after_read = after_read};
        if (!connection) {
                return _register_callback(
                        _new_callback_entry(offset, size, user_data, callback),
                        anonymous_callbacks);
        }

        _connection_entry_t *entry = _get_or_new_connection_entry(connection,
                                                                  connections);
        return _register_callback(
                _new_callback_entry(offset, size, user_data, callback),
                &entry->after_read_callbacks);
}

UNUSED static bank_callback_handle_t
_register_before_write(conf_object_t *bank,
                       conf_object_t *connection,
                       uint64 offset,
                       uint64 size,
                       before_write_callback_t before_write,
                       lang_void *user_data,
                       _connection_vect_t *connections,
                       _callback_vect_t *anonymous_callbacks)
{
        _callback_t callback = (_callback_t){.before_write = before_write};
        if (!connection) {
                return _register_callback(
                        _new_callback_entry(offset, size, user_data, callback),
                        anonymous_callbacks);
        }

        _connection_entry_t *entry = _get_or_new_connection_entry(connection,
                                                                  connections);
        return _register_callback(
                _new_callback_entry(offset, size, user_data, callback),
                &entry->before_write_callbacks);
}

UNUSED static bank_callback_handle_t
_register_after_write(conf_object_t *bank,
                      conf_object_t *connection,
                      uint64 offset,
                      uint64 size,
                      after_write_callback_t after_write,
                      lang_void *user_data,
                      _connection_vect_t *connections,
                      _callback_vect_t *anonymous_callbacks)
{
        _callback_t callback = (_callback_t){.after_write = after_write};
        if (!connection) {
                return _register_callback(
                        _new_callback_entry(offset, size, user_data, callback),
                        anonymous_callbacks);
        }

        _connection_entry_t *entry = _get_or_new_connection_entry(connection,
                                                                  connections);
        return _register_callback(
                _new_callback_entry(offset, size, user_data, callback),
                &entry->after_write_callbacks);
}

static bool
_remove_callback_from(bank_callback_handle_t callback,
                      _callback_vect_t *callbacks) {
        for (int i = 0; i < VLEN(*callbacks); ++i) {
                _callback_entry_t *entry = VGET(*callbacks, i);
                if ((bank_callback_handle_t)entry == callback) {
                        MM_FREE(entry);
                        VDELETE_ORDER(*callbacks, i);
                        return true;
                }
        }
        return false;
}

UNUSED static void
_remove_callback(bank_callback_handle_t callback,
                 _connection_vect_t *connections,
                 _callback_vect_t *anonymous_before_read,
                 _callback_vect_t *anonymous_after_read,
                 _callback_vect_t *anonymous_before_write,
                 _callback_vect_t *anonymous_after_write)
{
        VECT(_callback_vect_t *) all_callbacks = VNULL;
        VADD(all_callbacks, anonymous_before_read);
        VADD(all_callbacks, anonymous_after_read);
        VADD(all_callbacks, anonymous_before_write);
        VADD(all_callbacks, anonymous_after_write);

        VFOREACH_T(*connections, _connection_entry_t *, entry) {
                VADD(all_callbacks, &(*entry)->before_read_callbacks);
                VADD(all_callbacks, &(*entry)->after_read_callbacks);
                VADD(all_callbacks, &(*entry)->before_write_callbacks);
                VADD(all_callbacks, &(*entry)->after_write_callbacks);
        }

        VFOREACH_T(all_callbacks, _callback_vect_t *, callbacks) {
                if (_remove_callback_from(callback, *callbacks)) {
                        break;
                }
        }

        VFREE(all_callbacks);
}

static void
_free_callbacks(_callback_vect_t *callbacks)
{
        for (int i = 0; i < VLEN(*callbacks); ++i) {
                _callback_entry_t *entry = VGET(*callbacks, i);
                MM_FREE(entry);
        }
}

static void
_free_connection(_connection_entry_t *entry)
{
        _free_callbacks(&entry->before_read_callbacks);
        _free_callbacks(&entry->after_read_callbacks);
        _free_callbacks(&entry->before_write_callbacks);
        _free_callbacks(&entry->after_write_callbacks);
        MM_FREE(entry);
}

UNUSED static void
_remove_connection_callbacks(conf_object_t *bank,
                             conf_object_t *connection,
                             _connection_vect_t *connections)
{
        VFORI(*connections, i) {
                _connection_entry_t *entry = VGET(*connections, i);
                if (entry->connection == connection) {
                        _free_connection(entry);
                        VDELETE_ORDER(*connections, i);
                        break;
                }
        }
}

static void
_toggle_connection(conf_object_t *connection,
                   _connection_vect_t *connections,
                   bool enable)
{
        VFOREACH_T(*connections, _connection_entry_t *, entry) {
                if ((*entry)->connection == connection) {
                        (*entry)->enabled = enable;
                        break;
                }
        }
}

UNUSED static void
_enable_connection_callbacks(conf_object_t *connection,
                             _connection_vect_t *connections)
{
        _toggle_connection(connection, connections, true);
}

UNUSED static void
_disable_connection_callbacks(conf_object_t *connection,
                              _connection_vect_t *connections)
{
        _toggle_connection(connection, connections, false);
}

UNUSED static attr_value_t
_get_connections(_connection_vect_t *connections)
{
        attr_value_t v = SIM_alloc_attr_list(VLEN(*connections));
        for (int i = 0; i < VLEN(*connections); ++i) {
                _connection_entry_t *entry = VGET(*connections, i);
                SIM_attr_list_set_item(&v, i,
                                       SIM_make_attr_object(entry->connection));
        }
        return v;
}

static int
_connection_idx(conf_object_t *connection, _connection_vect_t *connections)
{
        for (int idx = 0; idx < VLEN(*connections); ++idx) {
                _connection_entry_t *entry = VGET(*connections, idx);
                if (entry->connection == connection) {
                        return idx;
                }
        }
        return -1;
}

UNUSED static bool
_move_before(conf_object_t *connection,
             conf_object_t *before,
             _connection_vect_t *connections)
{
        if (connection == before) {
                return false;
        }

        int connection_idx = _connection_idx(connection, connections);
        if (connection_idx < 0) {
                return false;
        }

        _connection_entry_t *connection_entry = VGET(*connections,
                                                     connection_idx);
        VDELETE_ORDER(*connections, connection_idx);
        if (_connection_idx(before, connections) < 0) {
                VADD(*connections, connection_entry);
        } else {
                int before_idx = _connection_idx(before, connections);
                VINSERT(*connections, before_idx, connection_entry);
        }

        return true;
}

static bool
_in_range(physical_address_t instr_offset,
          physical_address_t instr_size,
          uint64 access_offset, uint64 access_size)
{
        if (instr_offset <= (access_offset + access_size - 1)
            && (instr_offset + instr_size - 1) >= access_offset) {
                return true;
        }
        return false;
}

struct bank_access {
        conf_object_t *bank;
        bool *inquiry;
        physical_address_t *offset;
        physical_address_t size;

        uint64 *value;
        bool *success;
        bool *suppress;
        conf_object_t *initiator;
};

static void
_inquire(bank_access_t *handle)
{
        *handle->inquiry = true;
}

static bool
_is_miss(bank_access_t *handle)
{
        return !*handle->success;
}
static void
_set_miss(bank_access_t *handle, bool missed)
{
        *handle->success = !missed;
}

static physical_address_t
_offset(bank_access_t *handle)
{
        return *handle->offset;
}
static void
_set_offset(bank_access_t *handle, physical_address_t offset)
{
        *handle->offset = offset;
}

static physical_address_t
_size(bank_access_t *handle)
{
        return handle->size;
}

static void
_set_suppress(bank_access_t *handle)
{
        *handle->suppress = true;
}

static uint64
_value(bank_access_t *handle)
{
        return *handle->value;
}
static uint64
_value_unless_miss(bank_access_t *handle) {
        if (_is_miss(handle)) {
                SIM_LOG_ERROR(handle->bank, 0,
                              "Forbidden to read value if the access missed");
        }
        return _value(handle);
}

static void
_set_value(bank_access_t *handle, uint64 value)
{
        *handle->value = value;
}
static void
_set_value_and_forgive_miss(bank_access_t *handle, uint64 value) {
        _set_value(handle, value);
        _set_miss(handle, false);
}

static conf_object_t *
_initiator(bank_access_t *handle)
{
        return handle->initiator;
}

static void
_issue_callback(_callback_type_t type,
                _callback_entry_t *callback,
                bank_access_t *handle,
                conf_object_t *connection)
{
        switch (type) {
        case Callback_Before_Read:
        {
                bank_before_read_interface_t bank_before_read_interface = {
                        .offset = _offset,
                        .size = _size,
                        .set_offset = _set_offset,
                        .inquire = _inquire,
                        .initiator = _initiator};
                callback->callback.before_read(connection,
                                               &bank_before_read_interface,
                                               handle,
                                               callback->user_data);
        }
                break;
        case Callback_After_Read:
        {
                bank_after_read_interface_t bank_after_read_interface = {
                        .offset = _offset,
                        .size = _size,
                        .missed = _is_miss,
                        .value = _value_unless_miss,
                        .set_missed = _set_miss,
                        .set_value = _set_value_and_forgive_miss,
                        .initiator = _initiator};
                callback->callback.after_read(
                        connection, &bank_after_read_interface,
                        handle,
                        callback->user_data);
        }
                break;
        case Callback_Before_Write:
        {
                bank_before_write_interface_t bank_before_write_interface = {
                        .offset = _offset,
                        .size = _size,
                        .value = _value,
                        .suppress = _set_suppress,
                        .set_offset = _set_offset,
                        .set_value = _set_value,
                        .initiator = _initiator};
                callback->callback.before_write(
                        connection, &bank_before_write_interface,
                        handle,
                        callback->user_data);
        }
                break;
        case Callback_After_Write:
        {
                bank_after_write_interface_t bank_after_write_interface = {
                        .offset = _offset,
                        .size = _size,
                        .missed = _is_miss,
                        .set_missed = _set_miss,
                        .initiator = _initiator};
                callback->callback.after_write(connection,
                                               &bank_after_write_interface,
                                               handle,
                                               callback->user_data);
        }
                break;
        }
}

static void
_issue_callbacks(_callback_type_t type,
                 bank_access_t *handle,
                 conf_object_t *connection,
                 _callback_vect_t *callbacks)
{
        for (int i = 0; i < VLEN(*callbacks); ++i) {
                _callback_entry_t *callback = VGET(*callbacks, i);
                if (!_in_range(callback->offset, callback->size,
                               *handle->offset, handle->size)) {
                        continue;
                }
                _issue_callback(type, callback, handle, connection);
        }
}

static _callback_vect_t *
_connection_callbacks(_connection_entry_t *entry, _callback_type_t type)
{
        switch (type) {
        case Callback_Before_Read:
                return &entry->before_read_callbacks;
        case Callback_After_Read:
                return &entry->after_read_callbacks;
        case Callback_Before_Write:
                return &entry->before_write_callbacks;
        case Callback_After_Write:
                return &entry->after_write_callbacks;
        }
        ASSERT(0);
}

static void
_issue_callbacks_for_type(conf_object_t *bank,
                          _connection_vect_t *connections,
                          _callback_vect_t *anonymous_callbacks,
                          bank_access_t *handle,
                          _callback_type_t type)
{
        // although anonymous banks cannot be instrumented, they get this far
        if (!bank) {
                return;
        }

        _issue_callbacks(type, handle, NULL, anonymous_callbacks);
        VFOREACH_T(*connections, _connection_entry_t *, entry) {
                if (!(*entry)->enabled) {
                        continue;
                }
                _issue_callbacks(type, handle, (*entry)->connection,
                                 _connection_callbacks(*entry, type));
        }
}

UNUSED static void
_callback_before_read(conf_object_t *bank,
                      conf_object_t *initiator,
                      bool *inquiry,
                      physical_address_t *offset,
                      physical_address_t size,
                      _connection_vect_t *connections,
                      _callback_vect_t *anonymous_callbacks)
{
        bank_access_t access = {
                .bank = bank,
                .inquiry = inquiry,
                .offset = offset,
                .size = size,
                .initiator = initiator};
        _issue_callbacks_for_type(bank, connections,
                                  anonymous_callbacks, &access,
                                  Callback_Before_Read);
}
UNUSED static void
_callback_after_read(conf_object_t *bank,
                     conf_object_t *initiator,
                     physical_address_t *offset,
                     physical_address_t size,
                     uint64 *value,
                     bool *success,
                     _connection_vect_t *connections,
                     _callback_vect_t *anonymous_callbacks)
{
        bank_access_t access = {
                .bank = bank,
                .inquiry = NULL,
                .offset = offset,
                .size = size,
                .value = value,
                .success = success,
                .initiator = initiator};
        _issue_callbacks_for_type(bank, connections,
                                  anonymous_callbacks, &access,
                                  Callback_After_Read);
}

UNUSED static void
_callback_before_write(conf_object_t *bank,
                       conf_object_t *initiator,
                       physical_address_t *offset,
                       physical_address_t size,
                       uint64 *value,
                       bool *suppress,
                       _connection_vect_t *connections,
                       _callback_vect_t *anonymous_callbacks)
{
        bank_access_t access = {
                .bank = bank,
                .inquiry = NULL,
                .offset = offset,
                .size = size,
                .value = value,
                .suppress = suppress,
                .initiator = initiator};
        _issue_callbacks_for_type(bank, connections, anonymous_callbacks,
                                  &access,
                                  Callback_Before_Write);
}
UNUSED static void
_callback_after_write(conf_object_t *bank,
                      conf_object_t *initiator,
                      physical_address_t *offset,
                      physical_address_t size,
                      bool *success,
                      _connection_vect_t *connections,
                      _callback_vect_t *anonymous_callbacks)
{
        bank_access_t access = {
                .bank = bank,
                .inquiry = NULL,
                .offset = offset,
                .size = size,
                .success = success,
                .initiator = initiator};
        _issue_callbacks_for_type(bank, connections, anonymous_callbacks,
                                  &access,
                                  Callback_After_Write);
}

UNUSED static set_error_t
_set_device_member(attr_value_t val,
                   char *ptr,
                   const uint32 *dimension_sizes,
                   const uint32 *dimension_strides,
                   unsigned int remaining_dimensions,
                   set_error_t (*setter)(attr_value_t val, void *member,
                                         uintptr_t aux),
                   uintptr_t aux) {
        if (remaining_dimensions == 0) {
                return setter(val, (void*)ptr, aux);
        } else {
                for (unsigned i = 0; i < dimension_sizes[0]; ++i) {
                        set_error_t status = _set_device_member(
                            SIM_attr_list_item(val, i),
                            ptr + dimension_strides[0] * i,
                            &dimension_sizes[1],
                            &dimension_strides[1],
                            remaining_dimensions-1,
                            setter, aux);
                        // If deserialization fails, bail out.
                        if (unlikely(status != Sim_Set_Ok)) {
                            return status;
                        }
                }
                return Sim_Set_Ok;
        }
}

UNUSED static attr_value_t
_get_device_member(char *ptr,
                   const uint32 *dimension_sizes,
                   const uint32 *dimension_strides,
                   unsigned int remaining_dimensions,
                   attr_value_t (*getter)(void *member, uintptr_t aux),
                   uintptr_t aux) {
        attr_value_t to_return;
        if (remaining_dimensions == 0) {
                to_return = getter(ptr, aux);
        } else {
                to_return = SIM_alloc_attr_list(dimension_sizes[0]);
                attr_value_t im_attr;
                for (unsigned i = 0; i < dimension_sizes[0]; ++i) {
                        im_attr = _get_device_member(
                            ptr + dimension_strides[0] * i,
                            &dimension_sizes[1],
                            &dimension_strides[1],
                            remaining_dimensions-1,
                            getter, aux);
                        SIM_attr_list_set_item(&to_return, i, im_attr);
                }
        }
        return to_return;
}

UNUSED static set_error_t
_set_device_member_via_deserializer(attr_value_t val, void *dest,
                                    void *deserializer) {
    return ((_deserializer_t)deserializer)(val, dest);
}

UNUSED static attr_value_t
_get_device_member_via_serializer(void *val, void *serializer) {
    return ((_serializer_t)serializer)(val);
}


typedef struct {
        ptrdiff_t relative_base;
        // excluding port dimensions
        unsigned int    ndims;
        // excluding port dimensions
        const uint32    *dimension_sizes;
        // including port dimensions
        const uint32    *dimension_strides;
        _deserializer_t setter;
        _serializer_t   getter;
} _saved_userdata_t;

UNUSED static set_error_t
_saved_device_member_setter(attr_value_t val, void *dest,
                            uintptr_t acc) {
    return ((_saved_userdata_t *)acc)->setter(val, dest);
}

UNUSED static attr_value_t
_saved_device_member_getter(void *val, uintptr_t acc) {
    return ((_saved_userdata_t *)acc)->getter(val);
}



UNUSED static set_error_t
_set_saved_variable(lang_void *saved_access, conf_object_t *obj,
                    attr_value_t *val, attr_value_t *_) {
        _saved_userdata_t *acc = (_saved_userdata_t *) saved_access;

        return _set_device_member(*val,
                                  (char *)obj + acc->relative_base,
                                  acc->dimension_sizes,
                                  acc->dimension_strides,
                                  acc->ndims,
                                  _saved_device_member_setter,
                                  (uintptr_t) acc);
}

UNUSED static attr_value_t
_get_saved_variable(lang_void *saved_access, conf_object_t *obj,
                    attr_value_t *_) {
        _saved_userdata_t *acc = (_saved_userdata_t *) saved_access;
        return _get_device_member((char *)obj + acc->relative_base,
                                  acc->dimension_sizes,
                                  acc->dimension_strides,
                                  acc->ndims,
                                  _saved_device_member_getter,
                                  (uintptr_t) acc);
}

UNUSED static set_error_t
_set_port_saved_variable(lang_void *saved_access, conf_object_t *_portobj,
                         attr_value_t *val, attr_value_t *_) {
        _port_object_t *portobj = (_port_object_t *)_portobj;
        conf_object_t *obj = portobj->dev;
        _saved_userdata_t *acc = (_saved_userdata_t *) saved_access;
        char *ptr = (char *)obj + acc->relative_base;
        for (int i = 0; i < portobj->ndims; ++i) {
                ptr += portobj->indices[i] * acc->dimension_strides[i];
        }
        return _set_device_member(*val,
                                  ptr,
                                  acc->dimension_sizes,
                                  acc->dimension_strides + portobj->ndims,
                                  acc->ndims,
                                  _saved_device_member_setter,
                                  (uintptr_t) acc);
}

UNUSED static attr_value_t
_get_port_saved_variable(lang_void *saved_access, conf_object_t *_portobj,
                         attr_value_t *_) {
        _port_object_t *portobj = (_port_object_t *)_portobj;
        conf_object_t *obj = portobj->dev;
        _saved_userdata_t *acc = (_saved_userdata_t *) saved_access;
        char *ptr = (char *)obj + acc->relative_base;
        for (int i = 0; i < portobj->ndims; ++i) {
                ptr += portobj->indices[i] * acc->dimension_strides[i];
        }
        return _get_device_member(ptr,
                                  acc->dimension_sizes,
                                  acc->dimension_strides + portobj->ndims,
                                  acc->ndims,
                                  _saved_device_member_getter,
                                  (uintptr_t) acc);
}

UNUSED static void
_DML_init_dimension_strides_from_dimsizes(
    uint32 *buffer, const uint32 *dimsizes, uint32 dims, size_t member_size) {
    if (dims == 0) {
        return;
    }
    ASSERT(dimsizes != NULL);
    for (uint32 i = 0; i < dims; ++i) {
        buffer[dims - i - 1] = member_size;
        member_size *= dimsizes[dims - i - 1];
    }
}

typedef struct {
    ht_str_table_t *callback_ht;
    ht_str_table_t *id_info_ht;
    const _id_info_t *id_infos;
} _dml_hook_get_set_aux_data_t;

UNUSED static set_error_t
_DML_set_single_hook_attr(attr_value_t val, void *_hook, uintptr_t _aux) {
    _dml_hook_t *hook = _hook;
    _dml_hook_get_set_aux_data_t *aux = (typeof(aux))_aux;

    return _DML_deserialize_hook_queue(aux->callback_ht, aux->id_info_ht,
                                       aux->id_infos, val, &hook->queue);
}

UNUSED static attr_value_t
_DML_get_single_hook_attr(void *_hook, uintptr_t _aux) {
    _dml_hook_t *hook = _hook;
    _dml_hook_get_set_aux_data_t *aux = (typeof(aux))_aux;

    return _DML_serialize_hook_queue(aux->callback_ht, aux->id_infos,
                                     &hook->queue);
}


UNUSED static inline uint64 _identity_to_key(_identity_t id) {
        return (uint64)id.id << 32 | (uint64)id.encoded_index;
}

typedef struct {
    uint32 port_obj_offset;
    uint32 index_divisor;
} _dml_port_object_assoc_t;

UNUSED static inline conf_object_t *
_identity_to_portobj(const _dml_port_object_assoc_t *port_object_assocs,
                     conf_object_t *dev, _identity_t id) {
    _dml_port_object_assoc_t portobj_assoc = port_object_assocs[id.id - 1];
    if (!portobj_assoc.index_divisor) return dev;
    return ((conf_object_t **)((char *)dev + portobj_assoc.port_obj_offset))[
        id.encoded_index / portobj_assoc.index_divisor];
}

static attr_value_t
_serialize_array_aux(const uint8 *data, size_t elem_size,
                     const uint32 *dimsizes, uint32 dims,
                     uint64 total_elem_count, _serializer_t serialize_elem) {
    uint32 len = *dimsizes;

    // Serialize the final dimension as bytes if serialize_elem is NULL
    if (dims == 1 && !serialize_elem) {
        return SIM_make_attr_data(len, data);
    }

    size_t children_elem_count = total_elem_count/len;

    attr_value_t val = SIM_alloc_attr_list(len);
    attr_value_t *items = SIM_attr_list(val);

    for (uint32 i = 0; i < len; ++i) {
        if (dims == 1) {
            items[i] = serialize_elem(&data[i*elem_size]);
        } else {
            items[i] = _serialize_array_aux(
                data + children_elem_count * elem_size * i, elem_size,
                dimsizes + 1, dims - 1, children_elem_count, serialize_elem);
        }
    }
    return val;
}

UNUSED static attr_value_t
_serialize_array(const void *data, size_t elem_size,
                 const uint32 *dimsizes, uint32 dims,
                 _serializer_t serialize_elem) {
    ASSERT(dims > 0);
    size_t total_elem_count = 1;
    for (uint32 i = 0; i < dims; ++i) {
        total_elem_count *= dimsizes[i];
    }
    return _serialize_array_aux((const uint8 *)data, elem_size, dimsizes, dims,
                                total_elem_count, serialize_elem);
}


static set_error_t
_deserialize_array_aux(attr_value_t val, uint8 *data, size_t elem_size,
                       const uint32 *dimsizes, uint32 dims,
                       size_t total_elem_count,
                       _deserializer_t deserialize_elem,
                       bool elems_are_bytes) {
    uint32 len = *dimsizes;
    ASSERT(len != 0);

    // Allow the final dimension to be represented as data if elems_are_bytes
    bool data_allowed = elems_are_bytes && dims == 1;
    if (data_allowed && SIM_attr_is_data(val)) {
        if (unlikely(SIM_attr_data_size(val) != len)) {
            SIM_c_attribute_error(
                "Invalid serialized value of byte array: expected data of %u "
                "bytes, got %u", len, SIM_attr_data_size(val));
            return Sim_Set_Illegal_Value;
        }
        memcpy(data, SIM_attr_data(val), len);
        return Sim_Set_Ok;
    } else if (unlikely(!SIM_attr_is_list(val))) {
        if (data_allowed) {
            SIM_attribute_error("Invalid serialized representation of byte "
                                "array: not a list or data");
        } else {
            SIM_attribute_error("Invalid serialized representation of array: "
                                "not a list");
        }
        return Sim_Set_Illegal_Type;
    } else if (unlikely(SIM_attr_list_size(val) != len)) {
        SIM_c_attribute_error(
            "Invalid serialized representation of %sarray: expected list of "
            "%u elements, got %u", data_allowed ? "byte " : "", len,
            SIM_attr_list_size(val));
        return Sim_Set_Illegal_Type;
    }
    attr_value_t *items = SIM_attr_list(val);
    size_t children_elem_count = total_elem_count/len;
    for (uint32 i = 0; i < len; ++i) {
        set_error_t error;
        if (dims == 1) {
            error = deserialize_elem(items[i], &data[i*elem_size]);
        } else {
            error = _deserialize_array_aux(
                items[i], &data[i*children_elem_count*elem_size], elem_size,
                dimsizes + 1, dims - 1, children_elem_count, deserialize_elem,
                elems_are_bytes);
        }
        if (error != Sim_Set_Ok) {
            return error;
        }
    }
    return Sim_Set_Ok;
}

UNUSED static set_error_t
_deserialize_array(attr_value_t in_val, void *out_data, size_t elem_size,
                   const uint32 *dimsizes, uint32 dims,
                   _deserializer_t deserialize_elem, bool elems_are_bytes) {
    ASSERT(dims > 0);
    size_t total_elem_count = 1;
    for (uint32 i = 0; i < dims; ++i) {
        total_elem_count *= dimsizes[i];
    }

    uint8 *temp_out = MM_MALLOC(total_elem_count * elem_size, uint8);
    set_error_t error = _deserialize_array_aux(
        in_val, temp_out, elem_size, dimsizes, dims, total_elem_count,
        deserialize_elem, elems_are_bytes);
    if (error == Sim_Set_Ok) {
        memcpy(out_data, temp_out, total_elem_count*elem_size);
    }
    MM_FREE(temp_out);
    return error;
}


// The internal format for ht is:
// dict(trait_identifier -> dict(statement_idx -> bool))
UNUSED static uint64 _select_log_level(ht_int_table_t *ht,
                                       uint64 first_key,
                                       uint64 second_key,
                                       uint64 first,
                                       uint64 subsequent) {
        ht_int_table_t *sub_table = (ht_int_table_t*)
                ht_lookup_int(ht, first_key);
        if (!sub_table) {
                sub_table = MM_MALLOC(1, ht_int_table_t);
                ht_init_int_table(sub_table);
                ht_insert_int(ht, first_key, (void*)sub_table);
                ht_insert_int(sub_table, second_key, (void*)1);
                return first;
        } else {
                if (!ht_lookup_int(sub_table, second_key)) {
                        ht_insert_int(sub_table, second_key, (void*)1);
                        return first;
                }
        }
        return subsequent;
}

UNUSED static int _free_sub_table(ht_int_table_t *table,
                                  uint64 key, void *val, void *_) {
        ht_clear_int_table(table, false);
        return 0;
}

UNUSED static void _free_table(ht_int_table_t *table) {
        ht_for_each_entry_int(table, _free_sub_table, NULL);
        ht_clear_int_table(table, true);
}

UNUSED static void _memoized_recursion(const char *name) {
    _signal_critical_error("Recursive call to memoized method %s. "
                           "This is considered undefined behavior.", name);
}

typedef struct {
    bool valid;
    bool is_bank;
    bool is_array;
    const char *portname;
} _dml_attr_parent_obj_proxy_info_t;

typedef struct {
    const char *name;
    const char *type;
    const char *doc;
    conf_class_t *parent_obj_class;
    _dml_attr_parent_obj_proxy_info_t proxy_info;
    attr_attr_t flags;
    uint32 object_relative_dims;
    bool readable;
    bool writable;
    bool should_be_registered;
    bool allow_cutoff;
} _dml_attr_conf_info_t;

typedef struct {
    const _id_info_t *id_info;
    void *vtable;
    uint32 num;
    bool allow_cutoff;
} _dml_attr_getset_info_t;

UNUSED static void _DML_register_attributes(
    conf_class_t *dev_class, const _id_info_t *id_info_array,
    const _dml_port_object_assoc_t *port_object_assocs,
    const _vtable_list_t *attribute_vtables, _each_in_t sequence,
    _dml_attr_conf_info_t (*get_attribute_info)(_traitref_t),
    attr_value_t (*get_attr)(void *, conf_object_t *, attr_value_t *),
    set_error_t (*set_attr)(void *, conf_object_t *, attr_value_t *,
                            attr_value_t *),
    attr_value_t (*get_portobj_attr)(void *, conf_object_t *, attr_value_t *),
    set_error_t (*set_portobj_attr)(void *, conf_object_t *, attr_value_t *,
                            attr_value_t *)) {
    for (uint32 i = 0; i < sequence.num; ++i) {
        _vtable_list_t list = attribute_vtables[i];
        uint64 num = list.num / sequence.array_size;
        uint64 start = num * sequence.array_idx;
        _traitref_t traitref = { list.vtable,
                                 { .id = list.id, .encoded_index = start }};
        _dml_attr_conf_info_t attr_info = get_attribute_info(traitref);
        if (!attr_info.should_be_registered) {
            continue;
        }

        _dml_attr_getset_info_t attr_getset_info = {
            &id_info_array[list.id - 1],
            traitref.trait,
            num,
            attr_info.allow_cutoff
        };
        _dml_attr_getset_info_t *attr_get_info = NULL;
        if (attr_info.readable) {
            attr_get_info = MM_MALLOC(1, _dml_attr_getset_info_t);
            *attr_get_info = attr_getset_info;
        }
        _dml_attr_getset_info_t *attr_set_info = NULL;
        if (attr_info.writable) {
            attr_set_info = MM_MALLOC(1, _dml_attr_getset_info_t);
            *attr_set_info = attr_getset_info;
        }

        strbuf_t type = sb_newf("%s", attr_info.type);
        _id_info_t id_info = id_info_array[list.id - 1];
        for (uint32 i = 0; i < attr_info.object_relative_dims; ++i) {
            char *tmp_type = sb_detach(&type);
            sb_addfmt(&type,
                      attr_info.allow_cutoff ? "[%s{0:%d}]" : "[%s{%d}]",
                      tmp_type, id_info.dimsizes[id_info.dimensions - 1 - i]);
            MM_FREE(tmp_type);
        }
        conf_class_t *parent_obj_class = attr_info.parent_obj_class;
        SIM_register_typed_attribute(
            parent_obj_class ? parent_obj_class : dev_class,
            attr_info.name,
            attr_info.readable ? parent_obj_class ? get_portobj_attr : get_attr
            : NULL, attr_get_info,
            attr_info.writable ? parent_obj_class ? set_portobj_attr : set_attr
            : NULL, attr_set_info,
            attr_info.flags, sb_str(&type), NULL, attr_info.doc);

        _dml_attr_parent_obj_proxy_info_t proxy_info = attr_info.proxy_info;
        if (proxy_info.valid) {
            uint32 port_obj_offset =
                port_object_assocs[list.id - 1].port_obj_offset;
            ASSERT(port_obj_offset);
            if (proxy_info.is_array) {
                ASSERT(id_info.dimensions >= 1);
                _register_port_array_legacy_proxy_attr(
                    dev_class, parent_obj_class, port_obj_offset,
                    id_info.dimsizes[0], proxy_info.is_bank,
                    proxy_info.portname, attr_info.name, get_portobj_attr,
                    set_portobj_attr, attr_info.flags, sb_str(&type),
                    attr_info.doc,
                    attr_get_info ? attr_get_info : attr_set_info);
            } else {
                _register_port_legacy_proxy_attr(
                    dev_class, parent_obj_class, port_obj_offset,
                    proxy_info.is_bank, proxy_info.portname, attr_info.name,
                    get_portobj_attr, set_portobj_attr, attr_info.flags,
                    sb_str(&type), attr_info.doc,
                    attr_get_info ? attr_get_info : attr_set_info);
            }
        }
        sb_free(&type);
    }
}

#endif
