/*
  Â© 2021-2024 Intel Corporation
  SPDX-License-Identifier: MPL-2.0
*/
dml 1.4;
device test;

import "utility.dml";

bank registers {
    param partial = true;

    register r size 4 @ 0x0 {
        field d @ [31:24] is (read, write) {
            method read() -> (uint64) {
                return 0x0d;
            }
        }
        field c @ [23:16] is (read, write) {
            method read() -> (uint64) {
                return 0x0c;
            }
        }
        field b @ [15:8] is (read, write) {
            method read() -> (uint64) {
                return 0x0b;
            }
        }
        field a @ [7:0] is (read, write) {
            method read() -> (uint64) {
                return 0x0a;
            }
        }
    }

    register r2 size 4 @ 0x4 {
        field c @ [31:20] is (read, write) {
            method read() -> (uint64) {
                return 0x0;
            }
        }
        field b @ [19:12] is (read, write) {
            method read() -> (uint64) {
                return 0xff;
            }
        }
        field a @ [11:0] is (read, write) {
            method read() -> (uint64) {
                return 0x0;
            }
        }
    }

    method test_read() {
        local uint64 val;

        val = r.read_register(0xff, NULL);
        assert val == 0x0a;

        val = r.read_register(0xffff, NULL);
        assert val == 0x0b0a;

        val = r.read_register(0xff00, NULL);
        assert val == 0x0b00;

        val = r.read_register(0xff00ff, NULL);
        assert val == 0x0c000a;

        val = r2.read_register(0xff0000, NULL);
        assert val == 0xf0000;
    }

    method test_write() {
        r.val = 0;
        r.write_register(0x01020304, 0xff, NULL);
        assert r.val == 0x04;

        r.val = 0;
        r.write_register(0x01020304, 0xffff, NULL);
        assert r.val == 0x0304;

        r.val = 0;
        r.write_register(0x01020304, 0xff00, NULL);
        assert r.val == 0x0300;

        r.val = 0;
        r.write_register(0x01020304, 0xff00ff, NULL);
        assert r.val == 0x020004;

        r2.val = 0;
        r2.write_register(0x01020304, 0xff0000, NULL);
        assert r2.val == 0x20000;
    }

    method test() {
        test_read();
        test_write();
    }
}

bank disabled_field_invoked {
    param partial = true;

    session bool b_read = false;
    register r size 4 @ 0x0 {
        field c @ [23:16] is (read, write) {
            method read() -> (uint64) {
                return 0x0c;
            }
        }
        field b @ [15:8] is (read, write) {
            method read() -> (uint64) {
                b_read = true;
                return 0x0b;
            }
        }
        field a @ [7:0] is (read, write) {
            method read() -> (uint64) {
                return 0x0a;
            }
        }
    }

    method test() {
        try {
            local uint64 val;
            val = read(0x0, 0xff00ff, NULL);
            assert val == 0x0c000a;
            assert !b_read;
        } catch assert false;
    }
}

bank disabled_register_invoked {
    param partial = true;
    param overlapping = true;

    session bool r2_read = false;

    register r1 size 1 @ 0x0 {
        param init_val = 0x0a;
    }
    register r2 size 1 @ 0x1 {
        param init_val = 0x0b;
        method read_register(uint64 enabled_bytes,
                                  void *user) -> (uint64) {
            r2_read = true;
            return 0x0b;
        }
    }
    register r3 size 1 @ 0x2 {
        param init_val = 0x0c;
    }

    method test() {
        try {
            local uint64 val;
            val = read(0x0, 0xff00ff, NULL);

            assert val == 0x0c000a;
            assert !r2_read;
        } catch assert false;
    }
}

bank explicit_fields {
    param partial = true;

    register r size 4 @ 0x0 {
        field d @ [31:24] is (read, write) {
            method read() -> (uint64) {
                return 0x0d;
            }
        }
        field c @ [23:16] is (read, write) {
            method read() -> (uint64) {
                return 0x0c;
            }
        }
        field b @ [15:8] is (read, write) {
            method read() -> (uint64) {
                return 0x0b;
            }
        }
        field a @ [7:0] is (read, write) {
            method read() -> (uint64) {
                return 0x0a;
            }
        }
    }

    method test_read() {
        try {
            local uint64 val;

            val = read(0x0, 0xff, NULL);
            assert val == 0x0a;

            val = read(0x0, 0xffff, NULL);
            assert val == 0x0b0a;

            val = read(0x0, 0xffffff, NULL);
            assert val == 0x0c0b0a;

            val = read(0x0, 0xffffffff, NULL);
            assert val == 0x0d0c0b0a;

            val = read(0x0, 0x0, NULL);
            assert val == 0x0;

            val = read(0x0, 0xff0000ff, NULL);
            assert val == 0x0d00000a;

            val = read(0x0, 0xffff00, NULL);
            assert val == 0x000c0b00;
        } catch assert false;
    }

    method test_write() {
        try {
            r.val = 0;
            write(0x0, 0x01020304, 0xff, NULL);
            assert r.val == 0x04;

            r.val = 0;
            write(0x0, 0x01020304, 0xffff, NULL);
            assert r.val == 0x0304;

            r.val = 0;
            write(0x0, 0x01020304, 0xffffff, NULL);
            assert r.val == 0x020304;

            r.val = 0;
            write(0x0, 0x01020304, 0xffffffff, NULL);
            assert r.val == 0x01020304;

            r.val = 0;
            write(0x0, 0x01020304, 0x0, NULL);
            assert r.val == 0x0;

            r.val = 0;
            write(0x0, 0x01020304, 0xff0000ff, NULL);
            assert r.val == 0x01000004;

            r.val = 0;
            write(0x0, 0x01020304, 0xffff00, NULL);
            assert r.val == 0x00020300;
        } catch assert false;
    }

    method test() {
        test_read();
        test_write();
    }
}

bank ignored_enabled {
    param partial = true;

    register r size 4 @ 0x0 {
        method read_register(uint64 enabled_bytes,
                                  void *user) -> (uint64) {
            return 0xffffffff;
        }
    }

    method test() {
        local uint64 val;
        try {
            val = read(0x0, 0xff00, NULL);
        } catch assert false;
        assert val == 0xff00;
    }
}

bank implicit_fields {
    register r1 size 4 @ 0x0 {
        param init_val = 0x0d0c0b0a;
    }

    register r2 size 4 @ 0x4 {
        param init_val = 0x000c0b00;

        field d @ [31:24] is (read, write) {
            method read() -> (uint64) {
                return 0x0d;
            }
        }
        field a @ [7:0] is (read, write) {
            method read() -> (uint64) {
                return 0x0a;
            }
        }
    }

    method test_register(uint64 offset) {
        try {
            local uint64 val;

            val = read(offset, 0x0, NULL);
            assert val == 0x0;

            val = read(offset, 0xffffffff, NULL);
            assert val == 0x0d0c0b0a;

            val = read(offset, 0xff0000ff, NULL);
            assert val == 0x0d00000a;
        } catch assert false;
    }

    method test() {
        test_register(0x0);
        test_register(0x4);
    }
}

bank overlapping {
    param partial = true;
    param overlapping = true;

    register r1 size 4 @ 0x0 {
        param init_val = 0x0d0c0b0a;
        field d @ [31:24] is (read, write) {}
        field c @ [23:16] is (read, write) {}
        field b @ [15:8] is (read, write) {}
        field a @ [7:0] is (read, write) {}
    }
    register r2 size 4 @ 0x4 {
        param init_val = 0x04030201;
        field d @ [31:24] is (read, write) {}
        field c @ [23:16] is (read, write) {}
        field b @ [15:8] is (read, write) {}
        field a @ [7:0] is (read, write) {}
    }

    method test_read() {
        local uint64 val;
        try {
            val = read(0x2, 0xffffffff, NULL);
        } catch assert false;
        assert val == 0x02010d0c;
    }

    method test_write() {
        r1.val = r2.val = 0;

        try {
            write(0x2, 0x02010d0c, 0xffffffff, NULL);
        } catch assert false;
        assert r1.val == 0x0d0c0000;
        assert r2.val == 0x0201;
    }

    method test() {
        test_read();
        test_write();
    }
}

bank unmapped {
    param overlapping = true;
    param partial = true;

    register r1 size 1 @ 0x0 {
        param init_val = 0x0a;
    }

    register r2 size 1 @ 0x2 {
        param init_val = 0x0c;
    }

    method unmapped_read(uint64 offset, uint64 bits, void *user)
        -> (uint64) throws default {
        return 0x000b00;
    }

    method test() {
        local uint64 val;
        try {
            val = read(0x0, 0xffffff, NULL);
        } catch assert false;
        assert val == 0x0c0b0a;
    }
}

method init() {
    registers.test();

    disabled_field_invoked.test();
    disabled_register_invoked.test();
    explicit_fields.test();
    ignored_enabled.test();
    implicit_fields.test();
    overlapping.test();
    unmapped.test();
}
