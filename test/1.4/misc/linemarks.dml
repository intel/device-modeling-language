/*
  Â© 2024 Intel Corporation
  SPDX-License-Identifier: MPL-2.0
*/

dml 1.4;

device test;

/// COMPILE-ONLY

// This test is mainly descriptive, not prescriptive, of which DML lines have
// C lines directed to them (and from where). If the tests fails due to a
// change, don't be afraid to modify this test past the
// "**End of explanatory test cases**". This is particularly true of
// test_brace_linemarks().

// Linemarks to DML should only be generated where it makes "make sense."
// The definition of this is loose, but in most contexts bears the necessary
// (but not always sufficient) requirement that a particular C line *must only*
// be redirected to a DML line if:
// 1. Some part of the DML line is describing (a part of) a run-operation
//    through it being (part of) an expression, statement, or explicit
//    initializer.
// 2. The C line is a component of (the part of) the operation described in
//    the DML line
//
// Any C line for which it makes sense to redirect to a DML line should be,
// barring the implementation effort being unreasonable compared to the
// expected gain. Sometimes, a C line can reasonably correspond to multiple DML
// lines, and so will raise the question of which DML line should be chosen
// as the linemark target. This question can only be answered on a case-by-case
// basis. Typically, picking the first DML line that qualifies makes most
// sense.
//
// See the test cases of this file for explanatory examples re. what generated
// C lines it "makes sense" to redirect to DML.

// Explanation of the test-specific annotations:
//
// The `// BEGIN-LINEMARKS-CBLOCK` or `// BEGIN-LINEMARKS-FUNC` annotation,
// together with `// END-LINEMARKS`, delimits a block of DML lines which are
// expected to be targets of line directives in generated C. The test fails if
// any line in generated C is redirected to a line of this file outside of a
// linemarks block.
//
// `// BEGIN-LINEMARKS-CBLOCK` delimits a block of DML lines representing
// verbatim C. It tests that there is a chunk of contiguous C lines at the
// top-level (outside generated functions) that are redirected to the lines of
// the linemarks block. The test fails if any DML line of the block is not
// covered, or is not part of a contiguous chunk.
//
// `// BEGIN-LINEMARKS-FUNC ...` delimits a block of DML lines which are
// generated to statements of C functions. The annotation must specify a
// space-delimited list of what generated C functions in which linemarks to the
// DML lines of the block are expected; the test fails if any DML line of the
// block is covered outside of the specified C functions. The test also fails
// if any DML line of the block is *not* covered in each of the specified C
// functions, unless that DML line is either:
// * empty
// * a line comment (including annotations)
// * annotated with `// NOT-LINEMARKED` in the preceding line
// in which case the test will instead fail if the line is ever covered at all.


// The only exception to the stated necessary requirements for C lines to be
// redirected to DML is when the DML line itself is verbatim C, by means of a
// footer or header block. In such cases the C line should always be redirected
// to the DML line no matter what the C line is.
//
// The whitespace before %} is important for the test logic to work; it causes
// that line get its dedicated line in generated C, instead of it being omitted

// BEGIN-LINEMARKS-CBLOCK
header %{


 %}
// END-LINEMARKS


// BEGIN-LINEMARKS-CBLOCK
footer %{



 %}
// END-LINEMARKS

template u {
    // The most clear-cut examples of where redirection makes sense are C lines
    // generated by written DML statements within methods.
    //
    // If the method definition gets its dedicated generated C function (as
    // opposed to being inlined), then the opening and closing braces of that
    // function are also redirected to the opening and closing braces of the
    // method.
    shared method s_m() default
    // BEGIN-LINEMARKS-FUNC _DML_TM_u__s_m
    {
        assert true;
    }
    // END-LINEMARKS
}

template t is u {
    // C statements that do *not* correspond to DML statements, or correspond
    // to DML statements injected into methods by DMLC, should *not* be
    // redirected to DML.
    // One example of this is the implicit trait reference downcast injected
    // into shared method overrides. These should not receive linemarks to DML.
    shared method s_m()
    // BEGIN-LINEMARKS-FUNC _DML_TM_t__s_m
    {
    }
    // END-LINEMARKS

    // Another example of code that should not redirected to DML is injected
    // prelude code of memoized methods, as well as implicit startup calls.
    // This highlights an important part of requirement (1): one could argue
    // that the prelude code corresponds to the use of 'memoized', but since
    // 'memoized' is just a declaration modifier, it cannot be said to
    // *describe* any operation performed by the prelude code in the same way
    // statements, expressions, and initializers describe the operations
    // generated from them.
    // Hence, that argument cannot be used to justify redirecting the prelude
    // code to the line with 'memoized'.
    shared independent startup memoized method s_memo_startup()
        -> (int, bool, float)
    // BEGIN-LINEMARKS-FUNC _DML_TM_t__s_memo_startup
    {
        return (4, true, 4.7);
    }
    // END-LINEMARKS
}

independent startup memoized method memo_startup() -> (int, bool, float)
// BEGIN-LINEMARKS-FUNC _DML_M_memo_startup
{
    return (4, true, 4.7);
}
// END-LINEMARKS


// dead methods receive no linemarks at all
method dead() {
    assert true;
}

// Explicit initializer describes a run-time operation: namely how the
// session/saved variable should be initialized. Indeed, due to how
// initializers in DMLC work, the initialization operation is entirely
// determined by the choice of initializer (for the particular type of the
// variable).
// Hence it makes sense to redirect the C line that performs the initialization
// to the DML line with the initializer.
saved int sav_1 =
// BEGIN-LINEMARKS-FUNC _init_data_objs
    4;
// END-LINEMARKS

// no linemarks; no explicit initializer
saved int sav_2;

// **End of explanatory test cases**
// Remainder of tests describe various edge-cases for what lines receive
// linemarks today, and should be considered more malleable.

// Methods that are only inlined don't get linemarks for the braces, and
// linemarks for their statements appear within the C functions for the methods
// in which they are inlined.
inline method inline_m(inline x) -> (int) {
    // BEGIN-LINEMARKS-FUNC _DML_M_init test_deinit
    return x + 4;
    // END-LINEMARKS
}

// destroy() is the only overridable method in DML 1.4 which is ad-hoc invoked
// by DMLC via a codegen_inline_byname, and can possibly never be called
// otherwise.
method destroy() {
    // BEGIN-LINEMARKS-FUNC test_deinit
    local int x;
    x = inline_m(x);
    assert x == 4;
    // END-LINEMARKS
}

method init()
// BEGIN-LINEMARKS-FUNC _DML_M_init
{

    local uint32 x = 4;
    // Linemark of do-while's "while" line is based on the condition expression
    do
        --x;
    // NOT-LINEMARKED
    while (
        x != 0
    // NOT-LINEMARKED
    );

    // Each inline param declaration has the site of its corresponding arg.
    x = inline_m(
        x
        // NOT-LINEMARKED
        );
    assert x == 7;
    // ... except for constant arguments, as variable declaration are not
    // generated for them, and they are instead propagated directly
    x = inline_m(
        // NOT-LINEMARKED
        3);
    assert x == 7;

    // members of struct declarations are linemarked
    local
      // NOT-LINEMARKED
      struct {
        int
        // NOT-LINEMARKED
            member;
        struct {
            int substruct_member;
        // NOT-LINEMARKED
        } m2;
    // NOT-LINEMARKED
    } y;

    test_brace_linemarks();
}
// END-LINEMARKS

method test_brace_linemarks()
// BEGIN-LINEMARKS-FUNC _DML_M_test_brace_linemarks
{
    // Compound.toc() omits braces when there are no declarations
    // NOT-LINEMARKED
    {
        assert true;
        assert true;
    // NOT-LINEMARKED
    }

    // .toc() of empty compounds and null statements emits no C statements
    // NOT-LINEMARKED
    {}
    // NOT-LINEMARKED
    ;
    if (true)
    // mkCompound reduces a compound with a single statement to that statement
    // NOT-LINEMARKED
    {
        assert true;
    // NOT-LINEMARKED
    }

    // ... Unless it contains a declaration.
    {
        local int y;
    }

    if (true)
    // multiple inner statements -- outermost mkCompound not collapsed
    {
        // inner Compounds are collapsed though, and made part of the outer
        // NOT-LINEMARKED
        {
            assert true;
            assert true;
        // NOT-LINEMARKED
        }
        // ... unless they contain a declaration
        {
            assert true;
            local int x;
        }
    }

    if (true)
    // Though in generated C you can observe braces, these stem from
    // .toc_stmt() of the inner if statement. They do not come from the
    // compound statement. That still gets collapsed.
    // NOT-LINEMARKED
    {
        if (true)
        {
        }
    // NOT-LINEMARKED
    }
    // else gets a dedicated linemark
    else
    ;
    // the "try" and "catch" keywords never get any linemarks
    // NOT-LINEMARKED
    try
    {
        local int y = 4;
        throw;
    }
    // NOT-LINEMARKED
    catch
    // TryCatch uses .toc() of the catch block if the try block cannot
    // fallthrough, so the braces get omitted.
    // However, the throw label still uses the site of the catch statement,
    // meaning the opening brace DOES get a linemark to it, even though it
    // itself is not emitted
    {
        assert true;
        assert true;
    // NOT-LINEMARKED
    }

    // NOT-LINEMARKED
    try
    // mkCompound collapse applies here.
    // NOT-LINEMARKED
    {
        if (false)
            throw;
    // NOT-LINEMARKED
    }
    // NOT-LINEMARKED
    catch
    // TryCatch uses .toc_stmt() of the catch block if the try block could
    // fallthrough.
    {
        assert true;
        assert true;
    }
}
// END-LINEMARKS
