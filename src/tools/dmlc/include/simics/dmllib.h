/*
  Â© 2010-2021 Intel Corporation
  SPDX-License-Identifier: 0BSD
*/

/* DML runtime utilities needed by the C code generated by dmlc */

#ifndef SIMICS_DMLLIB_H
#define SIMICS_DMLLIB_H

#include <stddef.h>

#include <simics/base/types.h>
#include <simics/base/log.h>
#include <simics/base/conf-object.h>
#include <simics/base/version.h>
#include <simics/util/swabber.h>
#include <simics/model-iface/bank-instrumentation.h>
#include <simics/simulator/conf-object.h>
#include <simics/util/alloc.h>
#include <simics/util/hashtab.h>
#include <simics/util/help-macros.h>
#include <simics/util/strbuf.h>
#include <simics/util/swabber.h>

// Copy bits from y given by mask into corresponding bits in x and return the
// result
static inline uint64 DML_combine_bits(uint64 x, uint64 y, uint64 mask)
{
        return (x & ~mask) | (y & mask);
}

#define DML_ASSERT(filename, lineno, expr) do {         \
    if (unlikely(!(expr)))                              \
        assert_error((lineno), (filename), "", NULL);   \
} while (0)

static inline uint64 DML_shlu(uint64 a, uint64 b)
{
        return b > 63 ? 0 : a << b;
}

UNUSED static void
_DML_fault(const char *filename, int lineno, const char *msg)
{
        // Need SIM_get_api_function indirection to work with old 6 base
        // packages.
        // TODO: use VT_critical_error directly in simics 7
        void (*critical_error)(const char *, const char *)
                = (void (*)(const char *, const char *))SIM_get_api_function(
                        "VT_critical_error");
        if (critical_error) {
                char long_msg[256];
                snprintf(long_msg, 256, "%s:%d: %s", filename, lineno, msg);
                critical_error(msg, long_msg);
        } else {
                assert_error(lineno, filename, "", msg);
        }
}

static inline int64 DML_shl(int64 a, int64 b, const char *filename, int lineno)
{
        if (unlikely(b < 0)) {
                _DML_fault(filename, lineno, "negative shift count");
                return 0;
        }
        return b > 63 ? 0 : (uint64)a << b;
}

static inline uint64 DML_shru(uint64 a, uint64 b)
{
        return b > 63 ? 0 : a >> b;
}

static inline int64 DML_shr(int64 a, int64 b, const char *filename, int lineno)
{
        if (unlikely(b < 0)) {
                _DML_fault(filename, lineno, "negative shift count");
                return 0;
        }
        return b > 63 ? (a > 0 ? 0 : -1) : a >> b;
}

static inline uint64 DML_divu(uint64 a, uint64 b,
                              const char *filename, int lineno)
{
        if (unlikely(b == 0)) {
                _DML_fault(filename, lineno, "integer division by zero");
                return 0;
        }
        return a / b;
}

static inline int64 DML_div(int64 a, int64 b, const char *filename, int lineno)
{
        if (unlikely(b == 0)) {
                _DML_fault(filename, lineno, "integer division by zero");
                return 0;
        }
        return a / b;
}

static inline uint64 DML_modu(uint64 a, uint64 b,
                              const char *filename, int lineno)
{
        if (unlikely(b == 0)) {
                _DML_fault(filename, lineno, "integer modulo by zero");
                return 0;
        }
        return a % b;
}

static inline int64 DML_mod(int64 a, int64 b, const char *filename, int lineno)
{
        if (unlikely(b == 0)) {
                _DML_fault(filename, lineno, "integer modulo by zero");
                return 0;
        }
        return a % b;
}

static inline bool
DML_lt_iu(int64 a, uint64 b)
{
        return (uint64)a < b || ((a | b) >> 63);
}

static inline bool
DML_lt_ui(uint64 a, int64 b)
{
        return a < (uint64)b && !((a | b) >> 63);
}

static inline bool
DML_leq_iu(int64 a, uint64 b)
{
        return (uint64)a <= b || ((a | b) >> 63);
}

static inline bool
DML_leq_ui(uint64 a, int64 b)
{
        return a <= (uint64)b && !((a | b) >> 63);
}

// compare signed and unsigned: return true if bits are equal and neither sign
// bit is set
static inline bool
DML_eq(uint64 a, uint64 b)
{
        return ((a ^ b) | ((b | a) >> 63)) == 0;
}

// Downcast a trait vtable expression expr to the vtable type of trait 'to',
// given that expr's type is found as to.ancestry. E.g.: If a trait y extends
// z, and x extends y, and xyz is a reference to trait x (i.e., has type
// (x *)), then DOWNCAST(xyz, x, y.z) yields a reference to the x trait,
// and DOWNCAST(xyz, x, y.z)->y.z == xyz.
// This is similar to the container_of macro in Linux.
#define DOWNCAST(expr, to, ancestry) \
        ((to *)((char *)(expr) - offsetof(to, ancestry)))

#define CALL_TRAIT_METHOD(type, method, dev, trait, ...)    \
        ({type __tref = trait; __tref->method(dev, __tref, __VA_ARGS__);})
#define CALL_TRAIT_METHOD0(type, method, dev, trait)    \
        ({type __tref = trait; __tref->method(dev, __tref);})

#define _raw_load_uint8_be_t   UNALIGNED_LOAD_BE8
#define _raw_load_uint16_be_t  UNALIGNED_LOAD_BE16
#define _raw_load_uint32_be_t  UNALIGNED_LOAD_BE32
#define _raw_load_uint64_be_t  UNALIGNED_LOAD_BE64
#define _raw_load_uint8_le_t   UNALIGNED_LOAD_LE8
#define _raw_load_uint16_le_t  UNALIGNED_LOAD_LE16
#define _raw_load_uint32_le_t  UNALIGNED_LOAD_LE32
#define _raw_load_uint64_le_t  UNALIGNED_LOAD_LE64
#define _raw_store_uint8_be_t  UNALIGNED_STORE_BE8
#define _raw_store_uint16_be_t UNALIGNED_STORE_BE16
#define _raw_store_uint32_be_t UNALIGNED_STORE_BE32
#define _raw_store_uint64_be_t UNALIGNED_STORE_BE64
#define _raw_store_uint8_le_t  UNALIGNED_STORE_LE8
#define _raw_store_uint16_le_t UNALIGNED_STORE_LE16
#define _raw_store_uint32_le_t UNALIGNED_STORE_LE32
#define _raw_store_uint64_le_t UNALIGNED_STORE_LE64

static inline int8
_raw_load_int8_be_t(const void *addr)
{
        return (int8)_raw_load_uint8_be_t(addr);
}

static inline int16
_raw_load_int16_be_t(const void *addr)
{
        return (int16)_raw_load_uint16_be_t(addr);
}

static inline int32
_raw_load_int32_be_t(const void *addr)
{
        return (int32)_raw_load_uint32_be_t(addr);
}

static inline int64
_raw_load_int64_be_t(const void *addr)
{
        return (int64)_raw_load_uint64_be_t(addr);
}

static inline int8
_raw_load_int8_le_t(const void *addr)
{
        return (int8)_raw_load_uint8_le_t(addr);
}

static inline int16
_raw_load_int16_le_t(const void *addr)
{
        return (int16)_raw_load_uint16_le_t(addr);
}

static inline int32
_raw_load_int32_le_t(const void *addr)
{
        return (int32)_raw_load_uint32_le_t(addr);
}

static inline int64
_raw_load_int64_le_t(const void *addr)
{
        return (int64)_raw_load_uint64_le_t(addr);
}

static inline uint32
_raw_load_uint24_be_t(const void *addr)
{
        return _raw_load_uint8_be_t(addr) << 16 |
                _raw_load_uint16_be_t((char *)addr + 1);
}

static inline int32
_raw_load_int24_be_t(const void *addr)
{
        return ((int32)_raw_load_uint24_be_t(addr) << 8) >> 8;
}

static inline void
_raw_store_uint24_be_t(void *addr, uint32 v)
{
        _raw_store_uint8_be_t(addr, v >> 16);
        _raw_store_uint16_be_t((char *)addr + 1, v & 0xffff);
}

static inline uint64
_raw_load_uint40_be_t(const void *addr)
{
        return (uint64)_raw_load_uint8_be_t(addr) << 32
               | _raw_load_uint32_be_t((char *)addr + 1);
}

static inline int64
_raw_load_int40_be_t(const void *addr)
{
        return ((int64)_raw_load_uint40_be_t(addr) << 24) >> 24;
}

static inline void
_raw_store_uint40_be_t(void *addr, uint64 v)
{
        _raw_store_uint8_be_t(addr, v >> 32);
        _raw_store_uint32_be_t((char *)addr + 1, v & 0xffffffff);
}

static inline uint64
_raw_load_uint48_be_t(const void *addr)
{
        return (uint64)_raw_load_uint16_be_t(addr) << 32
               | _raw_load_uint32_be_t((char *)addr + 2);
}

static inline int64
_raw_load_int48_be_t(const void *addr)
{ return ((int64)_raw_load_uint48_be_t(addr) << 16) >> 16; }

static inline void
_raw_store_uint48_be_t(void *addr, uint64 v)
{
        _raw_store_uint16_be_t(addr, v >> 32);
        _raw_store_uint32_be_t((char *)addr + 2, v & 0xffffffff);
}

static inline uint64
_raw_load_uint56_be_t(const void *addr)
{
        return (uint64)_raw_load_uint24_be_t(addr) << 32
               | _raw_load_uint32_be_t((char *)addr + 3);
}

static inline int64
_raw_load_int56_be_t(const void *addr)
{ return ((int64)_raw_load_uint56_be_t(addr) << 8) >> 8; }

static inline void
_raw_store_uint56_be_t(void *addr, uint64 v)
{
        _raw_store_uint24_be_t(addr, v >> 32);
        _raw_store_uint32_be_t((char *)addr + 3, v & 0xffffffff);
}

static inline uint32
_raw_load_uint24_le_t(const void *addr)
{
        return _raw_load_uint8_le_t((char *)addr + 2) << 16 |
                _raw_load_uint16_le_t(addr);
}

static inline int32
_raw_load_int24_le_t(const void *addr)
{
        return ((int32)_raw_load_uint24_le_t(addr) << 8) >> 8;
}

static inline void
_raw_store_uint24_le_t(void *addr, uint32 v)
{
        _raw_store_uint8_le_t((char *)addr + 2, v >> 16);
        _raw_store_uint16_le_t(addr, v & 0xffff);
}

static inline uint64
_raw_load_uint40_le_t(const void *addr)
{
        return (uint64)_raw_load_uint8_le_t((char *)addr + 4) << 32
               | _raw_load_uint32_le_t(addr);
}

static inline int64
_raw_load_int40_le_t(const void *addr)
{
        return ((int64)_raw_load_uint40_le_t(addr) << 24) >> 24;
}

static inline void
_raw_store_uint40_le_t(void *addr, uint64 v)
{
        _raw_store_uint8_le_t((char *)addr + 4, v >> 32);
        _raw_store_uint32_le_t(addr, v & 0xffffffff);
}

static inline uint64
_raw_load_uint48_le_t(const void *addr)
{
        return (uint64)_raw_load_uint16_le_t((char *)addr + 4) << 32
               | _raw_load_uint32_le_t(addr);
}

static inline int64
_raw_load_int48_le_t(const void *addr)
{
        return ((int64)_raw_load_uint48_le_t(addr) << 16) >> 16;
}

static inline void
_raw_store_uint48_le_t(void *addr, uint64 v)
{
        _raw_store_uint16_le_t((char *)addr + 4, v >> 32);
        _raw_store_uint32_le_t(addr, v & 0xffffffff);
}

static inline uint64
_raw_load_uint56_le_t(const void *addr)
{
        return (uint64)_raw_load_uint24_le_t((char *)addr + 4) << 32
               | _raw_load_uint32_le_t(addr);
}

static inline int64
_raw_load_int56_le_t(const void *addr)
{
        return ((int64)_raw_load_uint56_le_t(addr) << 8) >> 8;
}

static inline void
_raw_store_uint56_le_t(void *addr, uint64 v)
{
        _raw_store_uint24_le_t((char *)addr + 4, v >> 32);
        _raw_store_uint32_le_t(addr, v & 0xffffffff);
}

// Define signed aliases for raw store, used in macros later
#define _raw_store_int8_be_t _raw_store_uint8_be_t
#define _raw_store_int16_be_t _raw_store_uint16_be_t
#define _raw_store_int24_be_t _raw_store_uint24_be_t
#define _raw_store_int32_be_t _raw_store_uint32_be_t
#define _raw_store_int40_be_t _raw_store_uint40_be_t
#define _raw_store_int48_be_t _raw_store_uint48_be_t
#define _raw_store_int56_be_t _raw_store_uint56_be_t
#define _raw_store_int64_be_t _raw_store_uint64_be_t
#define _raw_store_int8_le_t _raw_store_uint8_le_t
#define _raw_store_int16_le_t _raw_store_uint16_le_t
#define _raw_store_int24_le_t _raw_store_uint24_le_t
#define _raw_store_int32_le_t _raw_store_uint32_le_t
#define _raw_store_int40_le_t _raw_store_uint40_le_t
#define _raw_store_int48_le_t _raw_store_uint48_le_t
#define _raw_store_int56_le_t _raw_store_uint56_le_t
#define _raw_store_int64_le_t _raw_store_uint64_le_t

// macro definitions for endian types
#define FOR_ALL_BITSIZES(x, s, ed) \
        x(8, s, ed) x(16, s, ed)   \
        x(24, s, ed) x(32, s, ed)  \
        x(40, s, ed) x(48, s, ed)  \
        x(56, s, ed) x(64, s, ed)
#define FOR_ENDIAN_VARIANTS(x)                                 \
        FOR_ALL_BITSIZES(x, u, be) FOR_ALL_BITSIZES(x, u, le)  \
        FOR_ALL_BITSIZES(x, , be) FOR_ALL_BITSIZES(x, , le)

// declare endian types
#define DECLARE_ENDIAN_TYPE(size, sign, endian)                     \
        typedef struct { uint8 bytes[size/8]; }                 \
                sign ## int ## size ## _ ## endian ## _ ## t ;

FOR_ENDIAN_VARIANTS(DECLARE_ENDIAN_TYPE);

#undef DECLARE_ENDIAN_TYPE
#undef FOR_ALL_BITSIZES
#undef FOR_ENDIAN_VARIANTS

#define FOR_ALL_BITSIZES(x, sign, endian)               \
        x(int ## 64, sign ## int ## 8 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 16 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 24 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 32 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 40 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 48 ## _ ## endian ## _ ## t) \
        x(int ## 64, sign ## int ## 56 ## _ ## endian ## _ ## t)

#define FOR_ENDIAN_VARIANTS(x)                                    \
        FOR_ALL_BITSIZES(x, , be) FOR_ALL_BITSIZES(x, , le)       \
        FOR_ALL_BITSIZES(x, u, be) FOR_ALL_BITSIZES(x, u, le)     \
        x(uint ## 64, uint ## 64_le_t) x(uint ## 64, uint ## 64_be_t) \
        x(int ## 64, int ## 64_le_t) x(int ## 64, int ## 64_be_t)

#define DEFINE_ENDIAN_LOAD(inttype, endiantype)             \
        static inline inttype                           \
        dml_load_ ## endiantype (const endiantype eint) \
        {                                               \
            return _raw_load_ ## endiantype             \
                ((void *)&(eint.bytes));                \
        };

FOR_ENDIAN_VARIANTS(DEFINE_ENDIAN_LOAD)

#undef DEFINE_ENDIAN_LOAD

#define DEFINE_ENDIAN_STORE(inttype, endiantype)                             \
        static inline endiantype                                         \
        dml_store_ ## endiantype ( inttype val )                         \
        {                                                                \
                endiantype toret;                                        \
                _raw_store_ ## endiantype ((void *)&(toret.bytes), val); \
                return toret;                                            \
        }

FOR_ENDIAN_VARIANTS(DEFINE_ENDIAN_STORE);
#undef DEFINE_ENDIAN_LOAD

// x = y is translated to dml_copy_T(&x, y) for endian types
#define DEFINE_ENDIAN_COPY(inttype, endiantype) \
        static inline endiantype \
        dml_copy_ ## endiantype ( endiantype *dest, endiantype val ) \
        { memcpy(dest, &val, sizeof(endiantype)); return val; }
FOR_ENDIAN_VARIANTS(DEFINE_ENDIAN_COPY);
#undef DEFINE_ENDIAN_COPY

#define DEFINE_PRECHANGE(inttype, endiantype)                           \
        static inline inttype                                           \
        dml_prechange_ ## endiantype (endiantype *addr, int change,     \
                                      bool post) {                      \
                uint64 orig = dml_load_ ## endiantype (*addr);          \
                *addr = dml_store_ ## endiantype(orig + change);        \
                return post ? orig : dml_load_ ## endiantype (*addr);   \
        }

FOR_ENDIAN_VARIANTS(DEFINE_PRECHANGE);
#undef DEFINE_PRECHANGE

#undef FOR_ALL_BITSIZES
#undef FOR_ENDIAN_VARIANTS

// List of vtables of a specific trait in one specific object
typedef struct {
        // first trait vtable instance. Instances are stored linearly in a
        // possibly multi-dimensional array, with outer index corresponding to
        // index of outer DML object.
        uintptr_t base;
        // total number of elements (product of object's dimsizes)
        int num;
        // offset between two vtable instances; at least sizeof(<vtable type>)
        int offset;
} _vtable_list_t;

typedef struct {
        const _vtable_list_t *base;
        // iteration interval in list of vtable_list_t. Interval includes start
        // point but not endpoint. starti is currently always 0.
        int starti;
        int endi;
        // When iterating inside an array, the vtable_list_t instances show
        // number of elements globally. If one or more outer object array index
        // is fixed in the 'in each' expression, then these members show which
        // subset to iterate through from each vtable_list_t: Iteration in a
        // vtable_array_t starts at array_idx * num/array_size, and we iterate
        // through num/array_size elements.
        int array_idx;
        int array_size;
} _each_in_t;

UNUSED static uint64 _count_eachin(_each_in_t each_in) {
        int count = 0;
        for (int i = each_in.starti; i < each_in.endi; ++i) {
                count += each_in.base[i].num / each_in.array_size;
        }
        return count;
}

UNUSED static void
_DML_register_subobj_connect(conf_class_t *cls,
                             const char *classname, const char *port,
                             const char *desc)
{
        conf_class_t *port_cls = SIM_get_class(classname);
        if (port_cls == NULL) {
                char short_buf[256];
                snprintf(short_buf, 256, "Class '%s' not found", classname);
                char long_buf[256];
                snprintf(long_buf, 256,
                         "Failed to look up class '%s'"
                         " when registering port '%s'"
                         " in class '%s'", classname, port,
                         SIM_get_class_name(cls));
                VT_critical_error(short_buf, long_buf);
                return;
        }
        SIM_register_port(cls, port, port_cls, desc);
}

typedef struct {
        conf_object_t obj;
        conf_object_t *dev;
        int ndims;
        const uint32 *indices;
} _port_object_t;

UNUSED static conf_object_t *
_port_class_alloc_object(lang_void *data)
{
        return (conf_object_t *)MM_ZALLOC(1, _port_object_t);
}
UNUSED static lang_void *
_port_class_init_object(conf_object_t *obj, lang_void *data)
{
        _port_object_t *po = (_port_object_t *)obj;
        if (po->dev == NULL) {
                // can happen when restoring a checkpoint after reducing an
                // object array size
                SIM_LOG_ERROR(obj, 0, "Port object not recognized by parent");
                return NULL;
        }
        return obj;
}
UNUSED static int
_port_class_delete_instance(conf_object_t *obj)
{
        MM_FREE(obj);
        return 0;
}
UNUSED static conf_class_t *
_register_port_class(const char *name, const char *desc, const char *doc) {
        class_data_t cd = {
                .alloc_object = _port_class_alloc_object,
                .init_object = _port_class_init_object,
                .delete_instance = _port_class_delete_instance,
                .description = doc,
                .class_desc = desc,
        };
        return SIM_register_class(name, &cd);
}

UNUSED static conf_object_t *
_init_port_object(conf_object_t *dev, const char *portname, int ndims,
                  const uint32 *indices)
{
        _port_object_t *po = (_port_object_t *)SIM_object_descendant(
                dev, portname);
        ASSERT(po != NULL);
        po->dev = dev;
        po->ndims = ndims;
        po->indices = indices;
        return &po->obj;
}

/*
Before Simics 6, there were no port objects, so attributes in ports and banks
were registered on the device object using the name <portname>_<attrname>.  In
Simics 6, attributes are instead registered on the port object, but with a
proxy pseudo attribute registered on the device object for compatibility.

There are two functions for registering an attribute on a port class, with a
proxy on the device class: _register_port_attr registers an attribute on a
single port, and _register_port_array_attr registers an attribute on a
one-dimensional port array. Multi-dimensional port arrays don't exist in 5 and
thus don't need proxy attributes.
*/
typedef struct {
        ptrdiff_t port_obj_offset;
        const char *attrname;
        get_attr_t get;
        set_attr_t set;
} _port_attr_t;
static attr_value_t
_getattr_from_portobj(lang_void *ptr, conf_object_t *obj, attr_value_t *idx)
{
        ASSERT(SIM_attr_is_nil(*idx));
        _port_attr_t *port = (_port_attr_t *)ptr;
        conf_object_t *portobj = *(conf_object_t **)(
                (uintptr_t)obj + port->port_obj_offset);
        return port->get(NULL, portobj, NULL);
}
static set_error_t
_setattr_from_portobj(lang_void *ptr, conf_object_t *obj, attr_value_t *val,
                      attr_value_t *idx)
{
        ASSERT(SIM_attr_is_nil(*idx));
        _port_attr_t *port = (_port_attr_t *)ptr;
        conf_object_t *portobj = *(conf_object_t **)(
                (uintptr_t)obj + port->port_obj_offset);
        if (port->attrname == NULL || SIM_object_is_configured(portobj)) {
                return port->set(NULL, portobj, val, NULL);
        } else {
                // port attribute is registered as required; need to propagate
                // value through API call to fulfil requirement
                return SIM_set_attribute_default(portobj, port->attrname, *val);
        }
}

UNUSED static void
_register_port_attr_no_aux(conf_class_t *portcls, const char *attrname,
                           get_attr_t getter, set_attr_t setter,
                           attr_attr_t attr, const char *type, const char *desc)
{
        SIM_register_typed_attribute(
                portcls, attrname, getter, NULL, setter, NULL,
                attr, type, NULL, desc);
}

// port_obj_offset is the offset within the device struct of a pointer to the
// port object.
UNUSED static void
_register_port_attr(conf_class_t *devcls, conf_class_t *portcls,
                    ptrdiff_t port_obj_offset, bool is_bank,
                    const char *portname, const char *attrname,
                    get_attr_t getter, set_attr_t setter,
                    attr_attr_t attr, const char *type, const char *desc)
{
        _register_port_attr_no_aux(portcls, attrname,
                getter, setter, attr, type, desc);
        _port_attr_t *data = MM_MALLOC(1, _port_attr_t);
        data->port_obj_offset = port_obj_offset;
        if ((attr & Sim_Attr_Flag_Mask) == Sim_Attr_Required) {
                ASSERT(setter);
                data->attrname = MM_STRDUP(attrname);
        } else {
                data->attrname = NULL;
        }
        data->get = getter;
        data->set = setter;
        char name[strlen(portname) + strlen(attrname) + 2];
        sprintf(name, "%s_%s", portname, attrname);
        strbuf_t proxy_desc = sb_newf(
                "Proxy attribute for %s.%s.%s",
                is_bank ? "bank" : "port", portname, attrname);
        SIM_register_typed_attribute(
                devcls, name,
                getter ? _getattr_from_portobj : NULL, data,
                setter ? _setattr_from_portobj : NULL, data,
                (attr_attr_t)(Sim_Attr_Pseudo | Sim_Attr_Internal),
                type, NULL, sb_str(&proxy_desc));
        sb_free(&proxy_desc);
}

typedef struct {
        ptrdiff_t port_obj_base_offset;
        get_attr_t get;
        set_attr_t set;
        uint32 array_size;
        uint32 array_delta;
} _port_array_attr_t;
static attr_value_t
_getattr_from_portobj_array(lang_void *ptr, conf_object_t *obj,
                            attr_value_t *idx)
{
        ASSERT(SIM_attr_is_nil(*idx));
        _port_array_attr_t *port = (_port_array_attr_t *)ptr;
        uintptr_t port_obj_ptr_base = (uintptr_t)obj
                + port->port_obj_base_offset;
        attr_value_t vals = SIM_alloc_attr_list(port->array_size);
        for (uint32 i = 0; i < port->array_size; i++) {
                conf_object_t *port_obj = *(conf_object_t **)(
                        port_obj_ptr_base + (uint64)i * port->array_delta);
                attr_value_t val = port->get(NULL, port_obj, NULL);
                if (SIM_attr_is_invalid(val)) {
                        SIM_attr_free(&vals);
                        return val;
                }
                SIM_attr_list_set_item(&vals, i, val);
        }
        return vals;
}
static set_error_t
_setattr_from_portobj_array(lang_void *ptr, conf_object_t *obj,
                            attr_value_t *vals, attr_value_t *idx)
{
        ASSERT(SIM_attr_is_nil(*idx));
        _port_array_attr_t *port = (_port_array_attr_t *)ptr;
        uintptr_t port_obj_ptr_base = (uintptr_t)obj
                + port->port_obj_base_offset;
        for (uint32 i = 0; i < port->array_size; i++) {
                conf_object_t *port_obj = *(conf_object_t **)(
                        port_obj_ptr_base + (uint64)i * port->array_delta);
                attr_value_t val = SIM_attr_list_item(*vals, i);
                set_error_t err = port->set(NULL, port_obj, &val, NULL);
                if (err != Sim_Set_Ok) {
                        return err;
                }
        }
        return Sim_Set_Ok;
}
// port_obj_offset is the offset within the device struct of the first pointer
// to a port object. Pointers to remaining port object in the array are located
// array_delta bytes apart.
UNUSED static void
_register_port_array_attr(conf_class_t *devcls, conf_class_t *portcls,
                          ptrdiff_t port_obj_offset, ptrdiff_t array_delta,
                          uint32 array_size, bool is_bank,
                          const char *portname, const char *attrname,
                          get_attr_t getter, set_attr_t setter,
                          attr_attr_t attr, const char *type, const char *desc)
{
        _register_port_attr_no_aux(portcls, attrname,
                getter, setter, attr, type, desc);
        _port_array_attr_t *data = MM_MALLOC(1, _port_array_attr_t);
        data->port_obj_base_offset = port_obj_offset;
        data->get = getter;
        data->set = setter;
        data->array_size = array_size;
        data->array_delta = array_delta;
        // storing ptrdiff in uint32, overflow will not happen in practise
        ASSERT(data->array_delta == array_delta);
        char name[strlen(portname) + strlen(attrname) + 2];
        sprintf(name, "%s_%s", portname, attrname);
        strbuf_t proxy_desc = sb_newf("Proxy attribute for %s.%s[].%s",
                                      is_bank ? "bank" : "port",
                                      portname, attrname);
        strbuf_t proxy_type = sb_newf("[%s{%d}]", type, array_size);
        SIM_register_typed_attribute(
                devcls, name,
                getter ? _getattr_from_portobj_array : NULL, data,
                setter ? _setattr_from_portobj_array : NULL, data,
                (attr_attr_t)(Sim_Attr_Pseudo | Sim_Attr_Internal),
                sb_str(&proxy_type), NULL, sb_str(&proxy_desc));
        sb_free(&proxy_type);
        sb_free(&proxy_desc);
}

typedef struct {
        char *bufs[4];
        unsigned char i;
} dml_qname_cache_t;

#include <stdarg.h>

UNUSED PRINTF_FORMAT(2, 3) static const char *
__qname(dml_qname_cache_t *cache, const char *fmt, ...)
{
        va_list va;
        char *s;
        /* rotate between four buffers */
        if (!cache->bufs[cache->i])
                cache->bufs[cache->i] = MM_MALLOC(256, char);
        s = cache->bufs[cache->i];
        cache->i = (cache->i + 1) % 4;

        va_start(va, fmt);
        vsnprintf(s, 256, fmt, va);
        va_end(va);
        return (const char *)s;
}

static inline int
DML_pointer_eq(lang_void *data, lang_void *match_data)
{ return data == match_data; }

typedef bool (*_dml_reg_read_t)(void *dev, const uint16 *idx,
                                uint64 *result);
typedef bool (*_dml_reg_write_t)(void *dev, const uint16 *idx, uint64 val);
typedef struct {
        const char *name;
        unsigned dim;
        _dml_reg_read_t read;
        _dml_reg_write_t write;
} _dml_reg_t;

typedef struct {
        int64 num;
        uint32 reg;
        const uint16 *idx;
} _dml_reg_number_t;

static inline const _dml_reg_number_t *
_DML_find_regnum(const _dml_reg_number_t *map, uint32 maplen, uint32 regnum)
{
        uint32 i;
        for (i = 0; i < maplen; i++) {
                if (map[i].num == regnum)
                        return &map[i];
        }
        return NULL;
}

/* returns a static string */
static const char *
_DML_regname_unindexed(const _dml_reg_t *regs, const _dml_reg_number_t *map)
{
        const _dml_reg_t *reg = &regs[map->reg];

        if (reg->dim == 0)
                return reg->name;
        return NULL;
}

/* returns an allocated string to be freed by the caller */
static inline char *
_DML_regname_indexed(const _dml_reg_t *regs, const _dml_reg_number_t *map)
{
        const _dml_reg_t *reg = &regs[map->reg];

        strbuf_t name = SB_INIT;

        const char *src = reg->name;
        const uint16 *idxp = map->idx;
        
        for (int dim = reg->dim; dim > 0; dim--) {
                while (*src != '[')
                        sb_addc(&name, *src++);
                src++;
                sb_addfmt(&name, "[%u", *idxp++);
        }
        sb_addstr(&name, src);
        return sb_detach(&name);
}

static inline const char *
_DML_make_regname(const _dml_reg_t *regs, const _dml_reg_number_t *map)
{
        if (!map)
                return NULL;

        const char *name = _DML_regname_unindexed(regs, map);
        if (name)
                return name;                 /* statically allocated */
        else {
                /* Here we leak memory! We should probably put it in a
                   per-instance hash table instead. See bug 16901. */
                return _DML_regname_indexed(regs, map);
        }
}

static inline const _dml_reg_number_t *
_DML_find_regname(const _dml_reg_number_t *map, int maplen,
                  const char *name, const _dml_reg_t *regs)
{
        for (int i = 0; i < maplen; i++) {
                const char *name_unindexed =
                        _DML_regname_unindexed(regs, &map[i]);
                bool found = false;
                if (name_unindexed) {
                        found = (strcmp(name, name_unindexed) == 0);
                } else {
                        char *name_indexed = 
                                _DML_regname_indexed(regs, &map[i]);
                        found = (strcmp(name, name_indexed) == 0);
                        MM_FREE(name_indexed);
                }
                if (found)
                        return &map[i];
        }
        return NULL;
}

static inline uint64
_DML_read_reg(void *dev, const _dml_reg_number_t *map, const _dml_reg_t *regs)
{
        const _dml_reg_t *reg = &regs[map->reg];
        uint64 result;
        // This will currently ignore exceptions in getters
        reg->read(dev, map->idx, &result);
        return result;
}

static inline void
_DML_write_reg(void *dev, const _dml_reg_number_t *map, const _dml_reg_t *regs,
               uint64 val)
{
        const _dml_reg_t *reg = &regs[map->reg];
        // This will currently ignore exceptions in getters
        reg->write(dev, map->idx, val);
}

// This snipped is used from 1.4/dml-builtins.dml, mainly to avoid having to
// import sprintf into DML
static inline char *
_DML_describe_uint64_event(const char *base, uint64 data)
{
        char desc[strlen(base) + 25];
        sprintf(desc, "%s: %llu", base, data);
        return MM_STRDUP(desc);
}

typedef enum {
        Callback_Before_Read,
        Callback_After_Read,
        Callback_Before_Write,
        Callback_After_Write
} _callback_type_t;

typedef union _callback {
        before_read_callback_t before_read;
        after_read_callback_t after_read;
        before_write_callback_t before_write;
        after_write_callback_t after_write;
} _callback_t;

typedef struct _callback_entry {
        uint64 offset;
        uint64 size;
        lang_void *user_data;
        _callback_t callback;
} _callback_entry_t;

typedef VECT(_callback_entry_t *) _callback_vect_t;

typedef struct _connection_entry {
        conf_object_t *connection;
        bool enabled;

        _callback_vect_t before_read_callbacks;
        _callback_vect_t after_read_callbacks;
        _callback_vect_t before_write_callbacks;
        _callback_vect_t after_write_callbacks;
} _connection_entry_t;

typedef VECT(_connection_entry_t *) _connection_vect_t;

static _connection_entry_t *
_new_connection_entry(conf_object_t *connection)
{
        _connection_entry_t *entry = MM_ZALLOC(1, _connection_entry_t);
        entry->connection = connection;
        entry->enabled = true;
        return entry;
}

static _connection_entry_t *
_get_or_new_connection_entry(conf_object_t *connection,
                             _connection_vect_t *connections)
{
        _connection_entry_t *found = NULL;
        VFOREACH_T(*connections, _connection_entry_t *, cur) {
                if ((*cur)->connection == connection) {
                        found = *cur;
                        break;
                }
        }

        if (!found) {
                found = _new_connection_entry(connection);
                VADD(*connections, found);
        }

        return found;
}

static _callback_entry_t *
_new_callback_entry(uint64 offset, uint64 size, lang_void *user_data,
                    _callback_t callback)
{
        _callback_entry_t *entry = MM_ZALLOC(1, _callback_entry_t);
        entry->offset = offset;
        entry->size = size;
        entry->user_data = user_data;
        entry->callback = callback;

        return entry;
}

static bank_callback_handle_t
_register_callback(_callback_entry_t *entry, _callback_vect_t *callbacks)
{
        VADD(*callbacks, entry);
        return (bank_callback_handle_t)entry;
}

UNUSED static bank_callback_handle_t
_register_before_read(conf_object_t *bank,
                      conf_object_t *connection,
                      uint64 offset,
                      uint64 size,
                      before_read_callback_t before_read,
                      lang_void *user_data,
                      _connection_vect_t *connections,
                      _callback_vect_t *anonymous_callbacks)
{
        _callback_t callback = (_callback_t){.before_read = before_read};
        if (!connection) {
                return _register_callback(
                        _new_callback_entry(offset, size, user_data, callback),
                        anonymous_callbacks);
        }

        _connection_entry_t *entry = _get_or_new_connection_entry(connection,
                                                                  connections);
        return _register_callback(
                _new_callback_entry(offset, size, user_data, callback),
                &entry->before_read_callbacks);
}
UNUSED static bank_callback_handle_t
_register_after_read(conf_object_t *bank,
                     conf_object_t *connection,
                     uint64 offset,
                     uint64 size,
                     after_read_callback_t after_read,
                     lang_void *user_data,
                     _connection_vect_t *connections,
                     _callback_vect_t *anonymous_callbacks)
{
        _callback_t callback = (_callback_t){.after_read = after_read};
        if (!connection) {
                return _register_callback(
                        _new_callback_entry(offset, size, user_data, callback),
                        anonymous_callbacks);
        }

        _connection_entry_t *entry = _get_or_new_connection_entry(connection,
                                                                  connections);
        return _register_callback(
                _new_callback_entry(offset, size, user_data, callback),
                &entry->after_read_callbacks);
}

UNUSED static bank_callback_handle_t
_register_before_write(conf_object_t *bank,
                       conf_object_t *connection,
                       uint64 offset,
                       uint64 size,
                       before_write_callback_t before_write,
                       lang_void *user_data,
                       _connection_vect_t *connections,
                       _callback_vect_t *anonymous_callbacks)
{
        _callback_t callback = (_callback_t){.before_write = before_write};
        if (!connection) {
                return _register_callback(
                        _new_callback_entry(offset, size, user_data, callback),
                        anonymous_callbacks);
        }

        _connection_entry_t *entry = _get_or_new_connection_entry(connection,
                                                                  connections);
        return _register_callback(
                _new_callback_entry(offset, size, user_data, callback),
                &entry->before_write_callbacks);
}

UNUSED static bank_callback_handle_t
_register_after_write(conf_object_t *bank,
                      conf_object_t *connection,
                      uint64 offset,
                      uint64 size,
                      after_write_callback_t after_write,
                      lang_void *user_data,
                      _connection_vect_t *connections,
                      _callback_vect_t *anonymous_callbacks)
{
        _callback_t callback = (_callback_t){.after_write = after_write};
        if (!connection) {
                return _register_callback(
                        _new_callback_entry(offset, size, user_data, callback),
                        anonymous_callbacks);
        }

        _connection_entry_t *entry = _get_or_new_connection_entry(connection,
                                                                  connections);
        return _register_callback(
                _new_callback_entry(offset, size, user_data, callback),
                &entry->after_write_callbacks);
}

static bool
_remove_callback_from(bank_callback_handle_t callback,
                      _callback_vect_t *callbacks) {
        for (int i = 0; i < VLEN(*callbacks); ++i) {
                _callback_entry_t *entry = VGET(*callbacks, i);
                if ((bank_callback_handle_t)entry == callback) {
                        MM_FREE(entry);
                        VDELETE_ORDER(*callbacks, i);
                        return true;
                }
        }
        return false;
}

UNUSED static void
_remove_callback(bank_callback_handle_t callback,
                 _connection_vect_t *connections,
                 _callback_vect_t *anonymous_before_read,
                 _callback_vect_t *anonymous_after_read,
                 _callback_vect_t *anonymous_before_write,
                 _callback_vect_t *anonymous_after_write)
{
        VECT(_callback_vect_t *) all_callbacks = VNULL;
        VADD(all_callbacks, anonymous_before_read);
        VADD(all_callbacks, anonymous_after_read);
        VADD(all_callbacks, anonymous_before_write);
        VADD(all_callbacks, anonymous_after_write);

        VFOREACH_T(*connections, _connection_entry_t *, entry) {
                VADD(all_callbacks, &(*entry)->before_read_callbacks);
                VADD(all_callbacks, &(*entry)->after_read_callbacks);
                VADD(all_callbacks, &(*entry)->before_write_callbacks);
                VADD(all_callbacks, &(*entry)->after_write_callbacks);
        }

        VFOREACH_T(all_callbacks, _callback_vect_t *, callbacks) {
                if (_remove_callback_from(callback, *callbacks)) {
                        break;
                }
        }

        VFREE(all_callbacks);
}

static void
_free_callbacks(_callback_vect_t *callbacks)
{
        for (int i = 0; i < VLEN(*callbacks); ++i) {
                _callback_entry_t *entry = VGET(*callbacks, i);
                MM_FREE(entry);
        }
}

static void
_free_connection(_connection_entry_t *entry)
{
        _free_callbacks(&entry->before_read_callbacks);
        _free_callbacks(&entry->after_read_callbacks);
        _free_callbacks(&entry->before_write_callbacks);
        _free_callbacks(&entry->after_write_callbacks);
        MM_FREE(entry);
}

UNUSED static void
_remove_connection_callbacks(conf_object_t *bank,
                             conf_object_t *connection,
                             _connection_vect_t *connections)
{
        VFORI(*connections, i) {
                _connection_entry_t *entry = VGET(*connections, i);
                if (entry->connection == connection) {
                        _free_connection(entry);
                        VDELETE_ORDER(*connections, i);
                        break;
                }
        }
}

static void
_toggle_connection(conf_object_t *connection,
                   _connection_vect_t *connections,
                   bool enable)
{
        VFOREACH_T(*connections, _connection_entry_t *, entry) {
                if ((*entry)->connection == connection) {
                        (*entry)->enabled = enable;
                        break;
                }
        }
}

UNUSED static void
_enable_connection_callbacks(conf_object_t *connection,
                             _connection_vect_t *connections)
{
        _toggle_connection(connection, connections, true);
}

UNUSED static void
_disable_connection_callbacks(conf_object_t *connection,
                              _connection_vect_t *connections)
{
        _toggle_connection(connection, connections, false);
}

UNUSED static attr_value_t
_get_connections(_connection_vect_t *connections)
{
        attr_value_t v = SIM_alloc_attr_list(VLEN(*connections));
        for (int i = 0; i < VLEN(*connections); ++i) {
                _connection_entry_t *entry = VGET(*connections, i);
                SIM_attr_list_set_item(&v, i,
                                       SIM_make_attr_object(entry->connection));
        }
        return v;
}

static int
_connection_idx(conf_object_t *connection, _connection_vect_t *connections)
{
        for (int idx = 0; idx < VLEN(*connections); ++idx) {
                _connection_entry_t *entry = VGET(*connections, idx);
                if (entry->connection == connection) {
                        return idx;
                }
        }
        return -1;
}

UNUSED static bool
_move_before(conf_object_t *connection,
             conf_object_t *before,
             _connection_vect_t *connections)
{
        if (connection == before) {
                return false;
        }

        int connection_idx = _connection_idx(connection, connections);
        if (connection_idx < 0) {
                return false;
        }

        _connection_entry_t *connection_entry = VGET(*connections,
                                                     connection_idx);
        VDELETE_ORDER(*connections, connection_idx);
        if (_connection_idx(before, connections) < 0) {
                VADD(*connections, connection_entry);
        } else {
                int before_idx = _connection_idx(before, connections);
                VINSERT(*connections, before_idx, connection_entry);
        }

        return true;
}

static bool
_in_range(physical_address_t instr_offset,
          physical_address_t instr_size,
          uint64 access_offset, uint64 access_size)
{
        if (instr_offset <= (access_offset + access_size - 1)
            && (instr_offset + instr_size - 1) >= access_offset) {
                return true;
        }
        return false;
}

struct bank_access {
        conf_object_t *bank;
        bool *inquiry;
        physical_address_t *offset;
        physical_address_t size;

        uint64 *value;
        bool *success;
        bool *suppress;
};

static void
_inquire(bank_access_t *handle)
{
        *handle->inquiry = true;
}

static bool
_is_miss(bank_access_t *handle)
{
        return !*handle->success;
}
static void
_set_miss(bank_access_t *handle, bool missed)
{
        *handle->success = !missed;
}

static physical_address_t
_offset(bank_access_t *handle)
{
        return *handle->offset;
}
static void
_set_offset(bank_access_t *handle, physical_address_t offset)
{
        *handle->offset = offset;
}

static physical_address_t
_size(bank_access_t *handle)
{
        return handle->size;
}

static void
_set_suppress(bank_access_t *handle)
{
        *handle->suppress = true;
}

static uint64
_value(bank_access_t *handle)
{
        return *handle->value;
}
static uint64
_value_unless_miss(bank_access_t *handle) {
        if (_is_miss(handle)) {
                SIM_LOG_ERROR(handle->bank, 0,
                              "Forbidden to read value if the access missed");
        }
        return _value(handle);
}

static void
_set_value(bank_access_t *handle, uint64 value)
{
        *handle->value = value;
}
static void
_set_value_and_forgive_miss(bank_access_t *handle, uint64 value) {
        _set_value(handle, value);
        _set_miss(handle, false);
}

static void
_issue_callback(_callback_type_t type,
                _callback_entry_t *callback,
                bank_access_t *handle,
                conf_object_t *connection)
{
        switch (type) {
        case Callback_Before_Read:
        {
                bank_before_read_interface_t bank_before_read_interface = {
                        .offset = _offset,
                        .size = _size,
                        .set_offset = _set_offset,
                        .inquire = _inquire};
                callback->callback.before_read(connection,
                                               &bank_before_read_interface,
                                               handle,
                                               callback->user_data);
        }
                break;
        case Callback_After_Read:
        {
                bank_after_read_interface_t bank_after_read_interface = {
                        .offset = _offset,
                        .size = _size,
                        .missed = _is_miss,
                        .value = _value_unless_miss,
                        .set_missed = _set_miss,
                        .set_value = _set_value_and_forgive_miss};
                callback->callback.after_read(
                        connection, &bank_after_read_interface,
                        handle,
                        callback->user_data);
        }
                break;
        case Callback_Before_Write:
        {
                bank_before_write_interface_t bank_before_write_interface = {
                        .offset = _offset,
                        .size = _size,
                        .value = _value,
                        .suppress = _set_suppress,
                        .set_offset = _set_offset,
                        .set_value = _set_value};
                callback->callback.before_write(
                        connection, &bank_before_write_interface,
                        handle,
                        callback->user_data);
        }
                break;
        case Callback_After_Write:
        {
                bank_after_write_interface_t bank_after_write_interface = {
                        .offset = _offset,
                        .size = _size,
                        .missed = _is_miss,
                        .set_missed = _set_miss};
                callback->callback.after_write(connection,
                                               &bank_after_write_interface,
                                               handle,
                                               callback->user_data);
        }
                break;
        }
}

static void
_issue_callbacks(_callback_type_t type,
                 bank_access_t *handle,
                 conf_object_t *connection,
                 _callback_vect_t *callbacks)
{
        for (int i = 0; i < VLEN(*callbacks); ++i) {
                _callback_entry_t *callback = VGET(*callbacks, i);
                if (!_in_range(callback->offset, callback->size,
                               *handle->offset, handle->size)) {
                        continue;
                }
                _issue_callback(type, callback, handle, connection);
        }
}

static _callback_vect_t *
_connection_callbacks(_connection_entry_t *entry, _callback_type_t type)
{
        switch (type) {
        case Callback_Before_Read:
                return &entry->before_read_callbacks;
        case Callback_After_Read:
                return &entry->after_read_callbacks;
        case Callback_Before_Write:
                return &entry->before_write_callbacks;
        case Callback_After_Write:
                return &entry->after_write_callbacks;
        }
        ASSERT(0);
}

static void
_issue_callbacks_for_type(conf_object_t *bank,
                          _connection_vect_t *connections,
                          _callback_vect_t *anonymous_callbacks,
                          bank_access_t *handle,
                          _callback_type_t type)
{
        // although anonymous banks cannot be instrumented, they get this far
        if (!bank) {
                return;
        }

        _issue_callbacks(type, handle, NULL, anonymous_callbacks);
        VFOREACH_T(*connections, _connection_entry_t *, entry) {
                if (!(*entry)->enabled) {
                        continue;
                }
                _issue_callbacks(type, handle, (*entry)->connection,
                                 _connection_callbacks(*entry, type));
        }
}

UNUSED static void
_callback_before_read(conf_object_t *bank,
                      bool *inquiry,
                      physical_address_t *offset,
                      physical_address_t size,
                      _connection_vect_t *connections,
                      _callback_vect_t *anonymous_callbacks)
{
        bank_access_t access = {
                .bank = bank,
                .inquiry = inquiry,
                .offset = offset,
                .size = size};
        _issue_callbacks_for_type(bank, connections, anonymous_callbacks,
                                  &access,
                                  Callback_Before_Read);
}
UNUSED static void
_callback_after_read(conf_object_t *bank,
                     physical_address_t *offset,
                     physical_address_t size,
                     uint64 *value,
                     bool *success,
                     _connection_vect_t *connections,
                     _callback_vect_t *anonymous_callbacks)
{
        bank_access_t access = {
                .bank = bank,
                .inquiry = NULL,
                .offset = offset,
                .size = size,
                .value = value,
                .success = success};
        _issue_callbacks_for_type(bank, connections, anonymous_callbacks,
                                  &access,
                                  Callback_After_Read);
}

UNUSED static void
_callback_before_write(conf_object_t *bank,
                       physical_address_t *offset,
                       physical_address_t size,
                       uint64 *value,
                       bool *suppress,
                       _connection_vect_t *connections,
                       _callback_vect_t *anonymous_callbacks)
{
        bank_access_t access = {
                .bank = bank,
                .inquiry = NULL,
                .offset = offset,
                .size = size,
                .value = value,
                .suppress = suppress};
        _issue_callbacks_for_type(bank, connections, anonymous_callbacks,
                                  &access,
                                  Callback_Before_Write);
}
UNUSED static void
_callback_after_write(conf_object_t *bank,
                      physical_address_t *offset,
                      physical_address_t size,
                      bool *success,
                      _connection_vect_t *connections,
                      _callback_vect_t *anonymous_callbacks)
{
        bank_access_t access = {
                .bank = bank,
                .inquiry = NULL,
                .offset = offset,
                .size = size,
                .success = success};
        _issue_callbacks_for_type(bank, connections, anonymous_callbacks,
                                  &access,
                                  Callback_After_Write);
}

UNUSED static set_error_t
_set_device_member(attr_value_t val,
                   char *ptr,
                   const uint32 *dimension_sizes,
                   const uint32 *dimension_strides,
                   unsigned int remaining_dimensions,
                   set_error_t (*setter)(attr_value_t *val, void *addr)) {
        if (remaining_dimensions == 0) {
                return setter(&val, (void*)ptr);
        } else {
                for (unsigned i = 0; i < dimension_sizes[0]; ++i) {
                        set_error_t status = _set_device_member(
                            SIM_attr_list_item(val, i),
                            ptr + dimension_strides[0] * i,
                            &dimension_sizes[1],
                            &dimension_strides[1],
                            remaining_dimensions-1,
                            setter);
                        // currently, generated deserialized cannot fail
                        ASSERT(status == Sim_Set_Ok);
                }
                return Sim_Set_Ok;
        }
}

UNUSED static attr_value_t
_get_device_member(char *ptr,
                   const uint32 *dimension_sizes,
                   const uint32 *dimension_strides,
                   unsigned int remaining_dimensions,
                   void (*getter)(void *addr, attr_value_t *target)) {
        attr_value_t to_return;
        if (remaining_dimensions == 0) {
                getter((void*)ptr, &to_return);
        } else {
                to_return = SIM_alloc_attr_list(dimension_sizes[0]);
                attr_value_t im_attr;
                for (unsigned i = 0; i < dimension_sizes[0]; ++i) {
                        im_attr = _get_device_member(
                            ptr + dimension_strides[0] * i,
                            &dimension_sizes[1],
                            &dimension_strides[1],
                            remaining_dimensions-1,
                            getter);
                        SIM_attr_list_set_item(&to_return, i, im_attr);
                }
        }
        return to_return;
}

typedef struct {
        ptrdiff_t relative_base;
        // excluding port dimensions
        unsigned int ndims;
        // excluding port dimensions
        const uint32 *dimension_sizes;
        // including port dimensions
        const uint32 *dimension_strides;
        set_error_t (*setter)(attr_value_t *val, void *addr);
        void (*getter)(void *addr, attr_value_t *val);
} _saved_userdata_t;

UNUSED static set_error_t
_set_saved_variable(lang_void *saved_access, conf_object_t *obj,
                    attr_value_t *val, attr_value_t *_) {
        _saved_userdata_t *acc = (_saved_userdata_t *) saved_access;
        return _set_device_member(*val,
                                  (char *)obj + acc->relative_base,
                                  acc->dimension_sizes,
                                  acc->dimension_strides,
                                  acc->ndims,
                                  acc->setter);
}

UNUSED static attr_value_t
_get_saved_variable(lang_void *saved_access, conf_object_t *obj,
                    attr_value_t *_) {
        _saved_userdata_t *acc = (_saved_userdata_t *) saved_access;
        return _get_device_member((char *)obj + acc->relative_base,
                                  acc->dimension_sizes,
                                  acc->dimension_strides,
                                  acc->ndims,
                                  acc->getter);
}

UNUSED static set_error_t
_set_port_saved_variable(lang_void *saved_access, conf_object_t *_portobj,
                         attr_value_t *val, attr_value_t *_) {
        _port_object_t *portobj = (_port_object_t *)_portobj;
        conf_object_t *obj = portobj->dev;
        _saved_userdata_t *acc = (_saved_userdata_t *) saved_access;
        char *ptr = (char *)obj + acc->relative_base;
        for (int i = 0; i < portobj->ndims; ++i) {
                ptr += portobj->indices[i] * acc->dimension_strides[i];
        }
        return _set_device_member(*val,
                                  ptr,
                                  acc->dimension_sizes,
                                  acc->dimension_strides + portobj->ndims,
                                  acc->ndims,
                                  acc->setter);
}

UNUSED static attr_value_t
_get_port_saved_variable(lang_void *saved_access, conf_object_t *_portobj,
                         attr_value_t *_) {
        _port_object_t *portobj = (_port_object_t *)_portobj;
        conf_object_t *obj = portobj->dev;
        _saved_userdata_t *acc = (_saved_userdata_t *) saved_access;
        char *ptr = (char *)obj + acc->relative_base;
        for (int i = 0; i < portobj->ndims; ++i) {
                ptr += portobj->indices[i] * acc->dimension_strides[i];
        }
        return _get_device_member(ptr,
                                  acc->dimension_sizes,
                                  acc->dimension_strides + portobj->ndims,
                                  acc->ndims,
                                  acc->getter);
}

// The internal format for ht is:
// dict(trait_identifier -> dict(statement_idx -> bool))
UNUSED static uint64 _select_log_level(ht_int_table_t *ht,
                                       uint64 first_key,
                                       uint64 second_key,
                                       uint64 first,
                                       uint64 subsequent) {
        ht_int_table_t *sub_table = (ht_int_table_t*)
                ht_lookup_int(ht, first_key);
        if (!sub_table) {
                sub_table = MM_MALLOC(1, ht_int_table_t);
                ht_init_int_table(sub_table);
                ht_insert_int(ht, first_key, (void*)sub_table);
                ht_insert_int(sub_table, second_key, (void*)1);
                return first;
        } else {
                if (!ht_lookup_int(sub_table, second_key)) {
                        ht_insert_int(sub_table, second_key, (void*)1);
                        return first;
                }
        }
        return subsequent;
}

UNUSED static int _free_sub_table(ht_int_table_t *table,
                                  uint64 key, void *val, void *_) {
        ht_clear_int_table(table, false);
        return 0;
}

UNUSED static void _free_table(ht_int_table_t *table) {
        ht_for_each_entry_int(table, _free_sub_table, NULL);
        ht_clear_int_table(table, true);
}

#endif
